<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://goroyal.github.io/</id>
    <title>Goroyal&apos;s blog</title>
    <updated>2020-05-21T16:01:50.600Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://goroyal.github.io/"/>
    <link rel="self" href="https://goroyal.github.io/atom.xml"/>
    <subtitle>学习分享</subtitle>
    <logo>https://goroyal.github.io/images/avatar.png</logo>
    <icon>https://goroyal.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Goroyal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Linux 中的 2> /dev/null]]></title>
        <id>https://goroyal.github.io/post/linux-redirect-dev-null/</id>
        <link href="https://goroyal.github.io/post/linux-redirect-dev-null/">
        </link>
        <updated>2020-05-21T15:12:33.000Z</updated>
        <summary type="html"><![CDATA[<p>在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：</p>
<pre><code class="language-shell">2&gt; /dev/null
</code></pre>
<p>这是何意？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：</p>
<pre><code class="language-shell">2&gt; /dev/null
</code></pre>
<p>这是何意？</p>
 <!-- more --> 
<h2 id="linux-进程">Linux 进程</h2>
<p>以 bash 为例，shell 中执行一个命令时，其实是由 bash shell fork 出一个子进程，然后在这个子进程中运行相应的命令，直至退出。Linux 里的进程的数据结构如下：</p>
<pre><code class="language-C">struct task_struct {
	// 进程状态
	long state;
	// 虚拟内存结构体
	struct mm_struct *mm;
	// 进程号
	pid_t pid;
	// 指向父进程的指针
	struct task_struct __rcu *parent;
	// 子进程列表
	struct list_head children;
	// 存放文件系统信息的指针
	struct fs_struct *fs;
	// 一个数组，包含该进程打开的文件指针
	struct files_struct *files;
};
</code></pre>
<p><code>task_struct</code> 就是 Linux 对于一个进程的描述，也可以称之为进程描述符。其中的 <code>files</code> 指针指向一个数组，表示当前进程打开的所有文件。</p>
<p><strong>每个进程被创建时，<code>files</code> 指向的数组前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。</strong></p>
<p>:::<strong>tip</strong></p>
<blockquote>
<p>Linux 中的所有设备都是抽象成文件的，设备可以当作文件一样读和写。</p>
</blockquote>
<h2 id="重定向">重定向</h2>
<p>Linux shell 里通过 <code>&gt;</code>、<code>&lt;</code>进行输出、输入的重定向。</p>
<ul>
<li><code>&gt;</code>：将 shell 命令的输出指向某个地方，可以是文件，也可以是内存里的某个变量。比如 <code>ls -l &gt; file.txt</code> 就是把当前路径下的文件信息保存到 file.txt 文本中，如果没有这个重定向，它会将结果输出到显示器屏幕上。</li>
<li><code>&lt;</code>：从某个地方读取内容作为 shell 命令的输入，可以是文件，也可以是内存里的某个变量。比如 <code>{command} &lt; file.txt</code>，如果没有这个重定向，它会从键盘读取输入。</li>
</ul>
<p>此外，shell 还可以通过 <code>|</code> 将前一个命令的输出作为下一个命令的输入，比如：</p>
<pre><code class="language-shell"># 在命令历史中找到包含 ssh 字符串的命令
history | grep ssh
</code></pre>
<h2 id="2-devnull">2&gt; /dev/null</h2>
<p>通过上面的章节可以知道，<code>2</code> 表示标准错误，<code>&gt;</code> 表示将标准错误重定向到某个地方。</p>
<p><code>/dev/null</code> 是一个特殊文件，在Unix系统中称为 null 设备。 通俗地说，它也称为比特桶（bit bucket，也译作比特垃圾桶）或黑洞（blackhole），因为它会立即丢弃写入其中的任何内容，并且在读取时仅返回文件结束EOF。</p>
<p>所以这个命令合起来就是将忽略执行命令产生的错误。比如：</p>
<pre><code class="language-shell"># 删除当前路径下的folder目录，如果不存在则忽略错误
rm -r folder 2&gt; /dev/null
</code></pre>
<p>:::<strong>caution</strong></p>
<blockquote>
<p><code>2</code>和<code>&gt;</code>之间不能有空格</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://bash.cyberciti.biz/guide/What_is_a_Process%3F">What is a Process?</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">Linux的进程、线程、文件描述符是什么</a></li>
<li><a href="https://zh.wikipedia.org/wiki//dev/null">维基百科：/dev/null</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象编程与纯函数]]></title>
        <id>https://goroyal.github.io/post/oop-and-pure-function/</id>
        <link href="https://goroyal.github.io/post/oop-and-pure-function/">
        </link>
        <updated>2019-06-26T16:51:40.000Z</updated>
        <content type="html"><![CDATA[<p>在面向对象编程里面，我们常常对现实世界建模抽象成一个个类，然后创建它们的对象，通过对象的方法行为去描述逻辑。</p>
<p>纯函数是一种特殊的函数，给它相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>
<hr>
<p>占位符，待更。</p>
<p>https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1<br>
https://www.jiqizhixin.com/articles/2018-10-22-15</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[管理多个Java版本]]></title>
        <id>https://goroyal.github.io/post/manage-multiple-java-versions/</id>
        <link href="https://goroyal.github.io/post/manage-multiple-java-versions/">
        </link>
        <updated>2019-06-26T16:30:26.000Z</updated>
        <content type="html"><![CDATA[<p>自从Oracle宣布Java开始收费之后，越来越多的人会考虑从<a href="https://openjdk.java.net/install/">Open JDK</a>下载安装Java环境。可能自己机器上也会同时并存好几个Java版本，本文以macOS为例介绍一下如何从Open JDK安装并进行管理多版本。</p>
<h2 id="下载安装">下载安装</h2>
<pre><code class="language-shell">curl -O https://download.java.net/java/GA/jdk12/33/GPL/openjdk-12_osx-x64_bin.tar.gz 
tar xvf openjdk-12_osx-x64_bin.tar.gz

# 解压后文件夹比如名为jdk-12.jdk，移动到macOS管理的JVM目录中去
sudo mv jdk-12.jdk /Library/Java/JavaVirtualMachines
</code></pre>
<p>此时，可以输入如下命令查看本机上有几种Java版本：</p>
<pre><code class="language-shell">/usr/libexec/java_home -V
</code></pre>
<p>比如生成如下内容：</p>
<pre><code>Matching Java Virtual Machines (2):
    12, x86_64:	&quot;OpenJDK 12&quot;	/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home
    1.7.0_76, x86_64:	&quot;Java SE 7&quot;	/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home
</code></pre>
<p>也可以输入小写v参数查看具体的版本信息，比如查刚刚下载的Java 12：</p>
<pre><code class="language-shell">/usr/libexec/java_home -v 12
</code></pre>
<p>会显示<code>/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home</code>，这个就是它的Java Home。那么就能通过export设置当前的JAVA_HOME环境变量了。比如：</p>
<pre><code>export JAVA_HOME=`/usr/libexec/java_home -v 12`
</code></pre>
<h2 id="便利管理多版本">便利管理多版本</h2>
<p>Linux或者macOS都有bash或者其他shell，以bash为例，bash在每个用户目录下都有<code>.bashrc</code>文件用于配置用户相关的环境变量（如果没有可以自己创建），可以在该文件下面写如下代码：</p>
<pre><code class="language-shell"># type 'java7' at command prompt to switch to java 7
function java7() {
    export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
    echo &quot;JAVA_HOME is $JAVA_HOME&quot;
    java -version
}

# type 'java12' at command prompt to switch to java 12
function java12() {
    export JAVA_HOME=`/usr/libexec/java_home -v 12`
    echo &quot;JAVA_HOME is $JAVA_HOME&quot;
    java -version
}
</code></pre>
<p>保存之后，输入命令<code>source .bashrc</code>，然后可以通过命令<code>java12</code>或者<code>java7</code>来便捷切换所使用的Java版本。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try with closable resources]]></title>
        <id>https://goroyal.github.io/post/Try with closable resources/</id>
        <link href="https://goroyal.github.io/post/Try with closable resources/">
        </link>
        <updated>2019-06-17T14:41:03.000Z</updated>
        <content type="html"><![CDATA[<p>以前，拿到一个closable资源后，如果对它操作，都要先用try包起来，最后一定要在finally里面关掉：</p>
<pre><code class="language-java">Closable resource = xxx; //此处为得到这个resource的逻辑
try {
	// 处理逻辑
} finally {
	if (resource != null) {
		try {
			resource.close();
	}
}
</code></pre>
<p>自从Java 7之后，根据官方文档<a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">tryResouceClose</a>，任何实现了<code>java.lang.AutoClosable</code>，以及<code>java.io.Closable</code>接口的对象都可以在这段代码结束之后被关掉：</p>
<pre><code class="language-java">try (Closable resource = xxx) {
	// 处理逻辑
}
</code></pre>
<p>.NET里面也有个类似的用法，C#里面一般实现了IDisposable接口的对象在使用时最好结束后调用它的dispose方法，也可以使用using的方式来帮助回收：</p>
<pre><code class="language-csharp">using (IDisposable resource = xxx) {
	// 处理逻辑
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以单元测试的角度聊聊写代码]]></title>
        <id>https://goroyal.github.io/post/wring-code-from-unit-test-side/</id>
        <link href="https://goroyal.github.io/post/wring-code-from-unit-test-side/">
        </link>
        <updated>2019-05-24T12:25:28.000Z</updated>
        <content type="html"><![CDATA[<p>单元测试，也就是对代码较细粒度单元的测试，一般就是测某个方法或函数。说到单元测试，基本上每个开发者都不陌生，时不时会听到“测试覆盖率太低了！”，然后“We need to increase our code coverage!”。经常出bug？好好准备测试吧。</p>
<h2 id="1-为什么要提高覆盖率">1. 为什么要提高覆盖率？</h2>
<p>覆盖率为什么这么重要？我们每次修改代码之后都不希望把原有可用的功能搞出问题，如果没有足够的测试覆盖，开发者就没有足够的信心去交付新代码。测试覆盖率高的话，就可以用机器自动去跑高效率地去验证，在覆盖不到的地方需要人工去验证。所以当覆盖率很低的时候，人工需要一遍又一遍的去验证已有的功能，还要去验证新加的功能是否符合预期，这个真的会崩溃。开发者自己去做的话，八成会偷懒抑或是觉得自己改的范围影响不到那么多测得乐观。如果让测试工程师去做，那么需要领导们考虑开发跟测试的比例了。</p>
<p>测试覆盖率不完全是看单元测试，还包括更高层次的集成测试、系统测试。当然了，如果单元测试没写多少，指望粒度更粗层次更高的其他测试，你会非常痛苦的。单元测试的2个优势：跑得快、容易定位问题。</p>
<p>上面说了这么多，就是在强调单元测试覆盖率一定要尽可能高，每个单元测试职责一定要尽可能单一简单。单元测试覆盖无非就是代码行覆盖、分支覆盖，单元测试职责单一简单是说单元测试不要试图测某个方法的所有可能性，多写几个，这样出了问题能根据测试名字迅速找到为什么什么用例失败了以及被测方法的哪行可能有问题。</p>
<h2 id="2-单元测试为何难写">2. 单元测试为何难写？</h2>
<p>你可能听说过“测试驱动开发”，就是先写测试、后写代码，这个要求在写代码之前先好好分析需求、细化用例，把各个用例的测试写出来，每次改动代码都要求让尽可能多的测试结果为绿（成功），直到最后所有测试都绿了，那么代码的功能上也基本没问题了。这个可以了解下，有兴趣多看看这方面拓展一下。<br>
<img src="https://goroyal.github.io//post-images/1560780095750.png" alt="" loading="lazy"></p>
<p>为什么单元测试覆盖率往往上不去？因为有时候真的不好写。什么样的代码不好写单元测试：</p>
<ol>
<li>被测方法传入了比较复杂的类的对象参数（不是依赖接口），当我要测这个方法，我就要去new依赖的那个对象，但是那个对象又依赖其他的，我又要接着new……，可能这个方法还没开始测，光创建它依赖的东西就写了一大堆测试代码。</li>
<li>被测方法传入了某个对象作为参数，调用的复杂方法（不是依赖接口），这个方法有多复杂？可能它也跟上面一样也要new很多个对象才能跑起来，或者它调用了外部服务（网络、数据库等等）。简直没法测。</li>
<li>被测方法自己内部创建了一些复杂对象、或者这个方法所属对象的实例创建了一些复杂对象，往往可能是外部有依赖的，比如对文件系统、数据库、网络等有调用。</li>
<li>被测方法自己内部引用了static变量。</li>
<li>被测方法自己内部引用了单例对象。</li>
<li>被测方法调用了复杂的static方法，无法mock、无法用桩。</li>
<li>被测方法是一个static方法，它可能依赖一个或多个static变量，这个变量还会被其他static方法修改，很难保证当前测试的独立性，包括它本身作为生产代码都是有坑的。</li>
<li>被测方法传入了对象参数，考虑用桩了，但是发现那个类或者方法是final的，无法继承重写（如果是C#语言，sealed类无法被继承，无override关键字的方法不能被重写）。</li>
<li>被测方法本身太长了，很难面面俱到，或者是单元测试出了错之后不好定位是哪行代码引起的问题</li>
</ol>
<h2 id="3-如何写好单元测试">3. 如何写好单元测试</h2>
<p><strong>单元测试应该聚焦于被测方法本身的行为</strong>，而不是被测方法所依赖的其他对象的行为。外部环境有依赖的代码应该尽可能少，并且尽量去调用接口，而不是具体的类。我们经常会听到“面向接口编程”，这个用了之后，写单元测试真的是非常爽。单元测试里面会用mock库或者自己去创建简单的类去模拟某个方法的行为，接口约定根据输入会产生什么样的输出，对于调用接口的方法而言不必去关心具体的实现是什么。Java里有著名的Mockito，C#里有Moq，用起来如行云流水一般。</p>
<p><strong>方法或者类构造器里面自己创建的对象不能太复杂</strong>，复杂了你就没法测了。可以考虑调用该对象的接口，将它作为输入参数，那么就可以用上面说的方式去测了。</p>
<p>个人理解，<strong>static方法要尽可能做到纯函数化</strong>，也就是说一样的输入参数，随便什么情况下调用都应该给一样的输出。这其实就要求static这样的静态方法不要依赖不可控的static变量。如果做不到，尽量缩小它的使用范围吧……普通的实例方法调用static方法尽可能只调用简单的，没事别调用public的static变量，调用不受控制的static变量简直是给自己找麻烦，不可测是一方面，运行时被别的代码改掉的话就是灾难了。</p>
<p><strong>当被测方法太长的时候，实际上就意味着方法要拆了</strong>，便于理解和维护。可以正常的拆，比如新建方法、新建类，也可以花哨地拆。有些人写了一堆if、else语句，如果是创建对象相关的，是否可以考虑工厂模式了？如果if、else里面是比较长的逻辑，可以考虑用策略模式。而如果是普通的前后累积的代码很长，要不试试责任链模式？当拆完之后，原本的非常长的不好测的方法变成若干个易测的小方法。覆盖率自然就上去了。</p>
<h2 id="4-结语">4. 结语</h2>
<p>当每层代码都经过单元测试确保自己这层没问题之后，整个逻辑的链条其实问题不大了。覆盖率不是简简单单为了覆盖而覆盖，单元测试都要有断言，就是如果跟测试目的产生不一致的结果这个测试必须显示失败，否则光数据好看是没用的。<strong>单元测试也不可能做到100%覆盖，但是可以尽可能做得高</strong>，覆盖不到的地方再通过集成测试或者系统层面的测试去做。至于做不到100%覆盖的原因，比如代码里有对外部依赖的地方，再怎么抽离，总有地方需要去初始化。那么对于这个情况，尽可能把这个对外依赖范围缩小，其他地方用的时候传递接口。</p>
<p>关于面向接口编程和减少耦合，还可以了解下依赖注入，能帮助解耦调用模块和具体实现类模块。</p>
<p>为了代码可扩展性高、良好设计、易测试，可能会出现一个复杂业务逻辑的代码一层套一层的情况，一个逻辑看完可能经历了若干个类，这也是人们常常吐槽的Java这种语言的一个“啰嗦”之处。这个我也没有什么更好的想法，如果你有，可以分享一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 响应状态码]]></title>
        <id>https://goroyal.github.io/post/http-response-code/</id>
        <link href="https://goroyal.github.io/post/http-response-code/">
        </link>
        <updated>2019-04-06T12:14:38.000Z</updated>
        <content type="html"><![CDATA[<p>目前HTTP在Web开发中被广泛使用，REST (Representational State Transfer) 很多人应该或多或少都知道些。当然了，比较熟悉的可能主要是GET、POST方法。这篇文章不是介绍REST的定义和如何创建符合REST风格的API，而是讲讲在Web开发中通用的不同HTTP响应状态码的含义。在普通网站开发、分布式集群开发、团队协作方面，如果采用了HTTP作为组件之间交互的协议，遵守通用的响应状态码是很有必要的（一是有充分的信息量、二是避免歧义）。</p>
<p>HTTP响应状态共有5大类，分别是数字1、2、3、4、5开头。</p>
<h2 id="1xx">1XX</h2>
<p>信息性状态码，表示接收的请求正在处理。</p>
<ul>
<li>100：说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应</li>
<li>101：说明服务器正在根据客户端的指定，将协议切换成Update 首部所列的协议</li>
</ul>
<h2 id="2xx">2XX</h2>
<p>成功状态码，表示请求正常处理完毕</p>
<ul>
<li>200：OK，实体的主体部分包含了所请求的资源。（正常请求很多是这种状态）</li>
<li>201： Created，表示创建资源成功，响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location 首部包含的则是最具体的引用。（REST里面，POST或者PUT常常返回这样的状态）</li>
<li>202， Accepted， 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。</li>
<li>204：No Content，响应不包含实体的主体部分，通常在更新服务器上资源的时候成功的情况下不要求返回实体内容就会产生这个状态码。</li>
<li>206：Partial Content，成功执行了一个部分或Range（范围）请求。</li>
</ul>
<h2 id="3xx">3XX</h2>
<p>重定向状态码，表示需要进行附加操作以完成请求。</p>
<ul>
<li>301：Moved Permanently，永久性重定向，表示请求的资源被分配了新的URI，以后应使用资源现在所指的URI。</li>
<li>302：Found，临时性重定向，表示请求的资源被分配了新的URI，希望用户本次使用新的URI访问。</li>
<li>303：See Other，表示请求对应的资源存在这另一个URI，应使用GET方法定向获取请求的资源。</li>
<li>304：Not Modified，表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件。304状态码返回时不包含响应的主体部分（附带条件指：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）。304表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题。另一种情况是,如果服务器认为客户端缓存的资源已经过期了，那么服务器就会返回HTTP/200 OK响应，响应体就是该资源当前最新的内容。客户端收到200响应后，就会用新的响应体覆盖掉旧的缓存资源。</li>
<li>305：Use Proxy， 用来说明必须通过一个代理来访问资源；代理的位置由Location首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞。</li>
<li>307：Temporary Redirect，临时重定向，与302有相同的含义。尽管302标准禁止POST变幻成GET，实际大家并未遵守。307会遵照浏览器标准，不会从POST变为GET，但是对于处理响应时的行为每种浏览器可能出现不同的情况。</li>
</ul>
<h2 id="4xx">4XX</h2>
<p>客户端错误状态码，表示服务器无法处理请求。</p>
<ul>
<li>400：Bad Request， 用于告知客户端它发送了一个错误的请求，比方说请求体不符合预先定义的规则</li>
<li>401：Unauthorized，表示发送的请求需要有通过HTTP认证的认证信息，若之前已进行过请求，则表示认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate手部质询用户信息。</li>
<li>403：Forbidden，表明请求资源的访问被服务器拒绝了。</li>
<li>404：Not Found，用于说明服务器无法找到请求的URL所对应的资源。</li>
<li>405：Method Not Allowed，发起的请求中带有所请求的URL 不支持的方法时，使用此状态码。应该在响应中包含Allow 首部，以告知客户端对所请求的资源可以使用哪些方法。</li>
<li>406：Not Acceptable，客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的URL 相匹配的资源时，使用此代码。</li>
<li>413： Request Entity Too Large， 客户端发送的实体主体部分比服务器能够或者希望处理的要大时，返回此状态码。</li>
<li>429：Too Many Requests，表示客户端在给定时间范围内发送了太多请求。</li>
</ul>
<h2 id="5xx">5XX</h2>
<p>服务器错误状态码，表示服务器处理请求出错</p>
<ul>
<li>500：Intenernal Server Error，服务器在执行请求时发生了错误</li>
<li>501：Not Implemented，客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）</li>
<li>502：Bad Gateway， 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）。</li>
<li>503：Service Unavailable 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况所需时间，最好写入Retry-After首部字段返回给客户端。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的注解]]></title>
        <id>https://goroyal.github.io/post/java-annotation/</id>
        <link href="https://goroyal.github.io/post/java-annotation/">
        </link>
        <updated>2019-02-06T12:17:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概念">概念</h2>
<p>注解，也就是Annotation，是Java 5 开始引入的特征，它提供了一种安全的类似注释的机制，用来将任何的信息或元数据与程序元素（类、方法、属性等）进行关联。<br>
Annotation通过Java反射机制来访问注解信息，相关类根据这些信息决定对这些程序元素采用什么行为。Java语言解释器在工作时会忽略这些注解，因此注解在JVM中是“不起作用”的，只能通过配套工具对这些注解类型的信息进行访问和处理。<br>
在软件框架或者工具中常常用到注解，比如Struts，JUnit，TestNG，Spring等。</p>
<h2 id="定义注解">定义注解</h2>
<p>注解使用关键字<code>@interface</code>定义，而不是<code>interface</code>。所有注解都是继承的<code>java.lang.annotation.Annotation</code>接口，但是如果直接创建一个interface继承<code>java.lang.annotation.Annotation</code>接口并不是定义一个注解类型。<br>
创建的注解类型中可以定义常量、静态成员，也可以定义方法。但是这些方法的声明里必须是无参数、无抛出异常的。方法的返回值必须为primitive类型（包括<code>String</code>类型）、<code>Class</code>类型、枚举类型、注解类型中的一个或者以上之一组成的一维数组。方法的后面可以用default和一个值来表示这个方法的默认返回值，注意，默认值不能设为null。只有返回值是<code>Class</code>的方法可以在注解类型中使用泛型，因为该方法能够将各种类型通过类转换变成<code>Class</code>。<br>
举一个定义注解的例子：</p>
<pre><code class="language-java">public @interface Property{
    boolean nullable default false;
    String value default &quot;&quot;;
}

public class User{
    @Property(value = &quot;林雷&quot;)
    private String userName;
}
</code></pre>
<p>如以上先定义了一个注解类型<code>@Property</code>，然后定义一个Bean，也就是User类，其中有个userName的属性，对其用<code>@Property</code>注解进行了标记，那么也就是说userName被标记为值为“林雷”，而且它是不可空的，<code>@Property</code>后面括号里用等号连接的是个赋值操作，等号左边的内容实际上就是注解中定义的方法，等号右边的内容就是让注解中对应的方法返回一个什么样的值，如果不定义的话就采用注解里设的默认值。可以定义多个，以逗号隔开。</p>
<h2 id="三种标准注解">三种标准注解</h2>
<p>从Java 5开始就已经自带了三种标准注解，如下：</p>
<h3 id="override">@Override</h3>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
</code></pre>
<p><code>@Override</code>是一种标记型注解。表示当前的方法定义覆盖了父类中的方法，起到断言作用，方法签名必须相同（即方法名、参数类型、参数顺序、参数个数都一样），否则无法通过编译。这个注解常用作试图覆盖父类方法而又写错了方法名时的一个保障性校验。</p>
<h3 id="deprecated">@Deprecated</h3>
<pre><code class="language-java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
</code></pre>
<p><code>@Deprecated</code>是一种标记型注解。对不应该再使用的程序元素添加该注解，当调用被注解的方法时，在编译器会显示提示信息不鼓励使用被这个注解了的程序元素。<br>
注意，该注解与JavaDoc注释中的<code>@deprecated</code>标记是有区别的：前者是用于Java编译器识别的，而后者是在生成文档时被JavaDoc识别。</p>
<h3 id="suppresswarnings">@SuppressWarnings</h3>
<pre><code class="language-java">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
</code></pre>
<p>此注解能告诉Java编译器关闭对类、方法及成员变量的警告。有时编译时会提出一些警告，对于这些警告有的隐藏着Bug，有的是无法避免的，对于某些不想看到的警告信息，可以通过这个注解来屏蔽。<code>@SuppressWarning</code>不是一个marker annotation。它有一个类型为<code>String[]</code>的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对<code>@SuppressWarings</code>有效，同时编译器忽略掉无法识别的警告名。</p>
<h2 id="四种元注解">四种元注解</h2>
<h3 id="target">@Target</h3>
<p>表示注解可以用在什么地方，它的值是ElementType枚举中的枚举类型：<br>
CONSTRUCTOR 构造器声明；<br>
FIELD 域声明；<br>
METHOD 方法声明；<br>
TYPE 类、接口或enum声明；<br>
PARAMETER 参数声明；<br>
LOCAL_VARIABLE 局部变量声明；<br>
ANNOTATION_TYPE 注释类型声明<br>
PACKAGE 包声明</p>
<h3 id="retention">@Retention</h3>
<p>表示需要在什么级别保存该注解信息。设值时需要提供java.lang.annotation.RetentionPolicy中的枚举类型。</p>
<pre><code class="language-java">public enum RetentionPolicy{
    SOURCE, //编译程序处理完Annotation信息后就完成任务
    CLASS, //编译程序将Annotation储存于class中，但会被虚拟机丢弃，@Retention默认是Class级别
    RUNTIME //编译程序将Annotation储存于class中，虚拟机在运行期也保留注解，可以通过反射机制读取注解信息
}
</code></pre>
<h3 id="documented">@Documented</h3>
<p>将此注解包含到Javadoc中。</p>
<h3 id="inherited">@Inherited</h3>
<p>允许子类继承父类的注解。</p>
<hr>
<p>在自定义注解的时候可以综合使用这四个元注解定义自己定义的注解的作用范围等信息。</p>
<h2 id="通过反射加载注解">通过反射加载注解</h2>
<p>还用之前举的例子，下面简单写个通过反射获得注解信息的例子。<br>
先定义注解：</p>
<pre><code class="language-java">import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface Property {
    boolean nullable() default false;

    String value() default &quot;&quot;;
}
</code></pre>
<p>定义POJO Bean：</p>
<pre><code class="language-java">public class User {

    @Property(value = &quot;李雷&quot;)
    private String username;

    @Property(nullable = true, value = &quot;test@a.com&quot;)
    private String email;
}
</code></pre>
<p>接下来就是获取这个注解了：</p>
<pre><code class="language-java">import java.lang.reflect.Field;

public class AnnotationTest {
    public static void main(String[] args){
        //获取User类的Class实例
        Class&lt;?&gt; clazz = User.class;
        //获取这个类的所有属性
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields){
            //判断这个属性中是否有Property注解
            if (field.isAnnotationPresent(Property.class)){
                Property property = field.getAnnotation(Property.class);
                System.out.println(field.getName()+&quot;: &quot;+property.nullable()+&quot; &quot;+property.value());
            }
        }
    }
}
</code></pre>
<p>运行之后结果为：</p>
<pre><code>username: false 李雷
email: true test@a.com
</code></pre>
<p>从上面的结果也可以看到，即使类中的属性定义为private类型，也可以通过注解对其进行标记赋值，这个方法在Spring等框架中常常使用。</p>
<h2 id="参考资料">参考资料</h2>
<p>http://computerdragon.blog.51cto.com/6235984/1210969<br>
http://www.cnblogs.com/mandroid/archive/2011/07/18/2109829.html<br>
http://www.itzhai.com/java-based-notebook-annotation-annotation-introduction-and-use-custom-annotations.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux中的exit命令]]></title>
        <id>https://goroyal.github.io/post/exit-command-in-linux/</id>
        <link href="https://goroyal.github.io/post/exit-command-in-linux/">
        </link>
        <updated>2018-05-13T14:22:26.000Z</updated>
        <content type="html"><![CDATA[<p>我们在linux的命令行里面会用到exit，比方说退出某个shell。在shell脚本中这个命令可以终止脚本的执行。exit后面是可以接一个数字表示退出时候的状态。</p>
<p><code>exit(0)</code>一般表示成功结束，其他的是不成功的，如<code>exit(1)</code>。对于一些系统程序而言，这些错误编号是有含义的：</p>
<ul>
<li>1　　　　　　　　  一般性未知错误</li>
<li>2　　　　　　　　  不适合的shell命令</li>
<li>126 　　　　　　　命令不可执行</li>
<li>127 　　　　　　　没找到命令</li>
<li>128 　　　　　　　无效的退出参数</li>
<li>128+x 　　　　　　与Linux信号x相关的严重错误</li>
<li>130 　　　　　　　通过Ctrl+C终止的命令</li>
<li>255 　　　　　　　正常范围之外的退出状态码</li>
</ul>
<p>不带数字直接<code>exit</code>，脚本的退出状态码就由脚本里面最后执行的命令来决定（即exit之前的命令）。</p>
<p>至于<code>exit $?</code>，它和<code>exit</code>是一样的作用。</p>
<p>参考：</p>
<ul>
<li><a href="http://man.linuxde.net/exit">Linux命令大全</a></li>
<li><a href="https://www.ixdba.net/docs/shell/exit-status.html">退出和退出状态码</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SUSE Linux中安装Oracle数据库]]></title>
        <id>https://goroyal.github.io/post/install-oracle-db-in-suse/</id>
        <link href="https://goroyal.github.io/post/install-oracle-db-in-suse/">
        </link>
        <updated>2018-04-06T13:34:02.000Z</updated>
        <content type="html"><![CDATA[<p>从官网下载64位rpm安装包，解压，打开terminal进入rpm安装包所在目录，输入<code>rpm -i install oralce-xe-xxx.rpm</code><br>
然后会提示输入<code>/etc/init.d/oracle-xe configure</code>，按照步骤照做。<br>
在设置http端口的时候，默认为8080，可能会影响jboss、tomcat，可以改成8088。</p>
<p>配置ORACLE_HOME和path:<br>
打开<code>/etc/bash.bashrc.local</code>，</p>
<pre><code class="language-shell">export ORACLE_HOME=/u01/app/oracle/product/11.2.0/xe
export PATH=$PATH:$ORACLE_HOME/bin:
export ORACLE_SID=XE
</code></pre>
<p>配置结束后，在尝试sqlplus连接数据库的时候会出现密码不正确或者权限不够等问题，因为oracle express在安装的时候讲ORACLE用户作为这个软件的owner，而这个owner没有加到dba组里。<br>
可以输入命令<code>/etc/group</code>查看当前系统中的用户组，<code>/etc/passwd</code>查看系统中的用户。遇到一个问题就是实际上并不存在ORACLE这个用户，然后采取了一个方法，就是<code>vi /etc/group</code>强制在dba这个组加上ORACLE这个用户。<br>
打开新的终端，<code>su - oracle</code>从而切换到ORACLE用户，然后输入<code>groups</code>，可以查看它属于dba组。（其实挺奇怪，<code>su - oracle</code>可以切换到oracle用户，但是之前在其他地方找不到这个用户）</p>
<p>输入<code>/etc/init.d/oracle-xe start</code>(或<code>lsnrctl start</code>)启动oracle。</p>
<p>输入<code>sqlplus system/密码</code>，进行连接，如果说用户名或密码错误的话，可以输入<code>sqlplus / as sysdba</code>(注意，需要在ORACLE用户下)，然后建立连接后，输入<code>alter user system identified by 密码</code>;<br>
quit后在以<code>sqlplus system/密码</code>就能连上了。</p>
<p>密码不正确或者权限不够等问题，应该也可以通过更改oracle安装后的目录及文件的owner来实现，这里就暂不讨论。</p>
<p>还有可能和<code>$ORACLE_HOME/network/admin</code>下面的几个ora文件有关。附件里列出了它们。</p>
<p>如果安装的时候忘了改http端口，可以输入如下命令：</p>
<pre><code>sqlplus /nolog
connect
(input username and password)
exec dbms_xdb.sethttpport(8088)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的几种引用]]></title>
        <id>https://goroyal.github.io/post/references-in-java/</id>
        <link href="https://goroyal.github.io/post/references-in-java/">
        </link>
        <updated>2018-01-11T14:36:39.000Z</updated>
        <content type="html"><![CDATA[<p>Java中的引用主要有以下几种类型：<br>
• 强引用（StrongReference）：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p>
<p>• 软引用（SoftReference）：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>• 弱引用（WeakReference）：弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>• 虚引用（PhantomReference）：“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<hr>
<p>下面主要来谈谈软引用。<br>
对于软引用对象本身，至少有两个强引用指向它：由应用创建的原始的强引用，还有就是JVM创建的在所引对象队列上的一个新的强引用。软引用本质上是一个比较大的、最近最久未用的对象池。获得较好性能的关键是确保它们会被及时清理。</p>
<p>不要使用太多软引用，它们很容易填满整个堆。</p>
<p>当问题中的所引对象会同时被几个线程使用时，应该考虑弱引用。否则，弱引用很可能会被垃圾收集器回收：只有弱引用的对象在每个GC周期都可以回收。当强引用被移除时，弱引用会立即释放。</p>
<p>软：只要有足够内存，而且看上去有人会偶尔访问它，就留着它。<br>
弱：只要有其他人对这个对象感兴趣就让我知道它在哪，但是如果他们不再需要它了，就丢了，我自己会重新创建。</p>
<p>软引用的对象通常可以存活几分钟甚至几小时，但是只要所引读写仍然存在，弱引用对象就会一直存活（下一个GC周期会清理）。</p>
<p><strong>在Java中，集合类经常是内存泄露的根源。比如某个应用将对象放入一个HashMap对象中，但从不移除。随着时间推移，这个HashMap对象会越来越大，而且消耗堆。</strong></p>
]]></content>
    </entry>
</feed>