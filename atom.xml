<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://goroyal.github.io</id>
    <title>Goroyal&apos;s blog</title>
    <updated>2020-08-03T08:06:22.334Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://goroyal.github.io"/>
    <link rel="self" href="http://goroyal.github.io/atom.xml"/>
    <subtitle>学习分享</subtitle>
    <logo>http://goroyal.github.io/images/avatar.png</logo>
    <icon>http://goroyal.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Goroyal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Java持久化API]]></title>
        <id>http://goroyal.github.io/post/jpa/</id>
        <link href="http://goroyal.github.io/post/jpa/">
        </link>
        <updated>2020-08-03T08:04:32.000Z</updated>
        <content type="html"><![CDATA[<p>Java持久化API(Java Persistence API, JPA)是基于POJO的持久化机制，从Hibernate和Java数据对象上借鉴了很多理念，引入了Java 5注解的特性。</p>
<p>在Spring中使用JPA的第一步是要在Spring应用上下文中将实体管理器工厂按照Bean的形式来进行配置。</p>
<h2 id="配置实体管理器工厂">配置实体管理器工厂</h2>
<p>基于JPA的应用程序使用EntityManagerFactory的实现类来获取EntityManager实例。<br>
JPA定义的两种类型的实体管理器：</p>
<ul>
<li>应用程序管理类型（Application-managed），由LocalEntityManagerFactoryBean生成</li>
<li>容器管理类型（Container-managed），由LocalContainerEntityManagerFactoryBean生成</li>
</ul>
<p>二者区别在于EntityManager的创建和管理方式：</p>
<ul>
<li>应用程序管理类型的EntityManager由EntityManagerFactory创建</li>
<li>容器管理类型的EntityManager由PersistenceProvider的createEntityManagerFactory()方法得到的<br>
二者唯一值得关注的区别是在Spring应用上下文中如何进行配置。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#中引入的class命名空间相同但是source不同的问题解决]]></title>
        <id>http://goroyal.github.io/post/csharp-same-class-name-namespace-diff-source/</id>
        <link href="http://goroyal.github.io/post/csharp-same-class-name-namespace-diff-source/">
        </link>
        <updated>2020-08-03T07:39:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="场景">场景</h2>
<ol>
<li>在z项目里引用x和y项目，分别为x.dll和y.dll。</li>
<li>引入的class A在x.dll和y.dll都定义了，而且命名空间一样，然后x和y同时在z项目中被用到，z中想使用class A就会遇到这问题</li>
<li>x项目中定义了class A，同时y项目中在csproj文件里用<code>&lt;Compile Include=&quot;..\x\A.cs&quot;&gt;</code>将其引入进来并重新编译。然后x和y同时在z项目中被用到，z中想使用class A时候就会同样遇到这问题。</li>
</ol>
<h2 id="解决方案">解决方案</h2>
<p>第一步，在z项目引入x和y的时候指定它的alias，如下：</p>
<pre><code class="language-XML">&lt;ProjectReference Include=&quot;..\ProjextX\ProjextX.csproj&quot;&gt;
    &lt;Project&gt;{EE0F5BBF-54D4-40EB-BEB2-5D07A49BC5B8}&lt;/Project&gt;
    &lt;Name&gt;ProjextX.ClassA&lt;/Name&gt;
    &lt;Aliases&gt;ClassA&lt;/Aliases&gt;
&lt;/ProjectReference&gt;
</code></pre>
<p>第二步，在z项目中用到class A的地方，先在引用其他namespace之前加上<code>extern alias</code>，比如：</p>
<pre><code class="language-java">// 引入命名空间前
extern alias ProjextX;

// 调用的时候
private readonly ProjectZ::ProjextX.ClassA variable = new ProjectZ::ProjextX.ClassA();
</code></pre>
<p>注意的是，<code>extern alias</code>放在自己这个类的namespace定义外边还是里边效果是不一样的。</p>
<h1 id="参考链接">参考链接</h1>
<p>https://blogs.msdn.microsoft.com/ansonh/2006/09/27/extern-alias-walkthrough/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MSBuild学习]]></title>
        <id>http://goroyal.github.io/post/msbuild-learn/</id>
        <link href="http://goroyal.github.io/post/msbuild-learn/">
        </link>
        <updated>2020-08-03T07:36:16.000Z</updated>
        <content type="html"><![CDATA[<p>MSBuild是.NET平台下的构建工具。</p>
<h1 id="概览">概览</h1>
<p>MSBuild也就是用于构建应用的Microsoft Build Engine，它提供一个XML Schema用于project文件来控制构建平台process、build软件。<br>
可以使用Visual Studio或者调用MSBuild.exe来完成这个操作。VS里边的project文件（<code>.csproj</code>、<code>vbproj</code>、<code>vcxproj</code>等）包含MSBuild XML代码，这些代码将在使用IDE build project的时候被运行。</p>
<p>在VS 2017里面使用的MSBuild版本是15，现在MSBuild装在VS的每个版本的文件夹中，比如<code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild</code>。也可以使用这个powershell命令来定位MSBuild：<a href="https://github.com/Microsoft/vssetup.powershell"><code>vssetup.powershell</code></a>。</p>
<p><code>MSBuildToolsPath</code>不再是一个固定的位置。默认情况下将是相对于VS安装位置的<code>MSBuild\15.0\Bin</code>文件夹中。</p>
<h2 id="msbuild的相关概念">MSBuild的相关概念</h2>
<h3 id="properties">Properties</h3>
<p>Properties是键值对，可以用来配置builds。</p>
<pre><code class="language-XML">&lt;PropertyGroup&gt;
    &lt;BuildDir&gt;Build&lt;/BuildDir&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>在整个project文件中，properties通过<code>$(&lt;PropertyName&gt;)</code>的方式被引用，比如使用上面的BuildDir属性，则用<code>$(BuildDir)</code>即可。<br>
Properties的值可以被redefine。</p>
<p>MSBuild中保留的或众所周知的properties：</p>
<ul>
<li><code>MSBuildBinPath</code>: 当前使用的MSBuild binaries位置的绝对路径，例如<code>C:\Windows\Microsoft.Net\Framework\&lt;versionNumber&gt;</code></li>
<li><code>MSBuildExtensionsPath</code></li>
<li><code>MSBuildProjectFile</code>: project文件的完整文件名，例如<code>MyApp.proj</code></li>
</ul>
<p>完整的见<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2017">MSBuild reserved and well-known properties</a></p>
<p>可以使用<code>Condition</code> attribute来为一个property提供默认值，如果这个property没有value则给它设置一个。比如</p>
<pre><code class="language-XML">&lt;ToolsPath Condition=&quot;''$(TOOLSPATH)' == ''&quot;&gt;c:\tools&lt;/ToolsPath&gt;
</code></pre>
<p>除了在project文件中做配置，也可以在命令行执行的时候设置property。如：</p>
<pre><code class="language-shell">msbuild file.proj -property:Flavor=Debug
msbuild file.proj -p:Flavor=Debug
msbuild file.proj -p:Flavor=Debug;Platform=x86
msbuild file.proj -p:Flavor=Debug -p:Platform=x86
</code></pre>
<p>环境变量也会被认为是properties，并且自动被MSBuild装载进来。</p>
<h3 id="items">Items</h3>
<p>Items是build system的输入，通常代表文件。</p>
<pre><code class="language-XML">&lt;ItemGroup&gt;
    &lt;Compile Include = &quot;file1.cs&quot;/&gt;
    &lt;Compile Include = &quot;file2.cs&quot;/&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>file2.cs是append在file1.cs之后的，也可以结合<code>**</code>、<code>*</code>、<code>？</code>用wildcard模式，例如：</p>
<pre><code class="language-XML">&lt;CSFile Include=&quot;*.cs&quot;/&gt;
或者
&lt;ItemGroup&gt; 
    &lt;CSFile Include=&quot;*.cs&quot; Exclude=&quot;DoNotBuild.cs&quot;/&gt;
&lt;/ItemGroup&gt;
</code></pre>
<h3 id="targets">Targets</h3>
<p>解释如何将tasks以特定的顺序组合到一起，并在命令行调用构建过程的各个部分。<br>
感觉类似Ant的targets。详细的见<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets?view=vs-2017">MSBuild targets</a></p>
<h3 id="tasks">Tasks</h3>
<p>显示如何创建可以被MSBuild使用的可执行代码单元去执行原子的build操作。</p>
<h3 id="special-characters">Special Characters</h3>
<p>% $ @ ' ; ? *</p>
<h1 id="参考">参考</h1>
<p><a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2017">微软官方文档：MSBuild</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Inverted Index]]></title>
        <id>http://goroyal.github.io/post/inverted-index/</id>
        <link href="http://goroyal.github.io/post/inverted-index/">
        </link>
        <updated>2020-08-03T07:33:37.000Z</updated>
        <content type="html"><![CDATA[<p>Inverted Index, 也就是反向索引（倒排索引）。反向索引结构是典型的搜索引擎算法重要的部分。</p>
<p>常规的索引是文档到关键词的映射，但是这样的话检索关键词会比较慢，需要遍历一个又一个的文档。反向索引是从关键词到文档，这样可以根据关键词找到它在哪个文档里出现。</p>
<p>一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档吗。</p>
<p>以英文为例，下面是要被索引的文本：</p>
<pre><code>T0 = &quot;it is what it is&quot;
T1 = &quot;what is it&quot;
T2 = &quot;it is a banana&quot;
</code></pre>
<p>可以得到下列的反向文件索引：</p>
<pre><code>&quot;a&quot;: {2}
&quot;banana&quot;: {2}
&quot;it&quot;: {0, 1, 2}
&quot;is&quot;: {0, 1, 2}
&quot;what&quot;: {0, 1}
</code></pre>
<p>还可以在反向索引里面加上单词出现的位置，比如<code>&quot;banana&quot;: {(2, 3)}</code>表示banana出现在第三个文本的第四个位置。</p>
<p>反向索引在ElasticSearch里面也被使用到（Lucene)。假设有2个文档，文档的<code>content</code>域包含下列内容：</p>
<ol>
<li>The quick brown fox jumped over the lazy dog</li>
<li>Quick brown foxes leap over lazy dogs in summer</li>
</ol>
<p>为了创建反向索引，首先将每个文档的<code>content</code>拆分成词（称为<code>词条</code>或<code>token</code>），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。如下所示：</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Doc_1</th>
<th>Doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Quick</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>The</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>brown</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>dog</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>dogs</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>fox</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>foxes</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>in</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>jumped</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>lazy</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>leap</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>over</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>quick</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>summer</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>the</td>
<td>X</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们想搜索<code>quick brown</code>，我们只需要查找包含每个词条的文档：</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Doc_1</th>
<th>Doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>brown</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>quick</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>2</strong></td>
<td><strong>1</strong></td>
</tr>
</tbody>
</table>
<p>两个文档都匹配，但是第一个文档比第二个匹配度更高。当然了，上面的反向索引存在点问题，比如<code>Quick</code>和<code>quick</code>，<code>dogs</code>和<code>dog</code>，可以作为相同词根进行索引，但还是不够的，需要进一步<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/analysis-intro.html">分析</a>。</p>
<h2 id="参考">参考</h2>
<p><a href="https://zh.wikipedia.org/zh-hans/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">维基百科</a><br>
<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html">ElasticSearch文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM类加载机制]]></title>
        <id>http://goroyal.github.io/post/jvm-lei-jia-zai-ji-zhi/</id>
        <link href="http://goroyal.github.io/post/jvm-lei-jia-zai-ji-zhi/">
        </link>
        <updated>2020-08-02T15:04:49.000Z</updated>
        <content type="html"><![CDATA[<p>Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。如编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。</p>
<p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段，其中验证、准备、解析三个部分统称为连接。</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，累的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。</p>
<p>对于初始化阶段，虚拟机规范严格规定有且只有5种情况必须对类立即进行”初始化“（加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic这4条指令码时，如果类没有进行过初始化，则需要先触发其初始化。这4个常见的Java代码场景：使用new关键字实例化对象时、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候、调用一个类的静态方法时。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要。。</li>
<li>当初始化一个类时，如果发现其父类还没有进行过初始化，需要。。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），需要。。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要。。</li>
</ul>
<p>加载类的过程：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>非数组类的加载是开发者可控性最强的，加载阶段既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器去完成。</p>
<p>对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，是由Java虚拟机直接创建的。但数组类与类加载器仍有密切关系，因为数组类的元素类型最终是要靠类加载器去创建。一个数组类（下称为C）创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（指的是数组去掉一个维度的类型）是引用类型，那就递归去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。（一个类必须与类加载器一起确定唯一性）</li>
<li>如果数组的组件类型不是引用类型（如int[]），Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</li>
</ul>
<p><strong>类加载器：</strong><br>
虚拟机设计团队把”通过一个类的全限定名来获取此类的二进制字节流“这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为”类加载器“。</p>
<p>类加载器可以说是java语言的一项创新，它在类层次划分、OSGi、热部署、代码加密等领域大放异彩。</p>
<p>每一个类加载器都拥有一个独立的类名称空间，比较两个类是否”相等“，只有这两个类是由同一个类加载器加载的前提下才有意义。这里的相等，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括instanceOf关键字做对象所属关系判定等情况。</p>
<p><strong>双亲委派模型：</strong><br>
从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器在Hotspot虚拟机中使用C++实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader。</p>
<p>从开发人员角度看，大部分Java程序都会使用以下3种系统提供的类加载器：</p>
<ul>
<li>启动类加载器，它复杂将$JAVA_HOME/lib中的并且是虚拟机识别的（仅按照文件名识别，如rt.jar）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</li>
<li>扩展类加载器，负责加载$JAVA_HOME/lib/ext中的所有类库，开发者可以直接使用扩展类加载器</li>
<li>应用程序类加载器，它是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果app中没有自定义过，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>类加载器的双亲委派模型，除了要求顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合关系来复用父加载器代码。<br>
自定义类加载器-&gt;应用程序类加载器-&gt;扩展类加载器-&gt;启动类加载器</p>
<p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去 尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系的显而易见的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。如类java.lang.Object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器去加载，因此Object类在程序的各种累加载器环境中都是同一个类。</p>
<p>破坏双亲委派模型：</p>
<ul>
<li>JDK 1.2之前的loadClass方法，后期为了兼容性做了妥协</li>
<li>JDNI服务，它的代码由启动类加载器去加载，但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的Classpath下的JNDI接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能”认识”这些代码，怎么处理？</li>
</ul>
<p>为了解决JNDI的问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader），这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那么这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，JNDI服务使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。Java中所有涉及SPI的加载动作基本上都采用了这种方式，如JNDI、JDBC、JCE、JAXB、JBI等。</p>
<p>双亲委派模型的第三次破坏是用户对程序动态性的追求导致的，如代码热替换、模块热部署。</p>
<p>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。OSGi按照下面顺序进行类搜索：</p>
<ul>
<li>将以java.*开头的类委派给父类加载器加载；</li>
<li>否则将委派列表名单内的类委派给父类加载器加载</li>
<li>否则将import列表中的类委派给export这个类的Bundle的类加载器加载</li>
<li>否则查找当前Bundle的Classpath，使用自己的类加载器加载</li>
<li>否则查找类是否在自己的Fragment Bundle中，如果在，委派给Fragment Bundle的类加载器加载</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则类查找失败。</li>
</ul>
<h4 id="字节码生成技术与动态代理的实现">字节码生成技术与动态代理的实现</h4>
<p>在java里面除了javac和字节码类库外，使用字节码生成的例子还有很多，如Web服务器中的JSP编译器，编译时植入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。我们选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的。<br>
即使没有直接用过java.lang.reflect.Proxy或实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况都会用过动态代理，因为如果Bean是面向接口编程，那么在Spring内部都是通过动态代理的方式来对Bean进行增强的。动态代理中所谓的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的。它的优势不在于省去了编写代理类那一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类和原始类脱离直接联系后，就可以很灵活地重用与不同的应用场景之中。</p>
<p>下面是最简单的动态代理用法：</p>
<pre><code class="language-Java">public class DynamicProxyTest {
	interface IHello {
		void sayHello();
	}
	
	static class Hello implements IHello {
		@Override
		public void sayHello() {
			System.out.println(&quot;hello world&quot;);
		}
	}
	
	static class DynamicProxy implements InvocationHandler {
		Object originalObj;
		Object bind(Object originalObj){
			this.originalObj = originalObj;
			return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);
		}
		
		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			System.out.println(&quot;welcome&quot;);
			return method.invoke(originalObj, args);
		}
	}
	
	public static void main(String[] args) {
		IHello hello = (IHello) new DynamicProxy().bind(new Hello());
		hello.sayHello();
	}
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>welcome
hello world
``
上述代码里唯一的“黑匣子”就是Proxy.newProxyInstance()方法，除此之外再没有任何特殊之处。这个方法返回了一个实现了IHello的接口，并且代理了new Hello()实例行为的对象。跟踪这个方法的源码可以看到程序进行了验证、优化、缓存、同步、生成字节码、显示类加载等操作，最后它调用了sun.misc.ProxyGenerator.generateProxyClass()方法来完成了字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码byte[]数组。如果想看这个在运行时产生的代理类中写了什么，可以在main()方法加入：

``` Java
System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, true)；
</code></pre>
<p>反编译后的代理类实现里面，为传入接口的每个方法以及从Object类继承的equals()、hashCode()、toString()方法都生成了对应的实现，并且统一调用了InvocationHandler对象的invoke()方法来实现这些方法的内容，这个方法的区别不过是传入的参数和Method对象有所不同而已。所以无论调用动态代理的哪一个方法，实际上都是在执行InvocationHandler.invoke()中的代理逻辑。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM垃圾收集器]]></title>
        <id>http://goroyal.github.io/post/jvm-la-ji-shou-ji-qi/</id>
        <link href="http://goroyal.github.io/post/jvm-la-ji-shou-ji-qi/">
        </link>
        <updated>2020-08-02T15:03:44.000Z</updated>
        <content type="html"><![CDATA[<p>常用垃圾收集器：G1，CMS等</p>
<h2 id="serial收集器">Serial收集器</h2>
<p>单线程的收集器，它的单线程的意义不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>Serial在新生代使用复制算法。Serial Old在老生代使用标记-整理算法。</p>
<p>虽然到后期的垃圾收集器，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除。</p>
<p>到目前为止，Serial收集器仍然是虚拟机运行在Client模式下的默认新生代收集器。</p>
<h2 id="parnew收集器">ParNew收集器</h2>
<p>Serial收集器的多线程版本。<br>
ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有个预性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是Hotspot虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。但是CMS作为老年代收集器却无法与JDK 1.4已经存在的新生代收集器Parallel Scavenge配合工作。</p>
<p>ParNew收集器是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UserParNewGC选项来强制指定它。</p>
<p>ParNew在单CPU环境中绝对不会有比Serial收集器更好的效果，甚至存在由于线程交互的开销。</p>
<h2 id="parallel-scavenge收集器">Parallel Scavenge收集器</h2>
<p>新生代收集器，也是使用复制算法、并行的多线程收集器。它的特点是关注点与其他收集器不同，CMS等收集器关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量（Throughput）。所谓吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>该收集器提供了两个参数用于精确控制吞吐量。</p>
<ul>
<li>-XX:MAXGCPauseMillis：控制最大垃圾收集停顿时间</li>
<li>-XX:GCTimeRatio：直接设置吞吐量大小</li>
</ul>
<p>Parallel Old是它在老年代的版本，使用多线程和标记-整理算法。</p>
<h2 id="cms收集器">CMS收集器</h2>
<p>Current Mark Sweep，一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。整个过程分为四步：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>初始标记和重新标记仍需要Stop The World。初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快。并发标记就是进校GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短。</p>
<p>CMS是一款优秀的收集器，但是3个缺点：</p>
<ul>
<li>对CPU资源非常敏感</li>
<li>无法处理浮动垃圾</li>
<li>是一款基于标记-清除算法的收集器，会有空间碎片产生</li>
</ul>
<h2 id="g1收集器garbage-first">G1收集器（Garbage First）</h2>
<p>并行与并发<br>
分代收集<br>
空间整合：G1整体来看是标记-整理，局部来看是基于复制算法。<br>
可预测的停顿</p>
<p>大致分为以下几步：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存溢出]]></title>
        <id>http://goroyal.github.io/post/jvm-nei-cun-yi-chu/</id>
        <link href="http://goroyal.github.io/post/jvm-nei-cun-yi-chu/">
        </link>
        <updated>2020-08-02T14:56:33.000Z</updated>
        <content type="html"><![CDATA[<p>JVM内存溢出经常有2种报错：</p>
<ul>
<li>OutOfMemory（OOM）</li>
<li>StackOverFlow（SOF ）</li>
</ul>
<p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError异常的可能。为了进行试验，在运行时使用以下的JVM参数：</p>
<pre><code>--verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
</code></pre>
<h2 id="java堆溢出">Java堆溢出</h2>
<p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>
<pre><code class="language-java">/**
 * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemorryError
 * 将对的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展，通过参数-XX:+HeapDumpOnOutOfMemorryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便时候进行分析
 */
public class HeapOOM {
	static class OOMObject {
	}
	
	public static void main(String[] args){
		List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();
		while(true){
			list.add(new OOMObject());
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">java.lang.OutOfMemoryError: Java Heap space
Dumping heap to java_pid3404.hprof...
Heap dump file created[22045981 bytes in 0.663 secs]
</code></pre>
<p>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息”java.lang.OutOfMemoryError“会跟着进一步提示”Java heap space“。</p>
<p>要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（<strong>Memory Leak</strong>）还是内存溢出（<strong>Memory Overflow</strong>）。</p>
<p>如果是内存泄露，可以进一步提高工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及GC Roots引用链的信息，就可以比较准确地定位出现泄露代码的位置。</p>
<p>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h2 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h2>
<p>由于在Hotspot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于Hotspot来说，虽然-Xoss参数（用于设置本地方法栈大小）存在，但实际上是无效的。栈容量只由-Xss参数设定。在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ul>
<p>这里把异常分成两种情况，看似更加严谨，但却存在一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上是对同一件事情的两种描述而已。</p>
<p>在《深入理解Java虚拟机规范》作者的实验中，将实验范围限制于单线程中的操作，尝试了两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是StackOverflowError。</p>
<ul>
<li>使用-Xss参数减少栈内存容量。结果，抛出StackOverflowError异常，异常出现时输出的堆栈深度相应地缩小。</li>
<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。</li>
</ul>
<pre><code class="language-java">/**
 * VM args: -Xss128k
 */
public class JavaVMStackOF {
	private int stackLength = 1;
	
	public void stackLeak() {
		stackLength++;
		stackLeak();
	}
	
	public static void main(String[] args) throws Throwable {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try {
			oom.stackLeak();
		} catch (Throwable e){
			System.out.println(&quot;stack length:&quot; + oom.stackLength);
			throw e;
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">stack length: 2402
Exception in thread &quot;main&quot; java.lang.StackOverflowError
	at....
.....后续异常堆栈信息省略
</code></pre>
<p>实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。<br>
如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系。或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。<br>
这一点需要在开发多线程应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说大多数情况下）达到1000~2000完全没有问题。但是如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，<strong>这种通过”减少内存“的手段来解决内存溢出的方式会比较难以想到</strong>。</p>
<pre><code class="language-java">public class JavaVMStackOOM {
	private void dontStop() {
		while (true) {}
	}
	
	public void stackLeakByThread() {
		while(true) {
			Thread thread = new Thread(new Runnable() {
				@Override
				public void run() {
					dontStop();
				}
			});
			thread.start();
		}
	}
	public static void main(String[] args) throws Throwable {
		JavaVMStackOOM oom = new JavaVMStackOOM();
		oom.stackLeakByThread();
	}
}
</code></pre>
<h2 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h2>
<p>JDK 1.7开始逐步”去永久代“，此处顺便看看这件事情的实际影响。<br>
String.intern()是一个Native方法，作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</p>
<pre><code class="language-java">/**
 * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		// 使用List保持着常量池引用，避免Full GC回收常量池行为
		List&lt;String&gt; list = new ArrayList&lt;&gt;();
		// 10MB的PermSize在integer范围内足够产生OOM了
		int i = 0;
		while (true) {
			list.add(String.valueOf(i++).intern());
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space
	at java.lang.String.intern(Native Method)
	at ... 
</code></pre>
<p>从运行结果可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是”PermGen space“，说明运行时常量池属于方法区（Hotspot虚拟机中的永久代）的一部分。</p>
<p>而使用JDK 1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响：</p>
<pre><code class="language-java">public class RuntimeConstantsPoolOOM {
	public static void main(String[] args){
		String str1 = new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();
		System.out.println(str1.intern() == str1);
		
		String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();
		System.out.println(str2.intern() == str2);
	}
} 
</code></pre>
<p>这段代码在JDK 1.6中运行，会得到两个false；而在JDK 1.7中运行会得到一个true一个false。产生差异的原因是：JDK 1.6中，<code>intern()</code>方法会把所赐遇到的字符串实例复制到永久代中，返回的也是永久代总这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<br>
而在JDK 1.7中的<code>intern()</code>实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此<code>intern()</code>返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为&quot;java&quot;这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量中已经有它的引用额，不符合”首次出现“的原则，而”计算机软件“这个字符串则是首次出现的。</p>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当前的很多主流框架如Spring、Hibernate对类进行增强时都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。像大量反射、大量JSP文件或动态产生JSP文件的应用、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）也会需要较大的方法区保证。</p>
<h2 id="本机直接内存溢出">本机直接内存溢出</h2>
<p>DirectMemory容量可以通过<code>-XX:MaxDirectMemory</code>指定，如果不指定则默认与Java堆最大值一样。如下代码越过了DirectByBuffer类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配于是手动抛出异常，真正申请分配内存的方法是<code>unsafe.allocateMemory()</code>。</p>
<pre><code class="language-java">/**
 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
 */
public class DirectMemoryOOM {
	private static final int _1MB = 1024 * 1024;
	
	public static void main(String[] args) throws Exception {
		Field unsafeField = Unsafe.class.getDeclaredFields()[0];
		unsafeField.setAccessible(true);
		Unsafe unsafe = (Unsafe) unsafeField.get(null);
		while(true) {
			unsafe.allocateMemory(_1MB);
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError
	at ...
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM GC]]></title>
        <id>http://goroyal.github.io/post/jvm-gc/</id>
        <link href="http://goroyal.github.io/post/jvm-gc/">
        </link>
        <updated>2020-08-02T14:49:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引用计数法">引用计数法</h2>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>
客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下他都是一个不错的算法）。<br>
但是至少主流的Java虚拟机里没有选用该方法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<h2 id="可达性分析算法">可达性分析算法</h2>
<p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h2 id="标记-清除算法">标记-清除算法</h2>
<p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p>
<p>它的主要不足有两个：</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<h2 id="复制算法">复制算法</h2>
<p>为了解决效率问题，一种称为”复制“的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代。IBM公司的专门研究表明，新生代中的对象98%是”朝生夕死“的，所以不需要按照1：1的比例来划分内存空间，而是将一块内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Hotspot虚拟机默认Eden和Survivor大小比例是8：1。</p>
<p>当然，我们也没有办法保证每次回收都只有不多于10%对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<h2 id="标记-整理算法">标记-整理算法</h2>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出标记-整理算法，标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h2 id="分代收集算法">分代收集算法</h2>
<p>当前商业虚拟机的垃圾收集都采用”分代收集“算法，这种算法根据对象存活周期的不同将内存分为几块。一般是把Java堆分为新生代和老生代。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java内存模型]]></title>
        <id>http://goroyal.github.io/post/java-memory-model/</id>
        <link href="http://goroyal.github.io/post/java-memory-model/">
        </link>
        <updated>2020-08-02T14:47:54.000Z</updated>
        <content type="html"><![CDATA[<p>在多核系统中，处理器一般有一层或者多层的缓存，这些的缓存通过加速数据访问（因为数据距离处理器更近）和降低共享内存在总线上的通讯（因为本地缓存能够满足很多内存操作）来提高CPU性能。缓存能够大大提升性能，但是它们也带来了许多挑战。例如，当两个CPU同时检查相同的内存地址时会发生什么？在什么样的条件下它们会看到相同的值？</p>
<p>在处理器层面上，内存模型定义了一个充要条件：“让当前的处理器可以看到其他的处理器写入到内存数据”以及“其他处理器可以看到当前处理器写入到内存的数据”。有些处理器有很强的内存模型（strong memory model），能够让所有的处理器在任何时候任何指定的内存地址上都可以看到完全相同的值。而另外一些处理器则有较弱的内存模型（weaker memory model），在这种处理器中，必须使用内存屏障（一种特殊的指令）来刷新本地处理器缓存并使本地处理器缓存无效，目的是为了让当前处理器能够看到其他处理器的写操作或者让其他处理器能看到当前处理器的写操作。这些内存屏障通常在lock和unlock操作的时候完成。内存屏障在高级语言中对程序员是不可见的。</p>
<p>在强内存模型下，有时候编写程序可能会更容易，因为减少了对内存屏障的依赖。但是即使在一些最强的内存模型下，内存屏障仍然是必须的。设置内存屏障往往与我们的直觉并不一致。进来处理器设计的趋势更倾向于弱的内存模型，因为弱内存模型削弱了缓存一致性，所以在多处理器平台和更大容量的内存下可以实现更好的可伸缩性。</p>
<p>“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反应了缓存的影响。</p>
<p>此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其性能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。</p>
<h2 id="哪个区域存放哪些内容">哪个区域存放哪些内容</h2>
<ul>
<li>方法区：各个线程的共享区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。习惯在Hotspot虚拟机上的开发者很多人把方法区成为“永久代”。</li>
<li>虚拟机栈：线程私有的，描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口灯信息。每一个方法从调研直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译器可知的各种基本数据类型、对象引用和redurnAddress类型。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
<li>本地方法栈：与虚拟机栈类似，但是本地方法栈为虚拟机使用到的Native方法服务。</li>
<li>堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。是垃圾收集器管理的主要区域。</li>
<li>程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。JDK 1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java volatile]]></title>
        <id>http://goroyal.github.io/post/java-volatile/</id>
        <link href="http://goroyal.github.io/post/java-volatile/">
        </link>
        <updated>2020-08-02T11:28:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="volatile语义">volatile语义</h2>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ul>
<p>看一段代码：</p>
<pre><code class="language-java">public class VolatileExample extends Thread{
    //设置类静态变量,各线程访问这同一共享变量
    private  static boolean flag = false;
    //无限循环,等待flag变为true时才跳出循环
   public void run() {
       while (!flag){
       };
       System.out.println(&quot;停止了&quot;);
   }

    public static void main(String[] args) throws Exception {
        new VolatileExample().start();
        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了
        Thread.sleep(100);
        flag = true;
    }
}
</code></pre>
<p>当把上面代码中变量flag改成下面这样：</p>
<pre><code class="language-java">private  static valotile boolean flag = false;
</code></pre>
<p>在执行的话，你就会发现打印了“停止了”信息，因为用volatile修饰之后就变得不一样了：</p>
<ul>
<li>第一：使用volatile关键字会强制将修改的值立即写入主存；</li>
<li>第二：使用volatile关键字的话，当线程main进行修改时，会导致线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</li>
<li>第三：由于线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效，所以线程那么线程VolatileExample再次读取变量flag的值时会去主存读取。</li>
</ul>
<p>那么在线程main修改flag值时（当然这里包括2个操作，修改线程main工作内存中的值，然后将修改后的值写入内存），会使得线程VolatileExample的工作内存中缓存变量flag的缓存行无效，然后线程读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程VolatileExample读取到的就是最新的正确的值。<br>
使用volatile关键字增加了实例变量在多个线程之间的可见性。但是volatile关键字最致命的缺点是不支持原子性。</p>
<p>下面将关键字synchronized和volatile进行一下比较：</p>
<ol>
<li>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。</li>
<li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</li>
<li>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它将私有内存和公共内存中的数据做同步。</li>
<li>再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ol>
<h2 id="volatile非原子的特性">volatile非原子的特性</h2>
<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>
下面看一个例子：</p>
<pre><code class="language-Java">public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
         
         //保证前面的线程都执行完
        while(Thread.activeCount()&gt;1)
   			Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>也许有些朋友认为输出结果是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。可能有人会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值是10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>虽然happens-before规则中的volatile变量规则是保证一个变量在修改volatile变量时，会让缓存行无效吗，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p><strong>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</strong></p>
<p>把上面的代码改成以下任何一种都可以达到效果：<br>
采用synchronized：</p>
<pre><code class="language-java">public class Test {
    public  int inc = 0;
    
    public synchronized void increase() {
        inc++;
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>采用Lock：</p>
<pre><code class="language-java">public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();
    
    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>采用AtomicInteger：</p>
<pre><code class="language-Java">public class Test {
    public  AtomicInteger inc = new AtomicInteger();
     
    public  void increase() {
        inc.getAndIncrement();
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h2 id="volatile能保证有序性">volatile能保证有序性</h2>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：<br>
1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>
可能上面说的比较绕，举个简单的例子：</p>
<pre><code class="language-Java">//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
</code></pre>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<h2 id="volatile的原理和实现机制">volatile的原理和实现机制</h2>
<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<blockquote>
<p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。<br>
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ul>
</blockquote>
<h2 id="总结">总结</h2>
<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ul>
]]></content>
    </entry>
</feed>