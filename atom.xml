<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://goroyal.github.io</id>
    <title>Goroyal&apos;s blog</title>
    <updated>2020-08-02T14:49:21.363Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://goroyal.github.io"/>
    <link rel="self" href="http://goroyal.github.io/atom.xml"/>
    <subtitle>学习分享</subtitle>
    <logo>http://goroyal.github.io/images/avatar.png</logo>
    <icon>http://goroyal.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Goroyal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Java内存模型]]></title>
        <id>http://goroyal.github.io/post/java-memory-model/</id>
        <link href="http://goroyal.github.io/post/java-memory-model/">
        </link>
        <updated>2020-08-02T14:47:54.000Z</updated>
        <content type="html"><![CDATA[<p>在多核系统中，处理器一般有一层或者多层的缓存，这些的缓存通过加速数据访问（因为数据距离处理器更近）和降低共享内存在总线上的通讯（因为本地缓存能够满足很多内存操作）来提高CPU性能。缓存能够大大提升性能，但是它们也带来了许多挑战。例如，当两个CPU同时检查相同的内存地址时会发生什么？在什么样的条件下它们会看到相同的值？</p>
<p>在处理器层面上，内存模型定义了一个充要条件：“让当前的处理器可以看到其他的处理器写入到内存数据”以及“其他处理器可以看到当前处理器写入到内存的数据”。有些处理器有很强的内存模型（strong memory model），能够让所有的处理器在任何时候任何指定的内存地址上都可以看到完全相同的值。而另外一些处理器则有较弱的内存模型（weaker memory model），在这种处理器中，必须使用内存屏障（一种特殊的指令）来刷新本地处理器缓存并使本地处理器缓存无效，目的是为了让当前处理器能够看到其他处理器的写操作或者让其他处理器能看到当前处理器的写操作。这些内存屏障通常在lock和unlock操作的时候完成。内存屏障在高级语言中对程序员是不可见的。</p>
<p>在强内存模型下，有时候编写程序可能会更容易，因为减少了对内存屏障的依赖。但是即使在一些最强的内存模型下，内存屏障仍然是必须的。设置内存屏障往往与我们的直觉并不一致。进来处理器设计的趋势更倾向于弱的内存模型，因为弱内存模型削弱了缓存一致性，所以在多处理器平台和更大容量的内存下可以实现更好的可伸缩性。</p>
<p>“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反应了缓存的影响。</p>
<p>此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其性能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。</p>
<h2 id="哪个区域存放哪些内容">哪个区域存放哪些内容</h2>
<ul>
<li>方法区：各个线程的共享区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。习惯在Hotspot虚拟机上的开发者很多人把方法区成为“永久代”。</li>
<li>虚拟机栈：线程私有的，描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口灯信息。每一个方法从调研直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译器可知的各种基本数据类型、对象引用和redurnAddress类型。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
<li>本地方法栈：与虚拟机栈类似，但是本地方法栈为虚拟机使用到的Native方法服务。</li>
<li>堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。是垃圾收集器管理的主要区域。</li>
<li>程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。JDK 1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java volatile]]></title>
        <id>http://goroyal.github.io/post/java-volatile/</id>
        <link href="http://goroyal.github.io/post/java-volatile/">
        </link>
        <updated>2020-08-02T11:28:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="volatile语义">volatile语义</h2>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ul>
<p>看一段代码：</p>
<pre><code class="language-java">public class VolatileExample extends Thread{
    //设置类静态变量,各线程访问这同一共享变量
    private  static boolean flag = false;
    //无限循环,等待flag变为true时才跳出循环
   public void run() {
       while (!flag){
       };
       System.out.println(&quot;停止了&quot;);
   }

    public static void main(String[] args) throws Exception {
        new VolatileExample().start();
        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了
        Thread.sleep(100);
        flag = true;
    }
}
</code></pre>
<p>当把上面代码中变量flag改成下面这样：</p>
<pre><code class="language-java">private  static valotile boolean flag = false;
</code></pre>
<p>在执行的话，你就会发现打印了“停止了”信息，因为用volatile修饰之后就变得不一样了：</p>
<ul>
<li>第一：使用volatile关键字会强制将修改的值立即写入主存；</li>
<li>第二：使用volatile关键字的话，当线程main进行修改时，会导致线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</li>
<li>第三：由于线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效，所以线程那么线程VolatileExample再次读取变量flag的值时会去主存读取。</li>
</ul>
<p>那么在线程main修改flag值时（当然这里包括2个操作，修改线程main工作内存中的值，然后将修改后的值写入内存），会使得线程VolatileExample的工作内存中缓存变量flag的缓存行无效，然后线程读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程VolatileExample读取到的就是最新的正确的值。<br>
使用volatile关键字增加了实例变量在多个线程之间的可见性。但是volatile关键字最致命的缺点是不支持原子性。</p>
<p>下面将关键字synchronized和volatile进行一下比较：</p>
<ol>
<li>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。</li>
<li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</li>
<li>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它将私有内存和公共内存中的数据做同步。</li>
<li>再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ol>
<h2 id="volatile非原子的特性">volatile非原子的特性</h2>
<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>
下面看一个例子：</p>
<pre><code class="language-Java">public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
         
         //保证前面的线程都执行完
        while(Thread.activeCount()&gt;1)
   			Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>也许有些朋友认为输出结果是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。可能有人会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值是10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>虽然happens-before规则中的volatile变量规则是保证一个变量在修改volatile变量时，会让缓存行无效吗，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p><strong>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</strong></p>
<p>把上面的代码改成以下任何一种都可以达到效果：<br>
采用synchronized：</p>
<pre><code class="language-java">public class Test {
    public  int inc = 0;
    
    public synchronized void increase() {
        inc++;
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>采用Lock：</p>
<pre><code class="language-java">public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();
    
    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>采用AtomicInteger：</p>
<pre><code class="language-Java">public class Test {
    public  AtomicInteger inc = new AtomicInteger();
     
    public  void increase() {
        inc.getAndIncrement();
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre>
<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h2 id="volatile能保证有序性">volatile能保证有序性</h2>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：<br>
1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>
可能上面说的比较绕，举个简单的例子：</p>
<pre><code class="language-Java">//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
</code></pre>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<h2 id="volatile的原理和实现机制">volatile的原理和实现机制</h2>
<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<blockquote>
<p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。<br>
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ul>
</blockquote>
<h2 id="总结">总结</h2>
<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 线程中的3个特性]]></title>
        <id>http://goroyal.github.io/post/java-thread-feature/</id>
        <link href="http://goroyal.github.io/post/java-thread-feature/">
        </link>
        <updated>2020-08-02T11:22:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="原子性">原子性</h2>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>
上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：<br>
请分析以下哪些操作是原子性操作：</p>
<pre><code class="language-java">x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
</code></pre>
<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h2 id="可见性">可见性</h2>
<p>对于可见性，Java提供了<code>volatile</code>关键字来保证可见性。</p>
<p>当一个共享变量被<code>volatile</code>修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，<code>synchronized</code>和<code>Lock</code>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="有序性">有序性</h2>
<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>
在Java里面，可以通过<code>volatile</code>关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过<code>synchronized</code>和<code>Lock</code>来保证有序性，很显然，<code>synchronized</code>和<code>Lock</code>保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<h3 id="happens-before原则先行发生原则">happens-before原则（先行发生原则）</h3>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的<code>finalize()</code>方法的开始</li>
</ul>
<p>这8条原则摘自《深入理解Java虚拟机》。<br>
这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：<br>
对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java锁]]></title>
        <id>http://goroyal.github.io/post/java-lock/</id>
        <link href="http://goroyal.github.io/post/java-lock/">
        </link>
        <updated>2020-08-02T09:34:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="锁状态">锁状态</h2>
<p>Java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>锁自旋</strong><br>
我们知道在当某个线程在进入同步方法/代码块时若发现该同步方法/代码块被其他现在所占，则它就要等待，进入阻塞状态，这个过程性能是低下的。</p>
<p>在遇到锁的争用或许等待事，线程可以不那么着急进入阻塞状态，而是等一等，看看锁是不是马上就释放了，这就是锁自旋。锁自旋在一定程度上可以对线程进行优化处理。</p>
<p><strong>偏向锁</strong><br>
偏向锁主要为了解决在没有竞争情况下锁的性能问题。在大多数情况下锁锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当某个线程获得锁的情况，该线程是可以多次锁住该对象，但是每次执行这样的操作都会因为CAS（CPU的Compare-And-Swap指令）操作而造成一些开销消耗性能，为了减少这种开销，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>当有其他线程在尝试着竞争偏向锁时，持有偏向锁的线程就会释放锁。</p>
<p><strong>锁膨胀</strong><br>
多个或多次调用粒度太小的锁，进行加锁解锁的消耗，反而还不如一次大粒度的锁调用来得高效。</p>
<p><strong>轻量级锁</strong><br>
轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。轻量级锁在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的指向和状态。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<h2 id="加锁方式">加锁方式</h2>
<p>在使用synchronized时，我们是这样使用锁的：</p>
<pre><code class="language-java">public class ThreadTest {
    public void test(){
        synchronized(this){
            //do something
        }
    }
}
</code></pre>
<p>synchronized可以确保在同一时间内只有一个线程在执行dosomething。下面是使用lock替代synchronized：</p>
<pre><code class="language-java">public class ThreadTest {
    Lock lock = new Lock();
    public void test(){
        lock.lock();
        //do something
        lock.unlock();
    }
}
</code></pre>
<p>lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。</p>
<h2 id="锁的公平性">锁的公平性</h2>
<p>公平性的对立面是饥饿。那么什么是“饥饿”呢？如果一个线程因为其他线程在一直抢占着CPU而得不到CPU运行时间，那么我们就称该线程被“饥饿致死”。而解决饥饿的方案则被称之为“公平性”——所有线程均可以公平地获得CPU运行机会。</p>
<p>导致线程饥饿主要有如下几个原因：<br>
高优先级线程吞噬所有的低优先级线程的CPU时间。我们可以为每个线程单独设置其优先级，从1到10。优先级越高的线程获得CPU的时间越多。对大多数应用来说，我们最好是不要改变其优先级值。</p>
<p>线程被永久堵塞在一个等待进入同步块的状态。Java的同步代码区是导致线程饥饿的重要因素。Java的同步代码块并不会保证进入它的线程的先后顺序。这就意味着理论上存在一个或者多个线程在试图进入同步代码区时永远被堵塞着，因为其他线程总是不断优于他获得访问权，导致它一直得到不到CPU运行机会被“饥饿致死”。</p>
<p>线程在等待一个本身也处于永久等待完成的对象。如果多个线程处在<code>wait()</code>方法执行上，而对其调用<code>notify()</code>不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
<p>为了解决线程“饥饿”的问题，我们可以使用锁实现公平性。</p>
<h2 id="锁的可重入性">锁的可重入性</h2>
<p>我们知道当线程请求一个由其它线程持有锁的对象时，该线程会阻塞，但是当线程请求由自己持有锁的对象时，是否可以成功呢？答案是可以成功的，成功的保障就是线程锁的“可重入性”。<br>
“可重入”意味着自己可以再次获得自己的内部锁，而不需要阻塞。如下：</p>
<pre><code class="language-java">public class Father {
    public synchronized void method(){
        //do something
    }
}
public class Child extends Father{
    public synchronized void method(){
        //do something 
        super.method();
    }
}
</code></pre>
<p>如果所是不可重入的，上面的代码就会死锁，因为调用child的method(),首先会获取父类Father的内置锁然后获取Child的内置锁，当调用父类的方法时，需要再次后去父类的内置锁，如果不可重入，可能会陷入死锁。</p>
<p>java多线程的可重入性的实现是通过每个锁关联一个请求计算和一个占有它的线程，当计数为0时，认为该锁是没有被占有的，那么任何线程都可以获得该锁的占有权。当某一个线程请求成功后，JVM会记录该锁的持有线程 并且将计数设置为1，如果这时其他线程请求该锁时则必须等待。当该线程再次请求请求获得锁时，计数会+1；当占有线程退出同步代码块时，计数就会-1，直到为0时，释放该锁。这时其他线程才有机会获得该锁的占有权。</p>
<ul>
<li>ReentrantLock：一个可重入的互斥锁，为lock接口的主要实现。</li>
<li>ReadWriteLock：ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。</li>
<li>ReentrantReadWriteLock：可重入读写锁</li>
<li>Semaphore：一个计数信号量。</li>
<li>Condition:锁的关联条件，目的是允许线程获取锁并且查看等待的某一个条件是否满足。</li>
<li>CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java synchronized]]></title>
        <id>http://goroyal.github.io/post/java-synchronized/</id>
        <link href="http://goroyal.github.io/post/java-synchronized/">
        </link>
        <updated>2020-08-02T09:32:20.000Z</updated>
        <content type="html"><![CDATA[<p>synchronized，我们谓之锁，主要用来给方法、代码块加锁。当某个方法或者代码块使用synchronized时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。</p>
<p>synchronized主要包括两种方法：synchronized 方法、synchronized 代码块。</p>
<p>synchronized 方法通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：</p>
<pre><code class="language-java">public synchronized void getResult();
</code></pre>
<p>synchronized方法控制对类成员变量的访问。它是如何来避免类成员变量的访问控制呢？我们知道方法使用了synchronized关键字表明该方法已加锁，在任一线程在访问改方法时都必须要判断该方法是否有其他线程在“独占”。每个类实例对应一个把锁，每个synchronized方法都必须调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，被阻塞的线程方能获得该锁。</p>
<p>其实synchronized方法是存在缺陷的，如果我们将一个很大的方法声明为synchronized将会大大影响效率的。如果多个线程在访问一个synchronized方法，那么同一时刻只有一个线程在执行该方法，而其他线程都必须等待，但是如果该方法没有使用synchronized，则所有线程可以在同一时刻执行它，减少了执行的总时间。所以如果我们知道一个方法不会被多个线程执行到或者说不存在资源共享的问题，则不需要使用synchronized关键字。但是如果一定要使用synchronized关键字，那么我们可以synchronized代码块来替换synchronized方法。</p>
<p>synchronized代码块所起到的作用和synchronized方法一样，只不过它使临界区变的尽可能短了，换句话说：它只把需要的共享数据保护起来，其余的长代码块留出此操作。语法如下：</p>
<pre><code class="language-java">synchronized(object) {  
    //允许访问控制的代码  
}
</code></pre>
<p>如果我们需要以这种方式来使用synchronized关键字,那么必须要通过一个对象引用来作为参数,通常这个参数我们常使用为this.</p>
<pre><code class="language-java">synchronized (this) {
    //允许访问控制的代码 
}
</code></pre>
<p>对于synchronized(this)有如下理解：</p>
<ul>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li>
<li>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问object中的非synchronized(this)同步代码块。</li>
<li>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其他synchronized(this)同步代码块得访问将被阻塞。</li>
<li>第三个例子同样适用其他同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其他线程对该object对象所有同步代码部分的访问都将被暂时阻塞。</li>
<li>以上规则对其他对象锁同样适用</li>
</ul>
<p>Java中每一个对象都可以作为锁，它主要体现在下面三个方面：</p>
<ul>
<li>对于同步方法，锁是当前实例对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
<li>对于静态同步方法，锁是当前对象的Class对象。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的Git命令]]></title>
        <id>http://goroyal.github.io/post/git-commands/</id>
        <link href="http://goroyal.github.io/post/git-commands/">
        </link>
        <updated>2020-08-02T09:21:54.000Z</updated>
        <content type="html"><![CDATA[<p>配置账号信息</p>
<pre><code class="language-shell">git config --global user.name &quot;your username&quot;
git config --global user.email &quot;your email&quot;
</code></pre>
<p>查看配置相关的信息</p>
<pre><code class="language-shell">git config --list # 查看配置的信息
git help config # 获取帮助信息
</code></pre>
<p>配置自动换行</p>
<pre><code class="language-shell">git config --global core.autocrlf input # 提交到git时是否自动将换行符转换为lf
</code></pre>
<p>配置密钥</p>
<pre><code class="language-shell">ssh-keygen -t rsa -C &quot;your email&quot; # 生成密钥
ssh -T git@github.com # 测试是否成功
</code></pre>
<p>新建仓库</p>
<pre><code class="language-shell">git init # 初始化本地仓库
git clone &lt;url&gt; # 克隆远程版本库
git add –all # 添加所有文件到暂存区（stage，index）
git status # 查看当前git状态
git remote add origin https://github.com/freshdgq/test.git # 关联到远程仓库地址
git push -u origin master # 第一次推送master分支的所有内容
</code></pre>
<p>修改和提交</p>
<pre><code class="language-shell">git status # 查看git当前状态
git diff # 查看改动后和改动前的不同之处
git add . # 跟踪所有改动过的文件
git add &lt;file&gt; # 跟踪指定的文件
git mv &lt;old&gt; &lt;new&gt; # 文件改名
git rm &lt;file&gt; # 删除指定文件
git rm --cached &lt;file&gt; # 停止跟踪文件但不删除
git commit -m &quot;message&quot; # 提交修改的文件到当前分支
git commit --amend # 修改最后一次提交
</code></pre>
<p>状态与版本处理</p>
<pre><code class="language-shell">git log # 查看提交的历史记录
git log -p &lt;file&gt; # 查看指定文件的提交记录
git blame &lt;file&gt; # 以列表方式查看指定文件的提交历史
git reset --hard HEAD  # 撤销工作目录中所有未提交文件的修改内容
git checkout HEAD &lt;file&gt; # 撤销指定的未提交文件的修改内容
git revert &lt;commit&gt; 撤销指定的提交
git reset --hard HEAD^ # 回退本地分支到上一个版本
git reset --hard HEAD~n # 回退本地分支到上n个版本
git checkout – readme.txt # 把readme.txt文件在工作区的修改全部撤销
</code></pre>
<p>分支与标签处理</p>
<pre><code class="language-shell">git branch # 查看本地所有分支
git checkout &lt;branch/tag&gt; # 切换到指定分支或标签

git branch &lt;new-branch&gt; # 创建新分支
git checkout -b &lt;new-branch&gt; # 创建并切换到新分支
git branch -d &lt;branch&gt; # 删除本地分支

git merge &lt;branch&gt; # 合并指定分支到当前分支
git rebase &lt;branch&gt; # 衍合指定分支到当前分支

git tag # 列出所有本地标签
git tag &lt;tagname&gt; # 基于最新提交创建标签
git tag -d &lt;tagname&gt; # 删除标签
</code></pre>
<p>本地远程</p>
<pre><code class="language-shell">git remote # 获得远程库列表
git remote v # 查看远程版本库信息
git remote show &lt;remote&gt; # 查看指定远程版本库信息
git remote add &lt;remote&gt;&lt;url&gt; # 添加远程版本库
git remote rm &lt;name&gt; # 删除对应的远程库
git branch -u origin/master master # 本地跟踪远程

git fetch &lt;remote&gt; # 从远程库获取代码
git pull &lt;remote&gt;&lt;branch&gt; # 拉取远程指定分支代码并快速合并
git push &lt;remote&gt;&lt;branch&gt; # 推送代码到远程指定分支并快速合并
git push &lt;remote&gt;:&lt;branch/tag-name&gt; # 删除远程分支或标签
git push --tags # 上传所有标签

git pull origin master # 从远程的master分支拉取代码到本地
git push origin master # 推送最新修改到远程的主分支
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网页里面引起脚本执行的方式]]></title>
        <id>http://goroyal.github.io/post/execute-script-in-web-page/</id>
        <link href="http://goroyal.github.io/post/execute-script-in-web-page/">
        </link>
        <updated>2020-08-02T09:16:09.000Z</updated>
        <content type="html"><![CDATA[<p>在当前页面的执行环境里执行脚本的方式：</p>
<ul>
<li>直接嵌入<code>&lt;script&gt;</code>代码块</li>
<li>通过<code>&lt;script src=...&gt;</code>加载远程代码</li>
<li>在各种HTML和CSS参数里通过<code>javascript:URL</code>触发调用</li>
<li>CSS <code>expression(...)</code>和某些浏览器里的XBL绑定</li>
<li>事件处理器（Event Handlers），譬如onclick、onerror、onload等</li>
<li>定时器Timers（setTimeout，setInterval）</li>
<li><code>eval(...)</code>调用</li>
</ul>
<p>表面上这些方法组合起来使用也很正常，但往往会造成极其难以预料的危险解析链传递。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java包装类的比较]]></title>
        <id>http://goroyal.github.io/post/java-baozhuang-class/</id>
        <link href="http://goroyal.github.io/post/java-baozhuang-class/">
        </link>
        <updated>2020-07-20T11:56:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="boolean">Boolean</h2>
<p><code>Boolean</code>内部维护了两个常量：</p>
<pre><code class="language-Java">public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
</code></pre>
<p>所以对于<code>Boolean a = true; Boolean b = true;</code>，<code>a == b</code>是得到true的。</p>
<h2 id="integer">Integer</h2>
<p><code>Integer</code>对一段范围内的数字有个缓存：IntegerCache.low ~ IntegerCache.high<br>
如果数字在这个范围内，两个integer <code>==</code>是返回true的；否则就会new一个对象返回，肯定是不相等的。<br>
<code>IntegerCache</code>的low是固定死的-128，high默认127，可以通过这个配置修改<code>-XX:AutoBoxCacheMax</code>。</p>
<h2 id="short-long">Short、Long</h2>
<p>和Integer差不多，但是它们的high是固定的127。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/aCoder2013/blog/issues/14">Java原生类型包装类初解析</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的线程]]></title>
        <id>http://goroyal.github.io/post/java-thread/</id>
        <link href="http://goroyal.github.io/post/java-thread/">
        </link>
        <updated>2020-07-20T11:00:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程状态">线程状态</h2>
<ol>
<li>新建：创建后尚未启动的线程处于这种状态</li>
<li>运行：运行状态包括操作系统中的运行态和就绪态，也就是说这个状态下的线程可能正在执行，也有可能在等待CPU为它分配执行时间；</li>
<li>无限期等待：处于这种状态的线程不会被分配CPU，它们要被其它进程显式唤醒。可能进入这种状态的操作有：
<ul>
<li>没有设置时间参数的wait和join方法；</li>
<li>LockSupport.park()方法；</li>
</ul>
</li>
<li>限期等待：处于这种状态的线程也不会被分配执行时间，不过不需要其它线程唤醒，等一段时间之后就会由系统自动唤醒。可能进入这种状态的有：
<ul>
<li>设置了时间参数的wait和join方法；</li>
<li>sleep方法；</li>
<li>LockSupport.parkNanos()方法、LockSupport.parkUntil()方法；</li>
</ul>
</li>
<li>阻塞状态：线程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获得一个排它锁。而等待状态则是在等待一段时间，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。</li>
<li>结束：已终止线程的线程状态，线程已经结束执行。</li>
</ol>
<h2 id="线程安全">线程安全</h2>
<p>当多个线程访问一个对象的时候，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】Java里的各种Map]]></title>
        <id>http://goroyal.github.io/post/java-map/</id>
        <link href="http://goroyal.github.io/post/java-map/">
        </link>
        <updated>2020-07-10T08:34:59.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Map</code>就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。</p>
<p>Java里面基于对Map的不同访问需求创建了它的不同实现类：</p>
<ul>
<li>对键的顺序没有要求</li>
<li>取出键的顺序按照插入记录时的顺序</li>
<li>取出键的顺序按照键的升序排序</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p><code>Map</code>就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。</p>
<p>Java里面基于对Map的不同访问需求创建了它的不同实现类：</p>
<ul>
<li>对键的顺序没有要求</li>
<li>取出键的顺序按照插入记录时的顺序</li>
<li>取出键的顺序按照键的升序排序</li>
</ul>
<!-- more -->
<h2 id="hashmap">HashMap</h2>
<p><code>Hashmap</code> 是一个最常用的Map，它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。</p>
<h3 id="空键问题">空键问题</h3>
<p><code>HashMap</code>最多只允许一条记录的键为Null，允许多条记录的值为 Null。</p>
<h3 id="线程安全问题">线程安全问题</h3>
<p><code>HashMap</code>的访问没有锁，即任一时刻可以有多个线程同时写HashMap，对它的访问是线程不安全的，可能会导致数据的不一致。如果需要线程安全，可以使用<code>ConcurrentHashMap</code>，<code>ConcurrentHashMap</code>的锁是分段加的；另外一种线程安全的Map结构是<code>HashTable</code>，它与<code>HashMap</code>类似，继承自Dictionary类，但是它不允许记录的键或者值为空，<code>HashTable</code>的线程安全是通过对整个数据结构上锁，，即任一时刻只有一个线程能写Hashtable，多线程情况下效率很低。</p>
<h3 id="hashcode与equals">HashCode与equals</h3>
<p><code>hashCode</code>是用来计算hash值的，hash值是用来确定hash表索引的。<br>
hash表中的一个索引处存放的是一张链表，所以还要通过<code>equals</code>方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry。put记录时，如果hash表中没定位到，就在链表前加一个Entry；如果定位到了，则更换Entry中的值，并返回旧的值。</p>
<h3 id="使用">使用</h3>
<p>一般情况下，我们用的最多的是<code>HashMap</code>，它里面存入的记录在取出的时候是随机的，它根据键的HashCode存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<p><code>LinkedHashMap</code>保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当<code>HashMap</code>容量很大，实际数据较少时，遍历起来可能会比<code>LinkedHashMap</code>慢，因为<code>LinkedHashMap</code>的遍历速度只和实际数据有关，和容量无关，而<code>HashMap</code>的遍历速度和他的容量有关。</p>
<p><code>LinkedHashMap</code> 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。</p>
<h2 id="treemap">TreeMap</h2>
<p><code>TreeMap</code>实现<code>SortMap</code>接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code> 遍历<code>TreeMap</code>时，得到的记录是排过序的。<br>
TreeSet集合排序有两种方式，Comparable和Comparator区别：</p>
<ul>
<li>让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</li>
<li>让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数，方式较为灵活。</li>
</ul>
<p><code>TreeMap</code>取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么<code>TreeMap</code>会更好。<code>TreeMap</code>更是多了一个排序的功能。</p>
<h3 id="comparator">Comparator</h3>
<p>由于TreeMap需要排序，所以需要一个Comparator为键值进行大小比较，当然也是用Comparator定位的。</p>
<ol>
<li>Comparator可以在创建TreeMap时指定；</li>
<li>如果创建时没有确定Comparator对象，那么就会使用key.compareTo()方法，这就要求key必须实现Comparable接口；</li>
<li>TreeMap是使用Tree数据结构实现的，所以使用Comparator接口就可以完成定位了。</li>
</ol>
<h2 id="相关set">相关Set</h2>
<p><code>HashSet</code>是通过<code>HashMap</code>实现的，<code>TreeSet</code>是通过<code>TreeMap</code>实现的。Java里的Set实现其实用的是Map的key。<br>
Map的key和Set都有一个共同的特性：集合的唯一性。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="http://blog.csdn.net/fg2006/article/details/6411200">HashMap,LinkedHashMap,TreeMap的区别</a></p>
]]></content>
    </entry>
</feed>