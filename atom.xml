<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://119.45.146.199</id>
    <title>Goroyal&apos;s blog</title>
    <updated>2020-09-04T07:36:40.280Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://119.45.146.199"/>
    <link rel="self" href="http://119.45.146.199/atom.xml"/>
    <subtitle>学习分享</subtitle>
    <logo>http://119.45.146.199/images/avatar.png</logo>
    <icon>http://119.45.146.199/favicon.ico</icon>
    <rights>All rights reserved 2020, Goroyal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[JVM调优之参数配置]]></title>
        <id>http://119.45.146.199/post/jvm-args/</id>
        <link href="http://119.45.146.199/post/jvm-args/">
        </link>
        <updated>2020-08-21T02:23:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="堆内存大小设置">堆内存大小设置</h2>
<p>JVM的堆内存大小有三方面限制：</p>
<ul>
<li>相关操作系统的数据模型（32位还是64位）限制</li>
<li>系统的可用虚拟内存限制</li>
<li>系统的可用物理内存限制</li>
</ul>
<p>32位系统下，一般限制在1.5G~2G，64位操作系统对内存无限制。</p>
<p>JVM的堆内存分为2块：</p>
<ul>
<li>Meta space：从Java 8开始，Java淘汰了原来的持久代（Permanent Generation），代之以元空间Meta space。主要存放的是Java类定义信息和常量。</li>
<li>Heap = 分为年轻代和年老代。年轻代又常分为2个Survivor区和1个Eden区。年轻代和年老代的划分对垃圾收集影响比较大。</li>
</ul>
<p>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。</p>
<p>2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<p>针对年轻代的垃圾回收即Young GC。在年轻代中经历了若干次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。针对年老代的垃圾回收即Full GC。</p>
<p>JVM的一个典型设置：</p>
<pre><code class="language-shell">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k
</code></pre>
<ul>
<li><code>-Xmx3550m</code>：设置JVM最大可用内存为3550M。</li>
<li><code>-Xms3550m</code>：设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li>
<li><code>-Xmn2g</code>：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 元空间大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，<strong>Oracle官方推荐配置为整个堆的3/8</strong>。</li>
<li><code>-Xss128k</code>：设置每个线程的堆栈大小。Java 5以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li>
</ul>
<pre><code class="language-shell">java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 
</code></pre>
<ul>
<li><code>-XX:NewRatio=4</code>：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</li>
<li><code>-XX:SurvivorRatio=4</code>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</li>
<li><code>-XX:MaxTenuringThreshold=0</code>：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li>
</ul>
<h2 id="回收器选择">回收器选择</h2>
<p>JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，Java 5以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p>
<h3 id="吞吐量优先的并行收集器">吞吐量优先的并行收集器</h3>
<p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。<br>
典型配置：</p>
<pre><code class="language-shell">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20
</code></pre>
<ul>
<li><code>-XX:+UseParallelGC</code>：选择并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</li>
<li><code>-XX:ParallelGCThreads=20</code>：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</li>
</ul>
<pre><code> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC
</code></pre>
<ul>
<li><code>-XX:+UseParallelOldGC</code>：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</li>
</ul>
<pre><code class="language-shell">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100
</code></pre>
<ul>
<li><code>-XX:MaxGCPauseMillis=100</code>：设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</li>
</ul>
<pre><code class="language-shell">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy
</code></pre>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p>
<h3 id="响应时间优先的并发收集器">响应时间优先的并发收集器</h3>
<p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。<br>
典型配置：</p>
<pre><code class="language-shell">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
</code></pre>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：设置年老代为并发收集。测试中配置这个以后，<code>-XX:NewRatio=4</code>的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</li>
<li><code>-XX:+UseParNewGC</code>：设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li>
</ul>
<pre><code class="language-shell">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection
</code></pre>
<ul>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li>
</ul>
<h2 id="辅助信息">辅助信息</h2>
<p>JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：</p>
<h3 id="-xxprintgc"><code>-XX:+PrintGC</code></h3>
<p>输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]<br>
[Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</p>
<h3 id="-xxprintgcdetails"><code>-XX:+PrintGCDetails</code></h3>
<p>输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>
[GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</p>
<h3 id="-xxprintgctimestamps"><code>-XX:+PrintGCTimeStamps</code></h3>
<p>PrintGCTimeStamps可与上面两个混合使用<br>
输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</p>
<h3 id="-xxprintgcapplicationconcurrenttime"><code>-XX:+PrintGCApplicationConcurrentTime</code></h3>
<p>打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用<br>
输出形式：Application time: 0.5291524 seconds</p>
<h3 id="-xxprintgcapplicationstoppedtime"><code>-XX:+PrintGCApplicationStoppedTime</code></h3>
<p>打印垃圾回收期间程序暂停的时间。可与上面混合使用<br>
输出形式：Total time for which application threads were stopped: 0.0468229 seconds</p>
<h3 id="-xxprintheapatgc"><code>-XX:PrintHeapAtGC</code></h3>
<p>打印GC前后的详细堆栈信息，输出形式：<br>
34.702: [GC {Heap before gc invocations=7:<br>
def new generation total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)<br>
eden space 49152K, 99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)<br>
from space 6144K, 55% used [0x221d0000, 0x22527e10, 0x227d0000)<br>
to space 6144K, 0% used [0x21bd0000, 0x21bd0000, 0x221d0000)<br>
tenured generation total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)<br>
the space 69632K, 3% used [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)<br>
compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)<br>
the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)<br>
ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)<br>
rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)<br>
34.735: [DefNew: 52568K-&gt;3433K(55296K), 0.0072126 secs] 55264K-&gt;6615K(124928K)Heap after gc invocations=8:<br>
def new generation total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)<br>
eden space 49152K, 0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000)<br>
from space 6144K, 55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000)<br>
to space 6144K, 0% used [0x221d0000, 0x221d0000, 0x227d0000)<br>
tenured generation total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)<br>
the space 69632K, 4% used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)<br>
compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)<br>
the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)<br>
ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)<br>
rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)<br>
}<br>
, 0.0757599 secs]</p>
<h3 id="-xloggcfilename">-Xloggc:filename</h3>
<p>与上面几个配合使用，把相关日志信息记录到文件以便分析。</p>
<h2 id="常见配置汇总">常见配置汇总</h2>
<h3 id="堆设置">堆设置</h3>
<ul>
<li>-Xms:初始堆大小</li>
<li>-Xmx:最大堆大小</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
</ul>
<h4 id="优先级">优先级</h4>
<p>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级如下：</p>
<ul>
<li>高优先级：-XX:NewSize/-XX:MaxNewSize</li>
<li>中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?）</li>
<li>低优先级：-XX:NewRatio</li>
</ul>
<h3 id="收集器设置">收集器设置</h3>
<ul>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
</ul>
<h4 id="并行收集器设置">并行收集器设置</h4>
<ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li>
</ul>
<h4 id="并发收集器设置">并发收集器设置</h4>
<ul>
<li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li>
<li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。</li>
</ul>
<h4 id="垃圾回收统计信息">垃圾回收统计信息</h4>
<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
<h2 id="调优总结">调优总结</h2>
<h3 id="年轻代大小选择">年轻代大小选择</h3>
<ul>
<li>响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</li>
<li>吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</li>
</ul>
<h3 id="年老代大小选择">年老代大小选择</h3>
<ul>
<li>响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</li>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li>花在年轻代和年老代回收上的时间比例，减少年轻代和年老代花费的时间，一般会提高应用的效率</li>
<li>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</li>
</ul>
<h3 id="较小堆引起的碎片问题">较小堆引起的碎片问题</h3>
<p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：</p>
<ul>
<li>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。</li>
<li>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.iteye.com/blog/unixboy-174173">JVM调优总结 -Xms -Xmx -Xmn -Xss</a></li>
<li><a href="https://blog.csdn.net/sivyer123/article/details/17139443">JVM 堆内存设置原理</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java持久化API]]></title>
        <id>http://119.45.146.199/post/jpa/</id>
        <link href="http://119.45.146.199/post/jpa/">
        </link>
        <updated>2020-08-03T08:04:32.000Z</updated>
        <content type="html"><![CDATA[<p>Java持久化API(Java Persistence API, JPA)是基于POJO的持久化机制，从Hibernate和Java数据对象上借鉴了很多理念，引入了Java 5注解的特性。</p>
<p>在Spring中使用JPA的第一步是要在Spring应用上下文中将实体管理器工厂按照Bean的形式来进行配置。</p>
<h2 id="配置实体管理器工厂">配置实体管理器工厂</h2>
<p>基于JPA的应用程序使用EntityManagerFactory的实现类来获取EntityManager实例。<br>
JPA定义的两种类型的实体管理器：</p>
<ul>
<li>应用程序管理类型（Application-managed），由LocalEntityManagerFactoryBean生成</li>
<li>容器管理类型（Container-managed），由LocalContainerEntityManagerFactoryBean生成</li>
</ul>
<p>二者区别在于EntityManager的创建和管理方式：</p>
<ul>
<li>应用程序管理类型的EntityManager由EntityManagerFactory创建</li>
<li>容器管理类型的EntityManager由PersistenceProvider的createEntityManagerFactory()方法得到的<br>
二者唯一值得关注的区别是在Spring应用上下文中如何进行配置。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#中引入的class命名空间相同但是source不同的问题解决]]></title>
        <id>http://119.45.146.199/post/csharp-same-class-name-namespace-diff-source/</id>
        <link href="http://119.45.146.199/post/csharp-same-class-name-namespace-diff-source/">
        </link>
        <updated>2020-08-03T07:39:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="场景">场景</h2>
<ol>
<li>在z项目里引用x和y项目，分别为x.dll和y.dll。</li>
<li>引入的class A在x.dll和y.dll都定义了，而且命名空间一样，然后x和y同时在z项目中被用到，z中想使用class A就会遇到这问题</li>
<li>x项目中定义了class A，同时y项目中在csproj文件里用<code>&lt;Compile Include=&quot;..\x\A.cs&quot;&gt;</code>将其引入进来并重新编译。然后x和y同时在z项目中被用到，z中想使用class A时候就会同样遇到这问题。</li>
</ol>
<h2 id="解决方案">解决方案</h2>
<p>第一步，在z项目引入x和y的时候指定它的alias，如下：</p>
<pre><code class="language-XML">&lt;ProjectReference Include=&quot;..\ProjextX\ProjextX.csproj&quot;&gt;
    &lt;Project&gt;{EE0F5BBF-54D4-40EB-BEB2-5D07A49BC5B8}&lt;/Project&gt;
    &lt;Name&gt;ProjextX.ClassA&lt;/Name&gt;
    &lt;Aliases&gt;ClassA&lt;/Aliases&gt;
&lt;/ProjectReference&gt;
</code></pre>
<p>第二步，在z项目中用到class A的地方，先在引用其他namespace之前加上<code>extern alias</code>，比如：</p>
<pre><code class="language-java">// 引入命名空间前
extern alias ProjextX;

// 调用的时候
private readonly ProjectZ::ProjextX.ClassA variable = new ProjectZ::ProjextX.ClassA();
</code></pre>
<p>注意的是，<code>extern alias</code>放在自己这个类的namespace定义外边还是里边效果是不一样的。</p>
<h1 id="参考链接">参考链接</h1>
<p>https://blogs.msdn.microsoft.com/ansonh/2006/09/27/extern-alias-walkthrough/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MSBuild学习]]></title>
        <id>http://119.45.146.199/post/msbuild-learn/</id>
        <link href="http://119.45.146.199/post/msbuild-learn/">
        </link>
        <updated>2020-08-03T07:36:16.000Z</updated>
        <content type="html"><![CDATA[<p>MSBuild是.NET平台下的构建工具。</p>
<h1 id="概览">概览</h1>
<p>MSBuild也就是用于构建应用的Microsoft Build Engine，它提供一个XML Schema用于project文件来控制构建平台process、build软件。<br>
可以使用Visual Studio或者调用MSBuild.exe来完成这个操作。VS里边的project文件（<code>.csproj</code>、<code>vbproj</code>、<code>vcxproj</code>等）包含MSBuild XML代码，这些代码将在使用IDE build project的时候被运行。</p>
<p>在VS 2017里面使用的MSBuild版本是15，现在MSBuild装在VS的每个版本的文件夹中，比如<code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild</code>。也可以使用这个powershell命令来定位MSBuild：<a href="https://github.com/Microsoft/vssetup.powershell"><code>vssetup.powershell</code></a>。</p>
<p><code>MSBuildToolsPath</code>不再是一个固定的位置。默认情况下将是相对于VS安装位置的<code>MSBuild\15.0\Bin</code>文件夹中。</p>
<h2 id="msbuild的相关概念">MSBuild的相关概念</h2>
<h3 id="properties">Properties</h3>
<p>Properties是键值对，可以用来配置builds。</p>
<pre><code class="language-XML">&lt;PropertyGroup&gt;
    &lt;BuildDir&gt;Build&lt;/BuildDir&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>在整个project文件中，properties通过<code>$(&lt;PropertyName&gt;)</code>的方式被引用，比如使用上面的BuildDir属性，则用<code>$(BuildDir)</code>即可。<br>
Properties的值可以被redefine。</p>
<p>MSBuild中保留的或众所周知的properties：</p>
<ul>
<li><code>MSBuildBinPath</code>: 当前使用的MSBuild binaries位置的绝对路径，例如<code>C:\Windows\Microsoft.Net\Framework\&lt;versionNumber&gt;</code></li>
<li><code>MSBuildExtensionsPath</code></li>
<li><code>MSBuildProjectFile</code>: project文件的完整文件名，例如<code>MyApp.proj</code></li>
</ul>
<p>完整的见<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2017">MSBuild reserved and well-known properties</a></p>
<p>可以使用<code>Condition</code> attribute来为一个property提供默认值，如果这个property没有value则给它设置一个。比如</p>
<pre><code class="language-XML">&lt;ToolsPath Condition=&quot;''$(TOOLSPATH)' == ''&quot;&gt;c:\tools&lt;/ToolsPath&gt;
</code></pre>
<p>除了在project文件中做配置，也可以在命令行执行的时候设置property。如：</p>
<pre><code class="language-shell">msbuild file.proj -property:Flavor=Debug
msbuild file.proj -p:Flavor=Debug
msbuild file.proj -p:Flavor=Debug;Platform=x86
msbuild file.proj -p:Flavor=Debug -p:Platform=x86
</code></pre>
<p>环境变量也会被认为是properties，并且自动被MSBuild装载进来。</p>
<h3 id="items">Items</h3>
<p>Items是build system的输入，通常代表文件。</p>
<pre><code class="language-XML">&lt;ItemGroup&gt;
    &lt;Compile Include = &quot;file1.cs&quot;/&gt;
    &lt;Compile Include = &quot;file2.cs&quot;/&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>file2.cs是append在file1.cs之后的，也可以结合<code>**</code>、<code>*</code>、<code>？</code>用wildcard模式，例如：</p>
<pre><code class="language-XML">&lt;CSFile Include=&quot;*.cs&quot;/&gt;
或者
&lt;ItemGroup&gt; 
    &lt;CSFile Include=&quot;*.cs&quot; Exclude=&quot;DoNotBuild.cs&quot;/&gt;
&lt;/ItemGroup&gt;
</code></pre>
<h3 id="targets">Targets</h3>
<p>解释如何将tasks以特定的顺序组合到一起，并在命令行调用构建过程的各个部分。<br>
感觉类似Ant的targets。详细的见<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets?view=vs-2017">MSBuild targets</a></p>
<h3 id="tasks">Tasks</h3>
<p>显示如何创建可以被MSBuild使用的可执行代码单元去执行原子的build操作。</p>
<h3 id="special-characters">Special Characters</h3>
<p>% $ @ ' ; ? *</p>
<h1 id="参考">参考</h1>
<p><a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2017">微软官方文档：MSBuild</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Inverted Index]]></title>
        <id>http://119.45.146.199/post/inverted-index/</id>
        <link href="http://119.45.146.199/post/inverted-index/">
        </link>
        <updated>2020-08-03T07:33:37.000Z</updated>
        <content type="html"><![CDATA[<p>Inverted Index, 也就是反向索引（倒排索引）。反向索引结构是典型的搜索引擎算法重要的部分。</p>
<p>常规的索引是文档到关键词的映射，但是这样的话检索关键词会比较慢，需要遍历一个又一个的文档。反向索引是从关键词到文档，这样可以根据关键词找到它在哪个文档里出现。</p>
<p>一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档吗。</p>
<p>以英文为例，下面是要被索引的文本：</p>
<pre><code>T0 = &quot;it is what it is&quot;
T1 = &quot;what is it&quot;
T2 = &quot;it is a banana&quot;
</code></pre>
<p>可以得到下列的反向文件索引：</p>
<pre><code>&quot;a&quot;: {2}
&quot;banana&quot;: {2}
&quot;it&quot;: {0, 1, 2}
&quot;is&quot;: {0, 1, 2}
&quot;what&quot;: {0, 1}
</code></pre>
<p>还可以在反向索引里面加上单词出现的位置，比如<code>&quot;banana&quot;: {(2, 3)}</code>表示banana出现在第三个文本的第四个位置。</p>
<p>反向索引在ElasticSearch里面也被使用到（Lucene)。假设有2个文档，文档的<code>content</code>域包含下列内容：</p>
<ol>
<li>The quick brown fox jumped over the lazy dog</li>
<li>Quick brown foxes leap over lazy dogs in summer</li>
</ol>
<p>为了创建反向索引，首先将每个文档的<code>content</code>拆分成词（称为<code>词条</code>或<code>token</code>），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。如下所示：</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Doc_1</th>
<th>Doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Quick</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>The</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>brown</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>dog</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>dogs</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>fox</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>foxes</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>in</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>jumped</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>lazy</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>leap</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>over</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>quick</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>summer</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>the</td>
<td>X</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们想搜索<code>quick brown</code>，我们只需要查找包含每个词条的文档：</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Doc_1</th>
<th>Doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>brown</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>quick</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>2</strong></td>
<td><strong>1</strong></td>
</tr>
</tbody>
</table>
<p>两个文档都匹配，但是第一个文档比第二个匹配度更高。当然了，上面的反向索引存在点问题，比如<code>Quick</code>和<code>quick</code>，<code>dogs</code>和<code>dog</code>，可以作为相同词根进行索引，但还是不够的，需要进一步<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/analysis-intro.html">分析</a>。</p>
<h2 id="参考">参考</h2>
<p><a href="https://zh.wikipedia.org/zh-hans/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">维基百科</a><br>
<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html">ElasticSearch文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM类加载机制]]></title>
        <id>http://119.45.146.199/post/jvm-lei-jia-zai-ji-zhi/</id>
        <link href="http://119.45.146.199/post/jvm-lei-jia-zai-ji-zhi/">
        </link>
        <updated>2020-08-02T15:04:49.000Z</updated>
        <content type="html"><![CDATA[<p>Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。如编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。</p>
<p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段，其中验证、准备、解析三个部分统称为连接。</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，累的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。</p>
<p>对于初始化阶段，虚拟机规范严格规定有且只有5种情况必须对类立即进行”初始化“（加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic这4条指令码时，如果类没有进行过初始化，则需要先触发其初始化。这4个常见的Java代码场景：使用new关键字实例化对象时、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候、调用一个类的静态方法时。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要。。</li>
<li>当初始化一个类时，如果发现其父类还没有进行过初始化，需要。。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），需要。。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要。。</li>
</ul>
<p>加载类的过程：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>非数组类的加载是开发者可控性最强的，加载阶段既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器去完成。</p>
<p>对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，是由Java虚拟机直接创建的。但数组类与类加载器仍有密切关系，因为数组类的元素类型最终是要靠类加载器去创建。一个数组类（下称为C）创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（指的是数组去掉一个维度的类型）是引用类型，那就递归去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。（一个类必须与类加载器一起确定唯一性）</li>
<li>如果数组的组件类型不是引用类型（如int[]），Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</li>
</ul>
<p><strong>类加载器：</strong><br>
虚拟机设计团队把”通过一个类的全限定名来获取此类的二进制字节流“这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为”类加载器“。</p>
<p>类加载器可以说是java语言的一项创新，它在类层次划分、OSGi、热部署、代码加密等领域大放异彩。</p>
<p>每一个类加载器都拥有一个独立的类名称空间，比较两个类是否”相等“，只有这两个类是由同一个类加载器加载的前提下才有意义。这里的相等，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括instanceOf关键字做对象所属关系判定等情况。</p>
<p><strong>双亲委派模型：</strong><br>
从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器在Hotspot虚拟机中使用C++实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader。</p>
<p>从开发人员角度看，大部分Java程序都会使用以下3种系统提供的类加载器：</p>
<ul>
<li>启动类加载器，它复杂将$JAVA_HOME/lib中的并且是虚拟机识别的（仅按照文件名识别，如rt.jar）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</li>
<li>扩展类加载器，负责加载$JAVA_HOME/lib/ext中的所有类库，开发者可以直接使用扩展类加载器</li>
<li>应用程序类加载器，它是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果app中没有自定义过，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>类加载器的双亲委派模型，除了要求顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合关系来复用父加载器代码。<br>
自定义类加载器-&gt;应用程序类加载器-&gt;扩展类加载器-&gt;启动类加载器</p>
<p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去 尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系的显而易见的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。如类java.lang.Object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器去加载，因此Object类在程序的各种累加载器环境中都是同一个类。</p>
<p>破坏双亲委派模型：</p>
<ul>
<li>JDK 1.2之前的loadClass方法，后期为了兼容性做了妥协</li>
<li>JDNI服务，它的代码由启动类加载器去加载，但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的Classpath下的JNDI接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能”认识”这些代码，怎么处理？</li>
</ul>
<p>为了解决JNDI的问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader），这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那么这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，JNDI服务使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。Java中所有涉及SPI的加载动作基本上都采用了这种方式，如JNDI、JDBC、JCE、JAXB、JBI等。</p>
<p>双亲委派模型的第三次破坏是用户对程序动态性的追求导致的，如代码热替换、模块热部署。</p>
<p>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。OSGi按照下面顺序进行类搜索：</p>
<ul>
<li>将以java.*开头的类委派给父类加载器加载；</li>
<li>否则将委派列表名单内的类委派给父类加载器加载</li>
<li>否则将import列表中的类委派给export这个类的Bundle的类加载器加载</li>
<li>否则查找当前Bundle的Classpath，使用自己的类加载器加载</li>
<li>否则查找类是否在自己的Fragment Bundle中，如果在，委派给Fragment Bundle的类加载器加载</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则类查找失败。</li>
</ul>
<h4 id="字节码生成技术与动态代理的实现">字节码生成技术与动态代理的实现</h4>
<p>在java里面除了javac和字节码类库外，使用字节码生成的例子还有很多，如Web服务器中的JSP编译器，编译时植入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。我们选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的。<br>
即使没有直接用过java.lang.reflect.Proxy或实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况都会用过动态代理，因为如果Bean是面向接口编程，那么在Spring内部都是通过动态代理的方式来对Bean进行增强的。动态代理中所谓的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的。它的优势不在于省去了编写代理类那一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类和原始类脱离直接联系后，就可以很灵活地重用与不同的应用场景之中。</p>
<p>下面是最简单的动态代理用法：</p>
<pre><code class="language-Java">public class DynamicProxyTest {
	interface IHello {
		void sayHello();
	}
	
	static class Hello implements IHello {
		@Override
		public void sayHello() {
			System.out.println(&quot;hello world&quot;);
		}
	}
	
	static class DynamicProxy implements InvocationHandler {
		Object originalObj;
		Object bind(Object originalObj){
			this.originalObj = originalObj;
			return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);
		}
		
		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			System.out.println(&quot;welcome&quot;);
			return method.invoke(originalObj, args);
		}
	}
	
	public static void main(String[] args) {
		IHello hello = (IHello) new DynamicProxy().bind(new Hello());
		hello.sayHello();
	}
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>welcome
hello world
``
上述代码里唯一的“黑匣子”就是Proxy.newProxyInstance()方法，除此之外再没有任何特殊之处。这个方法返回了一个实现了IHello的接口，并且代理了new Hello()实例行为的对象。跟踪这个方法的源码可以看到程序进行了验证、优化、缓存、同步、生成字节码、显示类加载等操作，最后它调用了sun.misc.ProxyGenerator.generateProxyClass()方法来完成了字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码byte[]数组。如果想看这个在运行时产生的代理类中写了什么，可以在main()方法加入：

``` Java
System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, true)；
</code></pre>
<p>反编译后的代理类实现里面，为传入接口的每个方法以及从Object类继承的equals()、hashCode()、toString()方法都生成了对应的实现，并且统一调用了InvocationHandler对象的invoke()方法来实现这些方法的内容，这个方法的区别不过是传入的参数和Method对象有所不同而已。所以无论调用动态代理的哪一个方法，实际上都是在执行InvocationHandler.invoke()中的代理逻辑。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM垃圾收集器]]></title>
        <id>http://119.45.146.199/post/jvm-la-ji-shou-ji-qi/</id>
        <link href="http://119.45.146.199/post/jvm-la-ji-shou-ji-qi/">
        </link>
        <updated>2020-08-02T15:03:44.000Z</updated>
        <content type="html"><![CDATA[<p>常用垃圾收集器：G1，CMS等</p>
<h2 id="serial收集器">Serial收集器</h2>
<p>单线程的收集器，它的单线程的意义不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>Serial在新生代使用复制算法。Serial Old在老生代使用标记-整理算法。</p>
<p>虽然到后期的垃圾收集器，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除。</p>
<p>到目前为止，Serial收集器仍然是虚拟机运行在Client模式下的默认新生代收集器。</p>
<h2 id="parnew收集器">ParNew收集器</h2>
<p>Serial收集器的多线程版本。<br>
ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有个预性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是Hotspot虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。但是CMS作为老年代收集器却无法与JDK 1.4已经存在的新生代收集器Parallel Scavenge配合工作。</p>
<p>ParNew收集器是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UserParNewGC选项来强制指定它。</p>
<p>ParNew在单CPU环境中绝对不会有比Serial收集器更好的效果，甚至存在由于线程交互的开销。</p>
<h2 id="parallel-scavenge收集器">Parallel Scavenge收集器</h2>
<p>新生代收集器，也是使用复制算法、并行的多线程收集器。它的特点是关注点与其他收集器不同，CMS等收集器关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量（Throughput）。所谓吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>该收集器提供了两个参数用于精确控制吞吐量。</p>
<ul>
<li>-XX:MAXGCPauseMillis：控制最大垃圾收集停顿时间</li>
<li>-XX:GCTimeRatio：直接设置吞吐量大小</li>
</ul>
<p>Parallel Old是它在老年代的版本，使用多线程和标记-整理算法。</p>
<h2 id="cms收集器">CMS收集器</h2>
<p>Current Mark Sweep，一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。整个过程分为四步：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>初始标记和重新标记仍需要Stop The World。初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快。并发标记就是进校GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短。</p>
<p>CMS是一款优秀的收集器，但是3个缺点：</p>
<ul>
<li>对CPU资源非常敏感</li>
<li>无法处理浮动垃圾</li>
<li>是一款基于标记-清除算法的收集器，会有空间碎片产生</li>
</ul>
<h2 id="g1收集器garbage-first">G1收集器（Garbage First）</h2>
<p>并行与并发<br>
分代收集<br>
空间整合：G1整体来看是标记-整理，局部来看是基于复制算法。<br>
可预测的停顿</p>
<p>大致分为以下几步：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存溢出]]></title>
        <id>http://119.45.146.199/post/jvm-nei-cun-yi-chu/</id>
        <link href="http://119.45.146.199/post/jvm-nei-cun-yi-chu/">
        </link>
        <updated>2020-08-02T14:56:33.000Z</updated>
        <content type="html"><![CDATA[<p>JVM内存溢出经常有2种报错：</p>
<ul>
<li>OutOfMemory（OOM）</li>
<li>StackOverFlow（SOF ）</li>
</ul>
<p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError异常的可能。为了进行试验，在运行时使用以下的JVM参数：</p>
<pre><code>--verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
</code></pre>
<h2 id="java堆溢出">Java堆溢出</h2>
<p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>
<pre><code class="language-java">/**
 * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemorryError
 * 将对的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展，通过参数-XX:+HeapDumpOnOutOfMemorryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便时候进行分析
 */
public class HeapOOM {
	static class OOMObject {
	}
	
	public static void main(String[] args){
		List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();
		while(true){
			list.add(new OOMObject());
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">java.lang.OutOfMemoryError: Java Heap space
Dumping heap to java_pid3404.hprof...
Heap dump file created[22045981 bytes in 0.663 secs]
</code></pre>
<p>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息”java.lang.OutOfMemoryError“会跟着进一步提示”Java heap space“。</p>
<p>要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（<strong>Memory Leak</strong>）还是内存溢出（<strong>Memory Overflow</strong>）。</p>
<p>如果是内存泄露，可以进一步提高工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及GC Roots引用链的信息，就可以比较准确地定位出现泄露代码的位置。</p>
<p>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h2 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h2>
<p>由于在Hotspot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于Hotspot来说，虽然-Xoss参数（用于设置本地方法栈大小）存在，但实际上是无效的。栈容量只由-Xss参数设定。在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ul>
<p>这里把异常分成两种情况，看似更加严谨，但却存在一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上是对同一件事情的两种描述而已。</p>
<p>在《深入理解Java虚拟机规范》作者的实验中，将实验范围限制于单线程中的操作，尝试了两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是StackOverflowError。</p>
<ul>
<li>使用-Xss参数减少栈内存容量。结果，抛出StackOverflowError异常，异常出现时输出的堆栈深度相应地缩小。</li>
<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。</li>
</ul>
<pre><code class="language-java">/**
 * VM args: -Xss128k
 */
public class JavaVMStackOF {
	private int stackLength = 1;
	
	public void stackLeak() {
		stackLength++;
		stackLeak();
	}
	
	public static void main(String[] args) throws Throwable {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try {
			oom.stackLeak();
		} catch (Throwable e){
			System.out.println(&quot;stack length:&quot; + oom.stackLength);
			throw e;
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">stack length: 2402
Exception in thread &quot;main&quot; java.lang.StackOverflowError
	at....
.....后续异常堆栈信息省略
</code></pre>
<p>实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。<br>
如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系。或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。<br>
这一点需要在开发多线程应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说大多数情况下）达到1000~2000完全没有问题。但是如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，<strong>这种通过”减少内存“的手段来解决内存溢出的方式会比较难以想到</strong>。</p>
<pre><code class="language-java">public class JavaVMStackOOM {
	private void dontStop() {
		while (true) {}
	}
	
	public void stackLeakByThread() {
		while(true) {
			Thread thread = new Thread(new Runnable() {
				@Override
				public void run() {
					dontStop();
				}
			});
			thread.start();
		}
	}
	public static void main(String[] args) throws Throwable {
		JavaVMStackOOM oom = new JavaVMStackOOM();
		oom.stackLeakByThread();
	}
}
</code></pre>
<h2 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h2>
<p>JDK 1.7开始逐步”去永久代“，此处顺便看看这件事情的实际影响。<br>
String.intern()是一个Native方法，作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</p>
<pre><code class="language-java">/**
 * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		// 使用List保持着常量池引用，避免Full GC回收常量池行为
		List&lt;String&gt; list = new ArrayList&lt;&gt;();
		// 10MB的PermSize在integer范围内足够产生OOM了
		int i = 0;
		while (true) {
			list.add(String.valueOf(i++).intern());
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space
	at java.lang.String.intern(Native Method)
	at ... 
</code></pre>
<p>从运行结果可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是”PermGen space“，说明运行时常量池属于方法区（Hotspot虚拟机中的永久代）的一部分。</p>
<p>而使用JDK 1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响：</p>
<pre><code class="language-java">public class RuntimeConstantsPoolOOM {
	public static void main(String[] args){
		String str1 = new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString();
		System.out.println(str1.intern() == str1);
		
		String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();
		System.out.println(str2.intern() == str2);
	}
} 
</code></pre>
<p>这段代码在JDK 1.6中运行，会得到两个false；而在JDK 1.7中运行会得到一个true一个false。产生差异的原因是：JDK 1.6中，<code>intern()</code>方法会把所赐遇到的字符串实例复制到永久代中，返回的也是永久代总这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<br>
而在JDK 1.7中的<code>intern()</code>实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此<code>intern()</code>返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为&quot;java&quot;这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量中已经有它的引用额，不符合”首次出现“的原则，而”计算机软件“这个字符串则是首次出现的。</p>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当前的很多主流框架如Spring、Hibernate对类进行增强时都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。像大量反射、大量JSP文件或动态产生JSP文件的应用、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）也会需要较大的方法区保证。</p>
<h2 id="本机直接内存溢出">本机直接内存溢出</h2>
<p>DirectMemory容量可以通过<code>-XX:MaxDirectMemory</code>指定，如果不指定则默认与Java堆最大值一样。如下代码越过了DirectByBuffer类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配于是手动抛出异常，真正申请分配内存的方法是<code>unsafe.allocateMemory()</code>。</p>
<pre><code class="language-java">/**
 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
 */
public class DirectMemoryOOM {
	private static final int _1MB = 1024 * 1024;
	
	public static void main(String[] args) throws Exception {
		Field unsafeField = Unsafe.class.getDeclaredFields()[0];
		unsafeField.setAccessible(true);
		Unsafe unsafe = (Unsafe) unsafeField.get(null);
		while(true) {
			unsafe.allocateMemory(_1MB);
		}
	}
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError
	at ...
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM GC]]></title>
        <id>http://119.45.146.199/post/jvm-gc/</id>
        <link href="http://119.45.146.199/post/jvm-gc/">
        </link>
        <updated>2020-08-02T14:49:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引用计数法">引用计数法</h2>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>
客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下他都是一个不错的算法）。<br>
但是至少主流的Java虚拟机里没有选用该方法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<h2 id="可达性分析算法">可达性分析算法</h2>
<p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h2 id="标记-清除算法">标记-清除算法</h2>
<p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p>
<p>它的主要不足有两个：</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<h2 id="复制算法">复制算法</h2>
<p>为了解决效率问题，一种称为”复制“的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代。IBM公司的专门研究表明，新生代中的对象98%是”朝生夕死“的，所以不需要按照1：1的比例来划分内存空间，而是将一块内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Hotspot虚拟机默认Eden和Survivor大小比例是8：1。</p>
<p>当然，我们也没有办法保证每次回收都只有不多于10%对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<h2 id="标记-整理算法">标记-整理算法</h2>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出标记-整理算法，标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h2 id="分代收集算法">分代收集算法</h2>
<p>当前商业虚拟机的垃圾收集都采用”分代收集“算法，这种算法根据对象存活周期的不同将内存分为几块。一般是把Java堆分为新生代和老生代。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java内存模型]]></title>
        <id>http://119.45.146.199/post/java-memory-model/</id>
        <link href="http://119.45.146.199/post/java-memory-model/">
        </link>
        <updated>2020-08-02T14:47:54.000Z</updated>
        <content type="html"><![CDATA[<p>在多核系统中，处理器一般有一层或者多层的缓存，这些的缓存通过加速数据访问（因为数据距离处理器更近）和降低共享内存在总线上的通讯（因为本地缓存能够满足很多内存操作）来提高CPU性能。缓存能够大大提升性能，但是它们也带来了许多挑战。例如，当两个CPU同时检查相同的内存地址时会发生什么？在什么样的条件下它们会看到相同的值？</p>
<p>在处理器层面上，内存模型定义了一个充要条件：“让当前的处理器可以看到其他的处理器写入到内存数据”以及“其他处理器可以看到当前处理器写入到内存的数据”。有些处理器有很强的内存模型（strong memory model），能够让所有的处理器在任何时候任何指定的内存地址上都可以看到完全相同的值。而另外一些处理器则有较弱的内存模型（weaker memory model），在这种处理器中，必须使用内存屏障（一种特殊的指令）来刷新本地处理器缓存并使本地处理器缓存无效，目的是为了让当前处理器能够看到其他处理器的写操作或者让其他处理器能看到当前处理器的写操作。这些内存屏障通常在lock和unlock操作的时候完成。内存屏障在高级语言中对程序员是不可见的。</p>
<p>在强内存模型下，有时候编写程序可能会更容易，因为减少了对内存屏障的依赖。但是即使在一些最强的内存模型下，内存屏障仍然是必须的。设置内存屏障往往与我们的直觉并不一致。进来处理器设计的趋势更倾向于弱的内存模型，因为弱内存模型削弱了缓存一致性，所以在多处理器平台和更大容量的内存下可以实现更好的可伸缩性。</p>
<p>“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反应了缓存的影响。</p>
<p>此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其性能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。</p>
<h2 id="哪个区域存放哪些内容">哪个区域存放哪些内容</h2>
<ul>
<li>方法区：各个线程的共享区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。习惯在Hotspot虚拟机上的开发者很多人把方法区成为“永久代”。</li>
<li>虚拟机栈：线程私有的，描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口灯信息。每一个方法从调研直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译器可知的各种基本数据类型、对象引用和redurnAddress类型。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
<li>本地方法栈：与虚拟机栈类似，但是本地方法栈为虚拟机使用到的Native方法服务。</li>
<li>堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。是垃圾收集器管理的主要区域。</li>
<li>程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。JDK 1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li>
</ul>
]]></content>
    </entry>
</feed>