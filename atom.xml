<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://goroyal.github.io</id>
    <title>Goroyal&apos;s blog</title>
    <updated>2020-08-02T09:57:16.396Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://goroyal.github.io"/>
    <link rel="self" href="http://goroyal.github.io/atom.xml"/>
    <subtitle>学习分享</subtitle>
    <logo>http://goroyal.github.io/images/avatar.png</logo>
    <icon>http://goroyal.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Goroyal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Java锁]]></title>
        <id>http://goroyal.github.io/post/java-lock/</id>
        <link href="http://goroyal.github.io/post/java-lock/">
        </link>
        <updated>2020-08-02T09:34:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="锁状态">锁状态</h2>
<p>Java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>锁自旋</strong><br>
我们知道在当某个线程在进入同步方法/代码块时若发现该同步方法/代码块被其他现在所占，则它就要等待，进入阻塞状态，这个过程性能是低下的。</p>
<p>在遇到锁的争用或许等待事，线程可以不那么着急进入阻塞状态，而是等一等，看看锁是不是马上就释放了，这就是锁自旋。锁自旋在一定程度上可以对线程进行优化处理。</p>
<p><strong>偏向锁</strong><br>
偏向锁主要为了解决在没有竞争情况下锁的性能问题。在大多数情况下锁锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当某个线程获得锁的情况，该线程是可以多次锁住该对象，但是每次执行这样的操作都会因为CAS（CPU的Compare-And-Swap指令）操作而造成一些开销消耗性能，为了减少这种开销，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>当有其他线程在尝试着竞争偏向锁时，持有偏向锁的线程就会释放锁。</p>
<p><strong>锁膨胀</strong><br>
多个或多次调用粒度太小的锁，进行加锁解锁的消耗，反而还不如一次大粒度的锁调用来得高效。</p>
<p><strong>轻量级锁</strong><br>
轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。轻量级锁在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的指向和状态。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<h2 id="加锁方式">加锁方式</h2>
<p>在使用synchronized时，我们是这样使用锁的：</p>
<pre><code class="language-java">public class ThreadTest {
    public void test(){
        synchronized(this){
            //do something
        }
    }
}
</code></pre>
<p>synchronized可以确保在同一时间内只有一个线程在执行dosomething。下面是使用lock替代synchronized：</p>
<pre><code class="language-java">public class ThreadTest {
    Lock lock = new Lock();
    public void test(){
        lock.lock();
        //do something
        lock.unlock();
    }
}
</code></pre>
<p>lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。</p>
<h2 id="锁的公平性">锁的公平性</h2>
<p>公平性的对立面是饥饿。那么什么是“饥饿”呢？如果一个线程因为其他线程在一直抢占着CPU而得不到CPU运行时间，那么我们就称该线程被“饥饿致死”。而解决饥饿的方案则被称之为“公平性”——所有线程均可以公平地获得CPU运行机会。</p>
<p>导致线程饥饿主要有如下几个原因：<br>
高优先级线程吞噬所有的低优先级线程的CPU时间。我们可以为每个线程单独设置其优先级，从1到10。优先级越高的线程获得CPU的时间越多。对大多数应用来说，我们最好是不要改变其优先级值。</p>
<p>线程被永久堵塞在一个等待进入同步块的状态。Java的同步代码区是导致线程饥饿的重要因素。Java的同步代码块并不会保证进入它的线程的先后顺序。这就意味着理论上存在一个或者多个线程在试图进入同步代码区时永远被堵塞着，因为其他线程总是不断优于他获得访问权，导致它一直得到不到CPU运行机会被“饥饿致死”。</p>
<p>线程在等待一个本身也处于永久等待完成的对象。如果多个线程处在<code>wait()</code>方法执行上，而对其调用<code>notify()</code>不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
<p>为了解决线程“饥饿”的问题，我们可以使用锁实现公平性。</p>
<h2 id="锁的可重入性">锁的可重入性</h2>
<p>我们知道当线程请求一个由其它线程持有锁的对象时，该线程会阻塞，但是当线程请求由自己持有锁的对象时，是否可以成功呢？答案是可以成功的，成功的保障就是线程锁的“可重入性”。<br>
“可重入”意味着自己可以再次获得自己的内部锁，而不需要阻塞。如下：</p>
<pre><code class="language-java">public class Father {
    public synchronized void method(){
        //do something
    }
}
public class Child extends Father{
    public synchronized void method(){
        //do something 
        super.method();
    }
}
</code></pre>
<p>如果所是不可重入的，上面的代码就会死锁，因为调用child的method(),首先会获取父类Father的内置锁然后获取Child的内置锁，当调用父类的方法时，需要再次后去父类的内置锁，如果不可重入，可能会陷入死锁。</p>
<p>java多线程的可重入性的实现是通过每个锁关联一个请求计算和一个占有它的线程，当计数为0时，认为该锁是没有被占有的，那么任何线程都可以获得该锁的占有权。当某一个线程请求成功后，JVM会记录该锁的持有线程 并且将计数设置为1，如果这时其他线程请求该锁时则必须等待。当该线程再次请求请求获得锁时，计数会+1；当占有线程退出同步代码块时，计数就会-1，直到为0时，释放该锁。这时其他线程才有机会获得该锁的占有权。</p>
<ul>
<li>ReentrantLock：一个可重入的互斥锁，为lock接口的主要实现。</li>
<li>ReadWriteLock：ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。</li>
<li>ReentrantReadWriteLock：可重入读写锁</li>
<li>Semaphore：一个计数信号量。</li>
<li>Condition:锁的关联条件，目的是允许线程获取锁并且查看等待的某一个条件是否满足。</li>
<li>CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java synchronized]]></title>
        <id>http://goroyal.github.io/post/java-synchronized/</id>
        <link href="http://goroyal.github.io/post/java-synchronized/">
        </link>
        <updated>2020-08-02T09:32:20.000Z</updated>
        <content type="html"><![CDATA[<p>synchronized，我们谓之锁，主要用来给方法、代码块加锁。当某个方法或者代码块使用synchronized时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。</p>
<p>synchronized主要包括两种方法：synchronized 方法、synchronized 代码块。</p>
<p>synchronized 方法通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：</p>
<pre><code class="language-java">public synchronized void getResult();
</code></pre>
<p>synchronized方法控制对类成员变量的访问。它是如何来避免类成员变量的访问控制呢？我们知道方法使用了synchronized关键字表明该方法已加锁，在任一线程在访问改方法时都必须要判断该方法是否有其他线程在“独占”。每个类实例对应一个把锁，每个synchronized方法都必须调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，被阻塞的线程方能获得该锁。</p>
<p>其实synchronized方法是存在缺陷的，如果我们将一个很大的方法声明为synchronized将会大大影响效率的。如果多个线程在访问一个synchronized方法，那么同一时刻只有一个线程在执行该方法，而其他线程都必须等待，但是如果该方法没有使用synchronized，则所有线程可以在同一时刻执行它，减少了执行的总时间。所以如果我们知道一个方法不会被多个线程执行到或者说不存在资源共享的问题，则不需要使用synchronized关键字。但是如果一定要使用synchronized关键字，那么我们可以synchronized代码块来替换synchronized方法。</p>
<p>synchronized代码块所起到的作用和synchronized方法一样，只不过它使临界区变的尽可能短了，换句话说：它只把需要的共享数据保护起来，其余的长代码块留出此操作。语法如下：</p>
<pre><code class="language-java">synchronized(object) {  
    //允许访问控制的代码  
}
</code></pre>
<p>如果我们需要以这种方式来使用synchronized关键字,那么必须要通过一个对象引用来作为参数,通常这个参数我们常使用为this.</p>
<pre><code class="language-java">synchronized (this) {
    //允许访问控制的代码 
}
</code></pre>
<p>对于synchronized(this)有如下理解：</p>
<ul>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li>
<li>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问object中的非synchronized(this)同步代码块。</li>
<li>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其他synchronized(this)同步代码块得访问将被阻塞。</li>
<li>第三个例子同样适用其他同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其他线程对该object对象所有同步代码部分的访问都将被暂时阻塞。</li>
<li>以上规则对其他对象锁同样适用</li>
</ul>
<p>Java中每一个对象都可以作为锁，它主要体现在下面三个方面：</p>
<ul>
<li>对于同步方法，锁是当前实例对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
<li>对于静态同步方法，锁是当前对象的Class对象。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java ReetrantLock]]></title>
        <id>http://goroyal.github.io/post/java-reetrantlock/</id>
        <link href="http://goroyal.github.io/post/java-reetrantlock/">
        </link>
        <updated>2020-08-02T09:28:10.000Z</updated>
        <summary type="html"><![CDATA[<p><code>ReetrantLock</code>是一个可重入排它锁，和使用<code>synchronized</code>方法和语句的隐式监视器锁有着相同的基本行为和语义，但是性能有所扩展。</p>
<p><code>ReentrantLock</code>由上次成功加锁但是还没有解锁的线程所持有。在锁没有被其他线程持有时，一个线程调用<code>lock</code>将返回成功获取锁。如果当前线程已经持有锁那么该方法将立即返回。这个可以使用方法<code>isHeldByCurrentThread</code>和<code>getHoldCount</code>检查。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>ReetrantLock</code>是一个可重入排它锁，和使用<code>synchronized</code>方法和语句的隐式监视器锁有着相同的基本行为和语义，但是性能有所扩展。</p>
<p><code>ReentrantLock</code>由上次成功加锁但是还没有解锁的线程所持有。在锁没有被其他线程持有时，一个线程调用<code>lock</code>将返回成功获取锁。如果当前线程已经持有锁那么该方法将立即返回。这个可以使用方法<code>isHeldByCurrentThread</code>和<code>getHoldCount</code>检查。</p>
<!-- more -->
<p>这个类的构造器接收一个可选的公平性参数。当设为 true 时，在争用的情况下，锁倾向于授权给等待时间最长的线程。另外，这个锁不保证任何特定访问顺序。使用被多个线程访问的公平锁的程序将呈现比使用默认设置的情况较低的总吞吐量（也就是变慢了，通常是慢很多），但是在获取锁和保证不饥饿的时间上有较小的方差。</p>
<p>公平锁可以保证锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程饥饿，但是较少线程切换，保证了很大的吞吐量。</p>
<p>同样需要注意的是，不计时的<code>tryLock()</code>方法不赞成公平设置。如果锁是可用的它将成功获得锁，而不管其他线程是否正在等待。</p>
<p>建议实践时永远在<code>lock</code>后面立即跟上一个<code>try</code>块，大多数典型的在构造之前/之后的情况是：</p>
<pre><code class="language-java">class X {
	private final ReentrantLock lock = new ReentrantLock();
	//...
	public void m(){
		lock.lock(); // block until condition holds
		try{
			// ... method body
		} finally {
			lock.unlock();
		}
	}
}
</code></pre>
<p>除了实现<code>Lock</code>接口，<code>ReetrantLock</code>类定义了大量 public 和 protected 方法来检查锁的状态，其中有一些方法只用于仪表和监控。这个类的序列化和内置锁的行为方式一致：反序列化的锁是处于解锁状态，在序列化的时候不管当前它的状态。</p>
<p>这个锁支持相同线程递归锁最大2147483647次。尝试超过这个限制将导致从加锁方法抛出<code>Error</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的Git命令]]></title>
        <id>http://goroyal.github.io/post/git-commands/</id>
        <link href="http://goroyal.github.io/post/git-commands/">
        </link>
        <updated>2020-08-02T09:21:54.000Z</updated>
        <content type="html"><![CDATA[<p>配置账号信息</p>
<pre><code class="language-shell">git config --global user.name &quot;your username&quot;
git config --global user.email &quot;your email&quot;
</code></pre>
<p>查看配置相关的信息</p>
<pre><code class="language-shell">git config --list # 查看配置的信息
git help config # 获取帮助信息
</code></pre>
<p>配置自动换行</p>
<pre><code class="language-shell">git config --global core.autocrlf input # 提交到git时是否自动将换行符转换为lf
</code></pre>
<p>配置密钥</p>
<pre><code class="language-shell">ssh-keygen -t rsa -C &quot;your email&quot; # 生成密钥
ssh -T git@github.com # 测试是否成功
</code></pre>
<p>新建仓库</p>
<pre><code class="language-shell">git init # 初始化本地仓库
git clone &lt;url&gt; # 克隆远程版本库
git add –all # 添加所有文件到暂存区（stage，index）
git status # 查看当前git状态
git remote add origin https://github.com/freshdgq/test.git # 关联到远程仓库地址
git push -u origin master # 第一次推送master分支的所有内容
</code></pre>
<p>修改和提交</p>
<pre><code class="language-shell">git status # 查看git当前状态
git diff # 查看改动后和改动前的不同之处
git add . # 跟踪所有改动过的文件
git add &lt;file&gt; # 跟踪指定的文件
git mv &lt;old&gt; &lt;new&gt; # 文件改名
git rm &lt;file&gt; # 删除指定文件
git rm --cached &lt;file&gt; # 停止跟踪文件但不删除
git commit -m &quot;message&quot; # 提交修改的文件到当前分支
git commit --amend # 修改最后一次提交
</code></pre>
<p>状态与版本处理</p>
<pre><code class="language-shell">git log # 查看提交的历史记录
git log -p &lt;file&gt; # 查看指定文件的提交记录
git blame &lt;file&gt; # 以列表方式查看指定文件的提交历史
git reset --hard HEAD  # 撤销工作目录中所有未提交文件的修改内容
git checkout HEAD &lt;file&gt; # 撤销指定的未提交文件的修改内容
git revert &lt;commit&gt; 撤销指定的提交
git reset --hard HEAD^ # 回退本地分支到上一个版本
git reset --hard HEAD~n # 回退本地分支到上n个版本
git checkout – readme.txt # 把readme.txt文件在工作区的修改全部撤销
</code></pre>
<p>分支与标签处理</p>
<pre><code class="language-shell">git branch # 查看本地所有分支
git checkout &lt;branch/tag&gt; # 切换到指定分支或标签

git branch &lt;new-branch&gt; # 创建新分支
git checkout -b &lt;new-branch&gt; # 创建并切换到新分支
git branch -d &lt;branch&gt; # 删除本地分支

git merge &lt;branch&gt; # 合并指定分支到当前分支
git rebase &lt;branch&gt; # 衍合指定分支到当前分支

git tag # 列出所有本地标签
git tag &lt;tagname&gt; # 基于最新提交创建标签
git tag -d &lt;tagname&gt; # 删除标签
</code></pre>
<p>本地远程</p>
<pre><code class="language-shell">git remote # 获得远程库列表
git remote v # 查看远程版本库信息
git remote show &lt;remote&gt; # 查看指定远程版本库信息
git remote add &lt;remote&gt;&lt;url&gt; # 添加远程版本库
git remote rm &lt;name&gt; # 删除对应的远程库
git branch -u origin/master master # 本地跟踪远程

git fetch &lt;remote&gt; # 从远程库获取代码
git pull &lt;remote&gt;&lt;branch&gt; # 拉取远程指定分支代码并快速合并
git push &lt;remote&gt;&lt;branch&gt; # 推送代码到远程指定分支并快速合并
git push &lt;remote&gt;:&lt;branch/tag-name&gt; # 删除远程分支或标签
git push --tags # 上传所有标签

git pull origin master # 从远程的master分支拉取代码到本地
git push origin master # 推送最新修改到远程的主分支
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网页里面引起脚本执行的方式]]></title>
        <id>http://goroyal.github.io/post/execute-script-in-web-page/</id>
        <link href="http://goroyal.github.io/post/execute-script-in-web-page/">
        </link>
        <updated>2020-08-02T09:16:09.000Z</updated>
        <content type="html"><![CDATA[<p>在当前页面的执行环境里执行脚本的方式：</p>
<ul>
<li>直接嵌入<code>&lt;script&gt;</code>代码块</li>
<li>通过<code>&lt;script src=...&gt;</code>加载远程代码</li>
<li>在各种HTML和CSS参数里通过<code>javascript:URL</code>触发调用</li>
<li>CSS <code>expression(...)</code>和某些浏览器里的XBL绑定</li>
<li>事件处理器（Event Handlers），譬如onclick、onerror、onload等</li>
<li>定时器Timers（setTimeout，setInterval）</li>
<li><code>eval(...)</code>调用</li>
</ul>
<p>表面上这些方法组合起来使用也很正常，但往往会造成极其难以预料的危险解析链传递。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java包装类的比较]]></title>
        <id>http://goroyal.github.io/post/java-baozhuang-class/</id>
        <link href="http://goroyal.github.io/post/java-baozhuang-class/">
        </link>
        <updated>2020-07-20T11:56:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="boolean">Boolean</h2>
<p><code>Boolean</code>内部维护了两个常量：</p>
<pre><code class="language-Java">public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
</code></pre>
<p>所以对于<code>Boolean a = true; Boolean b = true;</code>，<code>a == b</code>是得到true的。</p>
<h2 id="integer">Integer</h2>
<p><code>Integer</code>对一段范围内的数字有个缓存：IntegerCache.low ~ IntegerCache.high<br>
如果数字在这个范围内，两个integer <code>==</code>是返回true的；否则就会new一个对象返回，肯定是不相等的。<br>
<code>IntegerCache</code>的low是固定死的-128，high默认127，可以通过这个配置修改<code>-XX:AutoBoxCacheMax</code>。</p>
<h2 id="short-long">Short、Long</h2>
<p>和Integer差不多，但是它们的high是固定的127。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/aCoder2013/blog/issues/14">Java原生类型包装类初解析</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的线程]]></title>
        <id>http://goroyal.github.io/post/java-thread/</id>
        <link href="http://goroyal.github.io/post/java-thread/">
        </link>
        <updated>2020-07-20T11:00:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程状态">线程状态</h2>
<ol>
<li>新建：创建后尚未启动的线程处于这种状态</li>
<li>运行：运行状态包括操作系统中的运行态和就绪态，也就是说这个状态下的线程可能正在执行，也有可能在等待CPU为它分配执行时间；</li>
<li>无限期等待：处于这种状态的线程不会被分配CPU，它们要被其它进程显式唤醒。可能进入这种状态的操作有：
<ul>
<li>没有设置时间参数的wait和join方法；</li>
<li>LockSupport.park()方法；</li>
</ul>
</li>
<li>限期等待：处于这种状态的线程也不会被分配执行时间，不过不需要其它线程唤醒，等一段时间之后就会由系统自动唤醒。可能进入这种状态的有：
<ul>
<li>设置了时间参数的wait和join方法；</li>
<li>sleep方法；</li>
<li>LockSupport.parkNanos()方法、LockSupport.parkUntil()方法；</li>
</ul>
</li>
<li>阻塞状态：线程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获得一个排它锁。而等待状态则是在等待一段时间，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。</li>
<li>结束：已终止线程的线程状态，线程已经结束执行。</li>
</ol>
<h2 id="线程安全">线程安全</h2>
<p>当多个线程访问一个对象的时候，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】Java里的各种Map]]></title>
        <id>http://goroyal.github.io/post/java-map/</id>
        <link href="http://goroyal.github.io/post/java-map/">
        </link>
        <updated>2020-07-10T08:34:59.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Map</code>就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。</p>
<p>Java里面基于对Map的不同访问需求创建了它的不同实现类：</p>
<ul>
<li>对键的顺序没有要求</li>
<li>取出键的顺序按照插入记录时的顺序</li>
<li>取出键的顺序按照键的升序排序</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p><code>Map</code>就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。</p>
<p>Java里面基于对Map的不同访问需求创建了它的不同实现类：</p>
<ul>
<li>对键的顺序没有要求</li>
<li>取出键的顺序按照插入记录时的顺序</li>
<li>取出键的顺序按照键的升序排序</li>
</ul>
<!-- more -->
<h2 id="hashmap">HashMap</h2>
<p><code>Hashmap</code> 是一个最常用的Map，它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。</p>
<h3 id="空键问题">空键问题</h3>
<p><code>HashMap</code>最多只允许一条记录的键为Null，允许多条记录的值为 Null。</p>
<h3 id="线程安全问题">线程安全问题</h3>
<p><code>HashMap</code>的访问没有锁，即任一时刻可以有多个线程同时写HashMap，对它的访问是线程不安全的，可能会导致数据的不一致。如果需要线程安全，可以使用<code>ConcurrentHashMap</code>，<code>ConcurrentHashMap</code>的锁是分段加的；另外一种线程安全的Map结构是<code>HashTable</code>，它与<code>HashMap</code>类似，继承自Dictionary类，但是它不允许记录的键或者值为空，<code>HashTable</code>的线程安全是通过对整个数据结构上锁，，即任一时刻只有一个线程能写Hashtable，多线程情况下效率很低。</p>
<h3 id="hashcode与equals">HashCode与equals</h3>
<p><code>hashCode</code>是用来计算hash值的，hash值是用来确定hash表索引的。<br>
hash表中的一个索引处存放的是一张链表，所以还要通过<code>equals</code>方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry。put记录时，如果hash表中没定位到，就在链表前加一个Entry；如果定位到了，则更换Entry中的值，并返回旧的值。</p>
<h3 id="使用">使用</h3>
<p>一般情况下，我们用的最多的是<code>HashMap</code>，它里面存入的记录在取出的时候是随机的，它根据键的HashCode存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<p><code>LinkedHashMap</code>保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当<code>HashMap</code>容量很大，实际数据较少时，遍历起来可能会比<code>LinkedHashMap</code>慢，因为<code>LinkedHashMap</code>的遍历速度只和实际数据有关，和容量无关，而<code>HashMap</code>的遍历速度和他的容量有关。</p>
<p><code>LinkedHashMap</code> 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。</p>
<h2 id="treemap">TreeMap</h2>
<p><code>TreeMap</code>实现<code>SortMap</code>接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code> 遍历<code>TreeMap</code>时，得到的记录是排过序的。<br>
TreeSet集合排序有两种方式，Comparable和Comparator区别：</p>
<ul>
<li>让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</li>
<li>让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数，方式较为灵活。</li>
</ul>
<p><code>TreeMap</code>取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么<code>TreeMap</code>会更好。<code>TreeMap</code>更是多了一个排序的功能。</p>
<h3 id="comparator">Comparator</h3>
<p>由于TreeMap需要排序，所以需要一个Comparator为键值进行大小比较，当然也是用Comparator定位的。</p>
<ol>
<li>Comparator可以在创建TreeMap时指定；</li>
<li>如果创建时没有确定Comparator对象，那么就会使用key.compareTo()方法，这就要求key必须实现Comparable接口；</li>
<li>TreeMap是使用Tree数据结构实现的，所以使用Comparator接口就可以完成定位了。</li>
</ol>
<h2 id="相关set">相关Set</h2>
<p><code>HashSet</code>是通过<code>HashMap</code>实现的，<code>TreeSet</code>是通过<code>TreeMap</code>实现的。Java里的Set实现其实用的是Map的key。<br>
Map的key和Set都有一个共同的特性：集合的唯一性。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="http://blog.csdn.net/fg2006/article/details/6411200">HashMap,LinkedHashMap,TreeMap的区别</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript里的对象]]></title>
        <id>http://goroyal.github.io/post/js-object/</id>
        <link href="http://goroyal.github.io/post/js-object/">
        </link>
        <updated>2020-07-10T08:28:54.000Z</updated>
        <summary type="html"><![CDATA[<p>JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。<br>
对象时属性的容器，其中每个属性都是名字和值。<br>
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。</p>
]]></summary>
        <content type="html"><![CDATA[<p>JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。<br>
对象时属性的容器，其中每个属性都是名字和值。<br>
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。</p>
<!-- more -->
<p><strong>对象字面量</strong></p>
<pre><code class="language-javascript">var empty_object={};

var stoge={
  &quot;firstName&quot;:&quot;Joerome&quot;,
  &quot;lastName&quot;:&quot;Howare&quot;
};
</code></pre>
<p>上面的对象stoge中两个属性，如果他们不是JavaScript的保留字，可以去掉引号。<br>
检索对象里面属性的值可以用中括号去获取，如<code>stoge[&quot;firstName&quot;]</code>，如果该字符串表达式是一个字符串字面量，且是合法的JavaScript标识符不是保留字，那么也可以用点号“.”获取。如果试图获取一个不存在的属性，将得到undefined。</p>
<p>使用typeof操作符对确定属性的类型很有帮助：</p>
<pre><code class="language-javascript">typeof flight.number  // 'number'
</code></pre>
<p>注意，原型链中的任何属性都会产生值：</p>
<pre><code class="language-javascript">typeof flight.toString  // 'function'
typeof flight.constructor // 'function'
</code></pre>
<p>有两种方法处理这些不需要的属性：<br>
第一个是让程序做检查并丢弃值为函数的属性，一般来说，想让对象在运行时动态获取自身信息时，关注更多的是数据。<br>
另一个方法是使用hasOwnProperty方法，如果对象拥有独有的属性，将返回true，该方法不会检查原型链。</p>
<pre><code class="language-javascript">flight.hasOwnProperty('number') // true
</code></pre>
<p>for in 循环中遍历属性的顺序是不确定的，如果想要确保属性以特定的顺序出现，最好的办法是完全避免使用for in语句，而是创建一个数组，在其中以正确的顺序包含属性名，然后使用普通的for循环遍历。</p>
<p>delete可以删除对象中的属性，不会触及原型链中的任何对象，删除对象的属性可能会让原型链中的属性透现出来：</p>
<pre><code class="language-javascript">another.nickname  // 'Moe'

// 删除another的nickname属性，暴露出原型的nickname属性
delete another.nickname;

another.nickname  // 'Curly'
</code></pre>
<p>用Java里面的话理解，就是删除子类中的覆盖父类的属性以及get方法，那么下次再想获取该属性，将是从父类得到的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL不同的存储引擎]]></title>
        <id>http://goroyal.github.io/post/mysql-storage-engine/</id>
        <link href="http://goroyal.github.io/post/mysql-storage-engine/">
        </link>
        <updated>2020-07-10T08:25:32.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL由以下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲（Cache）组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p>
<p><strong>注意：存储引擎是基于表的，而不是数据库。</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL由以下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲（Cache）组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p>
<p><strong>注意：存储引擎是基于表的，而不是数据库。</strong></p>
<!-- more -->
<p>MySQL常用的插件式存储引擎主要包括MyISAM，InnoDB，NDB Cluster，Maria，Falcon，Memory，Archive，Merge，Federated等，其中最著名且使用最广泛的是MyISAM和InnoDB。MyISAM是MySQL的默认存储引擎，是MySQL最早的ISAM存储引擎的升级版本。</p>
<h2 id="myisam存储引擎">MyISAM存储引擎</h2>
<p>MyISAM是MySQL的默认存储引擎，它支持B-tree/FullText/R-tree索引类型。<br>
MyISAM的锁级别是表锁，表锁的开销小，加锁快；锁粒度大，发生锁冲突的概率较高，并发度低；表锁适合查询。MyISAM引擎不支持事务性，也不支持外键。</p>
<p>MyISAM对于一些OLAP（Online Analytical Processing，在线分析处理）操作速度快。除Windows版本外，是所有MySQL版本默认的存储引擎。</p>
<p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，当然你也可以通过myisampack来解压数据文件<br>
。<br>
在MySQL 5.0版本之前，MyISAM默认支持的表大小为4G，如果需要支持大于4G的MyISAM表时，则需要制定MAXROWS和 AVGROW_LENGTH属性。从MySQL 5.0版本开始，MyISAM默认支持256T的单表数据，这足够满足一般应用的需求。</p>
<p><strong>注意</strong>：对于MyISAM存储引擎表，MySQL数据库只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他使用LRU算法缓存数据 的大部分数据库大不相同。此外，在MySQL 5.1.23版本之前，无论是在32位还是64位操作系统环境下，缓存索引的缓冲区最大只能设置为4G。在之后的版本中，64位系统可以支持大于4G的索引缓冲区。</p>
<h2 id="innodb存储引擎">InnoDB存储引擎</h2>
<p>InnoDB存储引擎最大的亮点就是支持事务性，支持回滚。它支持Hash/B-tree索引类型。<br>
InnoDB的锁级别是行锁，行锁在锁定上带来的消耗大于表锁，但是在系统并发访问量较高时，InnoDB整体性能远高于MyISAM。InnoDB的索引不仅缓存索引本身，也缓存数据，所以InnoDB需要更大的内存。</p>
<p>InnoDB存储引擎支持事务，主要面向在线事务处理（OLTP）方面的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读取操作不会产生锁。MySQL在Windows版本下的InnoDB是默认的存储引擎，同时InnoDB默认地被包含在所有的MySQL二进制发布版本中。</p>
<p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB自身进行管理。从MySQL 4.1（包括4.1）版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。与Oracle类似，InnoDB存储引擎同样可以使用裸设备（row disk）来建立其表空间。</p>
<p>InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时使用一种被称为next-key locking 的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</p>
<p>对于表中数据的存储，InnoDB存储引擎采用了聚簇（clustered）的方式，这种方式类似于Oracle的索引聚集表（index organized table，IOT）。</p>
<p>每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的 ROWID，并以此作为主键。</p>
<h2 id="memory存储引擎">Memory存储引擎</h2>
<p>Memory存储引擎是一个内存级的存储引擎，它将所有数据都存储在内存中，所以它能够存储的数据量是比较小的。而因为内存的特性，Memory存储引擎对于数据的一致性支持教差。Memory的锁级别和MyISAM一样，是表锁；并且不支持事务性。</p>
<p>Memory存储引擎（之前称为HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。它默认使用哈希索引，而不是我们熟悉的B+树索引。</p>
<p>虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，其只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（这个问题之前已经提到，eBay的Igor Chernyshev工程师已经给出了Patch方案）。<br>
此外有一点常被忽视的是，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。</p>
<h2 id="ndb存储引擎">NDB存储引擎</h2>
<p>2003年，MySQL AB公司从Sony Ericsson公司收购了NDB 集群引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群；不过，与Oracle RAC share everything结构不同的是，其结构是share nothing的集群架构，因此能提供更高级别的高可用性。NDB的特点是数据全部放在内存中（从5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找（primary key lookup）的速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。</p>
<p>关于NDB存储引擎，有一个问题值得注意，那就是NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。</p>
<p><strong>注意</strong>：MySQL NDB Cluster存储引擎有社区版本和企业版本，并且NDB Cluster已作为Carrier Grade Edition单独下载版本而存在，可以通过[http://dev.mysql.com/ downloads/cluster/index.html](http://dev.mysql.com/ downloads/cluster/index.html)获得最新版本的NDB Cluster存储引擎。</p>
<h2 id="archive存储引擎">Archive存储引擎</h2>
<p>Archive存储引擎只支持INSERT和SELECT操作，MySQL 5.1开始支持索引。其使用zlib算法将数据行（row）进行压缩后存储，压缩比率一般可达1∶10。正如其名称所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是本身并不是事物安全的存储引擎，其设计目标主要是提供高速的插入 和压缩功能。</p>
<h2 id="federated存储引擎">Federated存储引擎</h2>
<p>Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。</p>
<h2 id="maria存储引擎">Maria存储引擎</h2>
<p>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎，开发者是MySQL 的创始人之一的Michael Widenius。因此，它可以看作是MyISAM的后续版本。其特点是：缓存数据和索引文件，行锁设计，提供MVCC功能，支持事务和非事务安全的选项 支持，以及更好的BLOB字符类型的处理性能。</p>
<h2 id="其他存储引擎">其他存储引擎</h2>
<p>除了上面提到的7种存储引擎外，还有很多其他的存储引擎，包括Merge、CSV、Sphinx和Infobright，它们都有各自适用的场合，这里不再一一做介绍了。了解了MySQL拥有这么多存储引擎后，现在我可以回答1.2节中提到的问题了。</p>
<p>为什么MySQL不支持全文索引？不！MySQL支持，MyISAM、Sphinx存储引擎支持全文索引。<br>
MySQL快是因为不支持事务吗？错！MySQL MyISAM存储引擎不支持事务，但是InnoDB支持。快是相对于不同应用来说的，对于ETL这种操作，MyISAM当然有其优势。<br>
当表的数据量大于1000W时，MySQL的性能会急剧下降吗？不！MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，如果 你选择了正确的存储引擎以及正确的配置，再大的数据量MySQL也是能承受的。如官方手册上提及的，Mytrix和Inc.在InnoDB上存储了超过 1TB的数据，还有一些其他网站使用InnoDB存储引擎处理平均每秒800次插入/更新的操作。</p>
<h2 id="myisam和innodb差别">MyISAM和InnoDB差别</h2>
<h3 id="构成差别">构成差别</h3>
<p>每个MyISAM在磁盘上存储成三个文件，文件的名字以表的名字开始，.frm文件存储表定义，.MYI(MYIndex)为索引文件，.MYD(MYData)为数据文件。</p>
<p>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
<h3 id="事务处理差别">事务处理差别</h3>
<p>MyISAM类型的表强调性能，执行速度比InnoDB快，但是不支持事务处理等高级功能。</p>
<p>InnoDB提供事务支持、外部键等高级数据库功能。</p>
<h3 id="crud操作">CRUD操作</h3>
<p>如果执行大量SELECT查询操作，MyISAM是最好的选择。</p>
<p>如果执行大量的UPDATE或者INSERT操作，出于性能方面考虑，应该使用InnoDB。<code>DELETE from table</code>时，InnoDB不会重新建立表，而是一行一行的删除。<br>
<code>LOAD TABLE FROM MASTER</code>操作对InnoDB不起作用，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。</p>
<h3 id="auto_increment操作">AUTO_INCREMENT操作</h3>
<p>MyISAM为INSERT和UPDATE操作自动更新这一列，这使得AUTO_INCREMENT列更快（10%+），在序列项的值删除后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。<br>
AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置。</p>
<p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但 是在MyISAM表中，可以和其他字段一起建立联合索引。<br>
如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。InnoDB自动增长计数器仅被存储在主内存中，而不是存在磁盘上。</p>
<h3 id="表的具体行数">表的具体行数</h3>
<p><code>select count(*) from table</code>，MyISAM只要简单的读出保存好的行数。注意的是，当count(*)语句包含 where 条件时，两种类型表的操作是一样的。</p>
<p>InnoDB 中不保存表的具体行数。也就是说，执行<code>select count(*) from table</code>时，InnoDB要扫描一遍整个表来计算有多少行。</p>
<h3 id="锁">锁</h3>
<p>MyISAM的锁是在表级别。其并发写的性能一直是一个让人比较头疼的问题。</p>
<p>InnoDB提供了行级别的锁(locking on row level)，提供与 Oracle类型一致的不加锁读取(non-locking read in SELECTs)。另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如<code>update table set num=1 where name like '%aaa%'</code>。</p>
<h3 id="索引">索引</h3>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引。</p>
<p>Innodb是索引和数据是存放在相同的文件，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。Innodb 的数据存放格式也比较独特,每个Innodb表 都会将主键以聚簇索引的形式创建。所有的数据都是以主键来作为升序排列在物理磁盘上面,所以主键 查询并且以主键排序的查询效率也会非常高。</p>
<h2 id="如何选择合适的引擎">如何选择合适的引擎</h2>
<h3 id="采用myisam引擎">采用MyISAM引擎</h3>
<p>R/W &gt; 100 ，并且Update较少 (R/W:读写比)<br>
并发不高，不需要支持事务<br>
表数据量小<br>
需要进行全文搜索</p>
<h3 id="采用innodb引擎">采用InnoDB引擎</h3>
<p>R/W比较小，频繁更新大字段<br>
表数据量超过千万，高并发<br>
安全性和可用性要求高</p>
<h3 id="采用memory引擎">采用Memory引擎</h3>
<p>有足够的内存<br>
对数据一致性要求不高，如session/在线人数等<br>
需要定期归档的数据</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.ha97.com/4197.html">MySQL存储引擎MyISAM与InnoDB的主要区别对比</a></li>
<li><a href="http://imysql.com/2015/07/23/something-important-about-mysql-design-reference.shtml">老叶观点：MySQL开发规范之我见</a></li>
<li><a href="http://simpleframework.net/news/view?newsId=63cd772590e8495bbff4d713e092f772">《MySQL技术内幕:InnoDB存储引擎》-- 第1章 MySQL体系结构和存储引擎</a></li>
</ul>
]]></content>
    </entry>
</feed>