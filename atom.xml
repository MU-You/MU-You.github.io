<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://goroyal.github.io</id>
    <title>Goroyal&apos;s blog</title>
    <updated>2020-07-20T12:00:20.184Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://goroyal.github.io"/>
    <link rel="self" href="http://goroyal.github.io/atom.xml"/>
    <subtitle>学习分享</subtitle>
    <logo>http://goroyal.github.io/images/avatar.png</logo>
    <icon>http://goroyal.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Goroyal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Java包装类的比较]]></title>
        <id>http://goroyal.github.io/post/java-baozhuang-class/</id>
        <link href="http://goroyal.github.io/post/java-baozhuang-class/">
        </link>
        <updated>2020-07-20T11:56:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="boolean">Boolean</h2>
<p><code>Boolean</code>内部维护了两个常量：</p>
<pre><code class="language-Java">public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
</code></pre>
<p>所以对于<code>Boolean a = true; Boolean b = true;</code>，<code>a == b</code>是得到true的。</p>
<h2 id="integer">Integer</h2>
<p><code>Integer</code>对一段范围内的数字有个缓存：IntegerCache.low ~ IntegerCache.high<br>
如果数字在这个范围内，两个integer <code>==</code>是返回true的；否则就会new一个对象返回，肯定是不相等的。<br>
<code>IntegerCache</code>的low是固定死的-128，high默认127，可以通过这个配置修改<code>-XX:AutoBoxCacheMax</code>。</p>
<h2 id="short-long">Short、Long</h2>
<p>和Integer差不多，但是它们的high是固定的127。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/aCoder2013/blog/issues/14">Java原生类型包装类初解析</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的线程]]></title>
        <id>http://goroyal.github.io/post/java-thread/</id>
        <link href="http://goroyal.github.io/post/java-thread/">
        </link>
        <updated>2020-07-20T11:00:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程状态">线程状态</h2>
<ol>
<li>新建：创建后尚未启动的线程处于这种状态</li>
<li>运行：运行状态包括操作系统中的运行态和就绪态，也就是说这个状态下的线程可能正在执行，也有可能在等待CPU为它分配执行时间；</li>
<li>无限期等待：处于这种状态的线程不会被分配CPU，它们要被其它进程显式唤醒。可能进入这种状态的操作有：
<ul>
<li>没有设置时间参数的wait和join方法；</li>
<li>LockSupport.park()方法；</li>
</ul>
</li>
<li>限期等待：处于这种状态的线程也不会被分配执行时间，不过不需要其它线程唤醒，等一段时间之后就会由系统自动唤醒。可能进入这种状态的有：
<ul>
<li>设置了时间参数的wait和join方法；</li>
<li>sleep方法；</li>
<li>LockSupport.parkNanos()方法、LockSupport.parkUntil()方法；</li>
</ul>
</li>
<li>阻塞状态：线程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获得一个排它锁。而等待状态则是在等待一段时间，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。</li>
<li>结束：已终止线程的线程状态，线程已经结束执行。</li>
</ol>
<h2 id="线程安全">线程安全</h2>
<p>当多个线程访问一个对象的时候，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】Java里的各种Map]]></title>
        <id>http://goroyal.github.io/post/java-map/</id>
        <link href="http://goroyal.github.io/post/java-map/">
        </link>
        <updated>2020-07-10T08:34:59.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Map</code>就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。</p>
<p>Java里面基于对Map的不同访问需求创建了它的不同实现类：</p>
<ul>
<li>对键的顺序没有要求</li>
<li>取出键的顺序按照插入记录时的顺序</li>
<li>取出键的顺序按照键的升序排序</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p><code>Map</code>就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。</p>
<p>Java里面基于对Map的不同访问需求创建了它的不同实现类：</p>
<ul>
<li>对键的顺序没有要求</li>
<li>取出键的顺序按照插入记录时的顺序</li>
<li>取出键的顺序按照键的升序排序</li>
</ul>
<!-- more -->
<h2 id="hashmap">HashMap</h2>
<p><code>Hashmap</code> 是一个最常用的Map，它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。</p>
<h3 id="空键问题">空键问题</h3>
<p><code>HashMap</code>最多只允许一条记录的键为Null，允许多条记录的值为 Null。</p>
<h3 id="线程安全问题">线程安全问题</h3>
<p><code>HashMap</code>的访问没有锁，即任一时刻可以有多个线程同时写HashMap，对它的访问是线程不安全的，可能会导致数据的不一致。如果需要线程安全，可以使用<code>ConcurrentHashMap</code>，<code>ConcurrentHashMap</code>的锁是分段加的；另外一种线程安全的Map结构是<code>HashTable</code>，它与<code>HashMap</code>类似，继承自Dictionary类，但是它不允许记录的键或者值为空，<code>HashTable</code>的线程安全是通过对整个数据结构上锁，，即任一时刻只有一个线程能写Hashtable，多线程情况下效率很低。</p>
<h3 id="hashcode与equals">HashCode与equals</h3>
<p><code>hashCode</code>是用来计算hash值的，hash值是用来确定hash表索引的。<br>
hash表中的一个索引处存放的是一张链表，所以还要通过<code>equals</code>方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry。put记录时，如果hash表中没定位到，就在链表前加一个Entry；如果定位到了，则更换Entry中的值，并返回旧的值。</p>
<h3 id="使用">使用</h3>
<p>一般情况下，我们用的最多的是<code>HashMap</code>，它里面存入的记录在取出的时候是随机的，它根据键的HashCode存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<p><code>LinkedHashMap</code>保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当<code>HashMap</code>容量很大，实际数据较少时，遍历起来可能会比<code>LinkedHashMap</code>慢，因为<code>LinkedHashMap</code>的遍历速度只和实际数据有关，和容量无关，而<code>HashMap</code>的遍历速度和他的容量有关。</p>
<p><code>LinkedHashMap</code> 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。</p>
<h2 id="treemap">TreeMap</h2>
<p><code>TreeMap</code>实现<code>SortMap</code>接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code> 遍历<code>TreeMap</code>时，得到的记录是排过序的。<br>
TreeSet集合排序有两种方式，Comparable和Comparator区别：</p>
<ul>
<li>让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</li>
<li>让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数，方式较为灵活。</li>
</ul>
<p><code>TreeMap</code>取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么<code>TreeMap</code>会更好。<code>TreeMap</code>更是多了一个排序的功能。</p>
<h3 id="comparator">Comparator</h3>
<p>由于TreeMap需要排序，所以需要一个Comparator为键值进行大小比较，当然也是用Comparator定位的。</p>
<ol>
<li>Comparator可以在创建TreeMap时指定；</li>
<li>如果创建时没有确定Comparator对象，那么就会使用key.compareTo()方法，这就要求key必须实现Comparable接口；</li>
<li>TreeMap是使用Tree数据结构实现的，所以使用Comparator接口就可以完成定位了。</li>
</ol>
<h2 id="相关set">相关Set</h2>
<p><code>HashSet</code>是通过<code>HashMap</code>实现的，<code>TreeSet</code>是通过<code>TreeMap</code>实现的。Java里的Set实现其实用的是Map的key。<br>
Map的key和Set都有一个共同的特性：集合的唯一性。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="http://blog.csdn.net/fg2006/article/details/6411200">HashMap,LinkedHashMap,TreeMap的区别</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript里的对象]]></title>
        <id>http://goroyal.github.io/post/js-object/</id>
        <link href="http://goroyal.github.io/post/js-object/">
        </link>
        <updated>2020-07-10T08:28:54.000Z</updated>
        <summary type="html"><![CDATA[<p>JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。<br>
对象时属性的容器，其中每个属性都是名字和值。<br>
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。</p>
]]></summary>
        <content type="html"><![CDATA[<p>JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。<br>
对象时属性的容器，其中每个属性都是名字和值。<br>
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。</p>
<!-- more -->
<p><strong>对象字面量</strong></p>
<pre><code class="language-javascript">var empty_object={};

var stoge={
  &quot;firstName&quot;:&quot;Joerome&quot;,
  &quot;lastName&quot;:&quot;Howare&quot;
};
</code></pre>
<p>上面的对象stoge中两个属性，如果他们不是JavaScript的保留字，可以去掉引号。<br>
检索对象里面属性的值可以用中括号去获取，如<code>stoge[&quot;firstName&quot;]</code>，如果该字符串表达式是一个字符串字面量，且是合法的JavaScript标识符不是保留字，那么也可以用点号“.”获取。如果试图获取一个不存在的属性，将得到undefined。</p>
<p>使用typeof操作符对确定属性的类型很有帮助：</p>
<pre><code class="language-javascript">typeof flight.number  // 'number'
</code></pre>
<p>注意，原型链中的任何属性都会产生值：</p>
<pre><code class="language-javascript">typeof flight.toString  // 'function'
typeof flight.constructor // 'function'
</code></pre>
<p>有两种方法处理这些不需要的属性：<br>
第一个是让程序做检查并丢弃值为函数的属性，一般来说，想让对象在运行时动态获取自身信息时，关注更多的是数据。<br>
另一个方法是使用hasOwnProperty方法，如果对象拥有独有的属性，将返回true，该方法不会检查原型链。</p>
<pre><code class="language-javascript">flight.hasOwnProperty('number') // true
</code></pre>
<p>for in 循环中遍历属性的顺序是不确定的，如果想要确保属性以特定的顺序出现，最好的办法是完全避免使用for in语句，而是创建一个数组，在其中以正确的顺序包含属性名，然后使用普通的for循环遍历。</p>
<p>delete可以删除对象中的属性，不会触及原型链中的任何对象，删除对象的属性可能会让原型链中的属性透现出来：</p>
<pre><code class="language-javascript">another.nickname  // 'Moe'

// 删除another的nickname属性，暴露出原型的nickname属性
delete another.nickname;

another.nickname  // 'Curly'
</code></pre>
<p>用Java里面的话理解，就是删除子类中的覆盖父类的属性以及get方法，那么下次再想获取该属性，将是从父类得到的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL不同的存储引擎]]></title>
        <id>http://goroyal.github.io/post/mysql-storage-engine/</id>
        <link href="http://goroyal.github.io/post/mysql-storage-engine/">
        </link>
        <updated>2020-07-10T08:25:32.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL由以下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲（Cache）组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p>
<p><strong>注意：存储引擎是基于表的，而不是数据库。</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL由以下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲（Cache）组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p>
<p><strong>注意：存储引擎是基于表的，而不是数据库。</strong></p>
<!-- more -->
<p>MySQL常用的插件式存储引擎主要包括MyISAM，InnoDB，NDB Cluster，Maria，Falcon，Memory，Archive，Merge，Federated等，其中最著名且使用最广泛的是MyISAM和InnoDB。MyISAM是MySQL的默认存储引擎，是MySQL最早的ISAM存储引擎的升级版本。</p>
<h2 id="myisam存储引擎">MyISAM存储引擎</h2>
<p>MyISAM是MySQL的默认存储引擎，它支持B-tree/FullText/R-tree索引类型。<br>
MyISAM的锁级别是表锁，表锁的开销小，加锁快；锁粒度大，发生锁冲突的概率较高，并发度低；表锁适合查询。MyISAM引擎不支持事务性，也不支持外键。</p>
<p>MyISAM对于一些OLAP（Online Analytical Processing，在线分析处理）操作速度快。除Windows版本外，是所有MySQL版本默认的存储引擎。</p>
<p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，当然你也可以通过myisampack来解压数据文件<br>
。<br>
在MySQL 5.0版本之前，MyISAM默认支持的表大小为4G，如果需要支持大于4G的MyISAM表时，则需要制定MAXROWS和 AVGROW_LENGTH属性。从MySQL 5.0版本开始，MyISAM默认支持256T的单表数据，这足够满足一般应用的需求。</p>
<p><strong>注意</strong>：对于MyISAM存储引擎表，MySQL数据库只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他使用LRU算法缓存数据 的大部分数据库大不相同。此外，在MySQL 5.1.23版本之前，无论是在32位还是64位操作系统环境下，缓存索引的缓冲区最大只能设置为4G。在之后的版本中，64位系统可以支持大于4G的索引缓冲区。</p>
<h2 id="innodb存储引擎">InnoDB存储引擎</h2>
<p>InnoDB存储引擎最大的亮点就是支持事务性，支持回滚。它支持Hash/B-tree索引类型。<br>
InnoDB的锁级别是行锁，行锁在锁定上带来的消耗大于表锁，但是在系统并发访问量较高时，InnoDB整体性能远高于MyISAM。InnoDB的索引不仅缓存索引本身，也缓存数据，所以InnoDB需要更大的内存。</p>
<p>InnoDB存储引擎支持事务，主要面向在线事务处理（OLTP）方面的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读取操作不会产生锁。MySQL在Windows版本下的InnoDB是默认的存储引擎，同时InnoDB默认地被包含在所有的MySQL二进制发布版本中。</p>
<p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB自身进行管理。从MySQL 4.1（包括4.1）版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。与Oracle类似，InnoDB存储引擎同样可以使用裸设备（row disk）来建立其表空间。</p>
<p>InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时使用一种被称为next-key locking 的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</p>
<p>对于表中数据的存储，InnoDB存储引擎采用了聚簇（clustered）的方式，这种方式类似于Oracle的索引聚集表（index organized table，IOT）。</p>
<p>每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的 ROWID，并以此作为主键。</p>
<h2 id="memory存储引擎">Memory存储引擎</h2>
<p>Memory存储引擎是一个内存级的存储引擎，它将所有数据都存储在内存中，所以它能够存储的数据量是比较小的。而因为内存的特性，Memory存储引擎对于数据的一致性支持教差。Memory的锁级别和MyISAM一样，是表锁；并且不支持事务性。</p>
<p>Memory存储引擎（之前称为HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。它默认使用哈希索引，而不是我们熟悉的B+树索引。</p>
<p>虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，其只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（这个问题之前已经提到，eBay的Igor Chernyshev工程师已经给出了Patch方案）。<br>
此外有一点常被忽视的是，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。</p>
<h2 id="ndb存储引擎">NDB存储引擎</h2>
<p>2003年，MySQL AB公司从Sony Ericsson公司收购了NDB 集群引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群；不过，与Oracle RAC share everything结构不同的是，其结构是share nothing的集群架构，因此能提供更高级别的高可用性。NDB的特点是数据全部放在内存中（从5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找（primary key lookup）的速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。</p>
<p>关于NDB存储引擎，有一个问题值得注意，那就是NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。</p>
<p><strong>注意</strong>：MySQL NDB Cluster存储引擎有社区版本和企业版本，并且NDB Cluster已作为Carrier Grade Edition单独下载版本而存在，可以通过[http://dev.mysql.com/ downloads/cluster/index.html](http://dev.mysql.com/ downloads/cluster/index.html)获得最新版本的NDB Cluster存储引擎。</p>
<h2 id="archive存储引擎">Archive存储引擎</h2>
<p>Archive存储引擎只支持INSERT和SELECT操作，MySQL 5.1开始支持索引。其使用zlib算法将数据行（row）进行压缩后存储，压缩比率一般可达1∶10。正如其名称所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是本身并不是事物安全的存储引擎，其设计目标主要是提供高速的插入 和压缩功能。</p>
<h2 id="federated存储引擎">Federated存储引擎</h2>
<p>Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。</p>
<h2 id="maria存储引擎">Maria存储引擎</h2>
<p>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎，开发者是MySQL 的创始人之一的Michael Widenius。因此，它可以看作是MyISAM的后续版本。其特点是：缓存数据和索引文件，行锁设计，提供MVCC功能，支持事务和非事务安全的选项 支持，以及更好的BLOB字符类型的处理性能。</p>
<h2 id="其他存储引擎">其他存储引擎</h2>
<p>除了上面提到的7种存储引擎外，还有很多其他的存储引擎，包括Merge、CSV、Sphinx和Infobright，它们都有各自适用的场合，这里不再一一做介绍了。了解了MySQL拥有这么多存储引擎后，现在我可以回答1.2节中提到的问题了。</p>
<p>为什么MySQL不支持全文索引？不！MySQL支持，MyISAM、Sphinx存储引擎支持全文索引。<br>
MySQL快是因为不支持事务吗？错！MySQL MyISAM存储引擎不支持事务，但是InnoDB支持。快是相对于不同应用来说的，对于ETL这种操作，MyISAM当然有其优势。<br>
当表的数据量大于1000W时，MySQL的性能会急剧下降吗？不！MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，如果 你选择了正确的存储引擎以及正确的配置，再大的数据量MySQL也是能承受的。如官方手册上提及的，Mytrix和Inc.在InnoDB上存储了超过 1TB的数据，还有一些其他网站使用InnoDB存储引擎处理平均每秒800次插入/更新的操作。</p>
<h2 id="myisam和innodb差别">MyISAM和InnoDB差别</h2>
<h3 id="构成差别">构成差别</h3>
<p>每个MyISAM在磁盘上存储成三个文件，文件的名字以表的名字开始，.frm文件存储表定义，.MYI(MYIndex)为索引文件，.MYD(MYData)为数据文件。</p>
<p>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
<h3 id="事务处理差别">事务处理差别</h3>
<p>MyISAM类型的表强调性能，执行速度比InnoDB快，但是不支持事务处理等高级功能。</p>
<p>InnoDB提供事务支持、外部键等高级数据库功能。</p>
<h3 id="crud操作">CRUD操作</h3>
<p>如果执行大量SELECT查询操作，MyISAM是最好的选择。</p>
<p>如果执行大量的UPDATE或者INSERT操作，出于性能方面考虑，应该使用InnoDB。<code>DELETE from table</code>时，InnoDB不会重新建立表，而是一行一行的删除。<br>
<code>LOAD TABLE FROM MASTER</code>操作对InnoDB不起作用，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。</p>
<h3 id="auto_increment操作">AUTO_INCREMENT操作</h3>
<p>MyISAM为INSERT和UPDATE操作自动更新这一列，这使得AUTO_INCREMENT列更快（10%+），在序列项的值删除后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。<br>
AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置。</p>
<p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但 是在MyISAM表中，可以和其他字段一起建立联合索引。<br>
如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。InnoDB自动增长计数器仅被存储在主内存中，而不是存在磁盘上。</p>
<h3 id="表的具体行数">表的具体行数</h3>
<p><code>select count(*) from table</code>，MyISAM只要简单的读出保存好的行数。注意的是，当count(*)语句包含 where 条件时，两种类型表的操作是一样的。</p>
<p>InnoDB 中不保存表的具体行数。也就是说，执行<code>select count(*) from table</code>时，InnoDB要扫描一遍整个表来计算有多少行。</p>
<h3 id="锁">锁</h3>
<p>MyISAM的锁是在表级别。其并发写的性能一直是一个让人比较头疼的问题。</p>
<p>InnoDB提供了行级别的锁(locking on row level)，提供与 Oracle类型一致的不加锁读取(non-locking read in SELECTs)。另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如<code>update table set num=1 where name like '%aaa%'</code>。</p>
<h3 id="索引">索引</h3>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引。</p>
<p>Innodb是索引和数据是存放在相同的文件，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。Innodb 的数据存放格式也比较独特,每个Innodb表 都会将主键以聚簇索引的形式创建。所有的数据都是以主键来作为升序排列在物理磁盘上面,所以主键 查询并且以主键排序的查询效率也会非常高。</p>
<h2 id="如何选择合适的引擎">如何选择合适的引擎</h2>
<h3 id="采用myisam引擎">采用MyISAM引擎</h3>
<p>R/W &gt; 100 ，并且Update较少 (R/W:读写比)<br>
并发不高，不需要支持事务<br>
表数据量小<br>
需要进行全文搜索</p>
<h3 id="采用innodb引擎">采用InnoDB引擎</h3>
<p>R/W比较小，频繁更新大字段<br>
表数据量超过千万，高并发<br>
安全性和可用性要求高</p>
<h3 id="采用memory引擎">采用Memory引擎</h3>
<p>有足够的内存<br>
对数据一致性要求不高，如session/在线人数等<br>
需要定期归档的数据</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.ha97.com/4197.html">MySQL存储引擎MyISAM与InnoDB的主要区别对比</a></li>
<li><a href="http://imysql.com/2015/07/23/something-important-about-mysql-design-reference.shtml">老叶观点：MySQL开发规范之我见</a></li>
<li><a href="http://simpleframework.net/news/view?newsId=63cd772590e8495bbff4d713e092f772">《MySQL技术内幕:InnoDB存储引擎》-- 第1章 MySQL体系结构和存储引擎</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】数组和链表]]></title>
        <id>http://goroyal.github.io/post/array-and-linkedlist/</id>
        <link href="http://goroyal.github.io/post/array-and-linkedlist/">
        </link>
        <updated>2020-07-10T07:55:54.000Z</updated>
        <summary type="html"><![CDATA[<p>在计算机程序里，数据存储的方式无外乎两种：顺序存储和链式存储。顺序存储的结构可以称为顺序表，也可以用数组描述，链式存储的结构可以称为链表。<br>
我们每一个学过数据结构的都知道，它们两者各自有一些鲜明的特性，比如：</p>
<ul>
<li>我们可以通过数组下标去访问数组里的元素，查询、更新的效率高，时间复杂度是O(1)，但是在中间某个位置插入或删除一个元素就要挪动后面所有的元素，时间复杂度是O(n)。</li>
<li>链表里元素之间存在指针指向关联的另一个元素，我们只能通过指针挨个去遍历访问链表里的元素，查询、更新的效率低，时间复杂度是O(n)，在中间某个位置插入或删除一个元素比较方便，只需要修改相邻指针的引用就可以了，时间复杂度是O(1)。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>在计算机程序里，数据存储的方式无外乎两种：顺序存储和链式存储。顺序存储的结构可以称为顺序表，也可以用数组描述，链式存储的结构可以称为链表。<br>
我们每一个学过数据结构的都知道，它们两者各自有一些鲜明的特性，比如：</p>
<ul>
<li>我们可以通过数组下标去访问数组里的元素，查询、更新的效率高，时间复杂度是O(1)，但是在中间某个位置插入或删除一个元素就要挪动后面所有的元素，时间复杂度是O(n)。</li>
<li>链表里元素之间存在指针指向关联的另一个元素，我们只能通过指针挨个去遍历访问链表里的元素，查询、更新的效率低，时间复杂度是O(n)，在中间某个位置插入或删除一个元素比较方便，只需要修改相邻指针的引用就可以了，时间复杂度是O(1)。</li>
</ul>
<!-- more -->
<h2 id="数组">数组</h2>
<p>数组的好处显而易见，它的存储结构比较紧凑，相对节省空间。每个元素都有唯一的索引，支持随机访问。但是数组所需要的空间需要一次分配够，当数组容量满时，新加入元素就要对数组进行扩容。扩容时，往往不能在原地直接扩，因为后面的内存可能已经分配给其他数据结构了，所以要重新申请一块新的更大的内存空间，将原有的数组里的元素全部复制到新的数组里，再释放原有数组的空间，这个过程时间复杂度是O(n)，可以参考Java的<code>ArrayList</code>。如果不加以合理的维护，内存中将产生大量碎片。</p>
<h2 id="链表">链表</h2>
<p>链表有效地解决里数组需要扩容的问题，因为链表里的每个元素节点都不需要连续，链表的节点通过指针进行索引，每个节点只能找到它指针指向的下一个节点。正常的单向链表是从头节点开始，每个节点依次有一个指针指向它后面的节点，尾部节点指向NULL。有时候为了方便拿到前驱节点，我们会采用双向链表，也就是每个节点既包含一个指针指向后面的，也包含一个指针指向前面的。还有一种链表是循环链表，也就是说尾节点指向了头节点。</p>
<h3 id="dummy-node">Dummy Node</h3>
<p>翻译为哑节点或者假人头节点。</p>
<p>Dummy node 是一个虚拟节点，也可以认为是标杆节点。Dummy node 就是在链表表头 head 前加一个节点指向 head，即dummy -&gt; head。Dummy node 的使用多针对单链表没有前向指针的问题，保证链表的 head 不会在删除操作中丢失。还有一种用法比较少见，就是使用 dummy node 来进行head的删除操作。所以，当链表的 head 有可能变化（被修改或者被删除）时，使用 dummy node 可以很好的简化代码，最终返回<code>dummy.next</code>即新的链表。</p>
<h3 id="快慢指针">快慢指针</h3>
<p>快慢指针指的是2个指针沿着链表向前移动的步数不一样，比如一个每次移2步，另一个每次移1步。可以通过它找到链表中间的节点以及判断链表是否循环。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 中的 2> /dev/null]]></title>
        <id>http://goroyal.github.io/post/linux-redirect-dev-null/</id>
        <link href="http://goroyal.github.io/post/linux-redirect-dev-null/">
        </link>
        <updated>2020-05-21T15:12:33.000Z</updated>
        <summary type="html"><![CDATA[<p>本文亦发布于<a href="https://thinkbucket.cn/blog/2020/05/21/linux-redirect-dev-null">ThinkBucket</a>。<br>
在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：</p>
<pre><code class="language-shell">2&gt; /dev/null
</code></pre>
<p>这是何意？</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文亦发布于<a href="https://thinkbucket.cn/blog/2020/05/21/linux-redirect-dev-null">ThinkBucket</a>。<br>
在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：</p>
<pre><code class="language-shell">2&gt; /dev/null
</code></pre>
<p>这是何意？</p>
 <!-- more --> 
<h2 id="linux-进程">Linux 进程</h2>
<p>以 bash 为例，shell 中执行一个命令时，其实是由 bash shell fork 出一个子进程，然后在这个子进程中运行相应的命令，直至退出。Linux 里的进程的数据结构如下：</p>
<pre><code class="language-C">struct task_struct {
	// 进程状态
	long state;
	// 虚拟内存结构体
	struct mm_struct *mm;
	// 进程号
	pid_t pid;
	// 指向父进程的指针
	struct task_struct __rcu *parent;
	// 子进程列表
	struct list_head children;
	// 存放文件系统信息的指针
	struct fs_struct *fs;
	// 一个数组，包含该进程打开的文件指针
	struct files_struct *files;
};
</code></pre>
<p><code>task_struct</code> 就是 Linux 对于一个进程的描述，也可以称之为进程描述符。其中的 <code>files</code> 指针指向一个数组，表示当前进程打开的所有文件。</p>
<p><strong>每个进程被创建时，<code>files</code> 指向的数组前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。</strong></p>
<p><strong>提示：</strong></p>
<blockquote>
<p>Linux 中的所有设备都是抽象成文件的，设备可以当作文件一样读和写。</p>
</blockquote>
<p>上述所说的文件描述符如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>文件描述符</th>
<th>默认情况</th>
<th>对应文件句柄位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输入（standard input）</td>
<td>0</td>
<td>从键盘获得输入</td>
<td>/proc/slef/fd/0</td>
</tr>
<tr>
<td>标准输出（standard output）</td>
<td>1</td>
<td>输出到屏幕（即控制台）</td>
<td>/proc/slef/fd/1</td>
</tr>
<tr>
<td>错误输出（error output）</td>
<td>2</td>
<td>输出到屏幕（即控制台）</td>
<td>/proc/slef/fd/2</td>
</tr>
</tbody>
</table>
<h2 id="重定向">重定向</h2>
<p>Linux shell 里通过 <code>&gt;</code>、<code>&lt;</code>进行输出、输入的重定向。</p>
<ul>
<li><code>&gt;</code>：将 shell 命令的输出指向某个地方，可以是文件，也可以是内存里的某个变量。比如 <code>ls -l &gt; file.txt</code> 就是把当前路径下的文件信息保存到 file.txt 文本中，如果没有这个重定向，它会将结果输出到显示器屏幕上。</li>
<li><code>&lt;</code>：从某个地方读取内容作为 shell 命令的输入，可以是文件，也可以是内存里的某个变量。比如 <code>{command} &lt; file.txt</code>，如果没有这个重定向，它会从键盘读取输入。</li>
</ul>
<p>当使用<code>&gt;</code>进行输出重定向时，默认是把某个命令的标准输出进行重定向。</p>
<pre><code class="language-shell"># 把标准输出重定向到新文件中
command &gt;filename

# 把标准输出重定向到新文件中
command 1&gt;filename

# 把标准错误重定向到新文件中
command 2&gt;filename
</code></pre>
<p>当使用<code>&lt;</code>进行输入重定向时，默认时把它右边的内容作为标准输入。</p>
<pre><code class="language-shell"># 以filename文件作为标准输入
command &lt;filename

# 以filename文件作为标准输入
command 0&lt;filename

# 从标准输入中读入，直到遇到delimiter分隔符
command &lt;&lt;delimiter
</code></pre>
<h3 id="管道">管道</h3>
<p>shell 还可以通过 <code>|</code> 这样的管道将前一个命令的输出作为下一个命令的输入，比如：</p>
<pre><code class="language-shell"># 在命令历史中找到包含 ssh 字符串的命令
history | grep ssh
</code></pre>
<h2 id="2-devnull">2&gt; /dev/null</h2>
<p>通过上面的章节可以知道，<code>2</code> 表示标准错误，<code>&gt;</code> 表示将标准错误重定向到某个地方。</p>
<p><code>/dev/null</code> 是一个特殊文件，在Unix系统中称为 null 设备。 通俗地说，它也称为比特桶（bit bucket，也译作比特垃圾桶）或黑洞（blackhole），因为它会立即丢弃写入其中的任何内容，并且在读取时仅返回文件结束EOF。</p>
<p>所以这个命令合起来就是将忽略执行命令产生的错误。比如：</p>
<pre><code class="language-shell"># 删除当前路径下的folder目录，如果不存在则忽略错误
rm -r folder 2&gt; /dev/null
</code></pre>
<p><strong>注意：</strong></p>
<blockquote>
<p><code>2</code>和<code>&gt;</code>之间不能有空格</p>
</blockquote>
<h3 id="更多用法">更多用法</h3>
<p><code>2&gt;&amp;1</code>：将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。这种写法的好处是可以避免同样的输出文件的描述符不用打开两次，标准输出和错误输出也不会抢占性往文件输出内容。<br>
<code>&gt; /dev/null</code>：将标准输出1重定向到<code>/dev/null</code>中。<br>
<code>&gt; /dev/null 2&gt;&amp;1</code>：就是让标准输出和错误输出重定向到<code>/dev/null</code>中（就是所有输出都丢弃了）。错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了<code>/dev/null</code>中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。<br>
<code>2&gt;&amp;1 &gt;/dev/null</code>：标准输出丢弃，错误输出显示在屏幕上。</p>
<p>我们会用<code>nohup</code>命令在后台启动Java程序，为了不让一些执行信息输出到控制台，会用如下命令丢弃输出：</p>
<pre><code class="language-shell">nohup java -jar xxxx.jar &gt;/dev/null 2&gt;&amp;1 &amp;
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://bash.cyberciti.biz/guide/What_is_a_Process%3F">What is a Process?</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">Linux的进程、线程、文件描述符是什么</a></li>
<li><a href="https://zh.wikipedia.org/wiki//dev/null">维基百科：/dev/null</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象编程与纯函数]]></title>
        <id>http://goroyal.github.io/post/oop-and-pure-function/</id>
        <link href="http://goroyal.github.io/post/oop-and-pure-function/">
        </link>
        <updated>2019-06-26T16:51:40.000Z</updated>
        <summary type="html"><![CDATA[<p>在面向对象编程里面，我们常常对现实世界建模抽象成一个个类，然后创建它们的对象，通过对象的方法行为去描述逻辑。</p>
<p>纯函数是一种特殊的函数，给它相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在面向对象编程里面，我们常常对现实世界建模抽象成一个个类，然后创建它们的对象，通过对象的方法行为去描述逻辑。</p>
<p>纯函数是一种特殊的函数，给它相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>
<!-- more -->
<p>占位符，待更。</p>
<p>https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1<br>
https://www.jiqizhixin.com/articles/2018-10-22-15</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Shell里管理多个Java版本]]></title>
        <id>http://goroyal.github.io/post/manage-multiple-java-versions/</id>
        <link href="http://goroyal.github.io/post/manage-multiple-java-versions/">
        </link>
        <updated>2019-06-26T16:30:26.000Z</updated>
        <summary type="html"><![CDATA[<p>自从Oracle宣布Java开始收费之后，越来越多的人会考虑从[Open JDK][1]下载安装Java环境。可能自己机器上也会同时并存好几个Java版本，本文以macOS为例介绍一下如何从Open JDK安装并进行管理多版本。</p>
]]></summary>
        <content type="html"><![CDATA[<p>自从Oracle宣布Java开始收费之后，越来越多的人会考虑从[Open JDK][1]下载安装Java环境。可能自己机器上也会同时并存好几个Java版本，本文以macOS为例介绍一下如何从Open JDK安装并进行管理多版本。</p>
<!-- more -->
<h2 id="下载安装">下载安装</h2>
<pre><code class="language-shell">curl -O https://download.java.net/java/GA/jdk12/33/GPL/openjdk-12_osx-x64_bin.tar.gz 
tar xvf openjdk-12_osx-x64_bin.tar.gz

# 解压后文件夹比如名为jdk-12.jdk，移动到macOS管理的JVM目录中去
sudo mv jdk-12.jdk /Library/Java/JavaVirtualMachines
</code></pre>
<p>此时，可以输入如下命令查看本机上有几种Java版本：</p>
<pre><code class="language-shell">/usr/libexec/java_home -V
</code></pre>
<p>比如生成如下内容：</p>
<pre><code>Matching Java Virtual Machines (2):
    12, x86_64:	&quot;OpenJDK 12&quot;	/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home
    1.7.0_76, x86_64:	&quot;Java SE 7&quot;	/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home
</code></pre>
<p>也可以输入小写v参数查看具体的版本信息，比如查刚刚下载的Java 12：</p>
<pre><code class="language-shell">/usr/libexec/java_home -v 12
</code></pre>
<p>会显示<code>/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home</code>，这个就是它的Java Home。那么就能通过export设置当前的JAVA_HOME环境变量了。比如：</p>
<pre><code>export JAVA_HOME=`/usr/libexec/java_home -v 12`
</code></pre>
<h2 id="便捷管理多版本">便捷管理多版本</h2>
<p>Linux或者macOS都有bash或者其他shell，以bash为例，bash在每个用户目录下都有<code>.bashrc</code>文件用于配置用户相关的环境变量（如果没有可以自己创建），可以在该文件下面写如下代码：</p>
<pre><code class="language-shell"># type 'java7' at command prompt to switch to java 7
function java7() {
    export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
    echo &quot;JAVA_HOME is $JAVA_HOME&quot;
    java -version
}

# type 'java12' at command prompt to switch to java 12
function java12() {
    export JAVA_HOME=`/usr/libexec/java_home -v 12`
    echo &quot;JAVA_HOME is $JAVA_HOME&quot;
    java -version
}
</code></pre>
<p>保存之后，输入命令<code>source .bashrc</code>，然后可以通过命令<code>java12</code>或者<code>java7</code>来便捷切换所使用的Java版本。</p>
<p>[1]:</p>
<!-- more -->
<p>https://openjdk.java.net/install/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try with closable resources]]></title>
        <id>http://goroyal.github.io/post/Try with closable resources/</id>
        <link href="http://goroyal.github.io/post/Try with closable resources/">
        </link>
        <updated>2019-06-17T14:41:03.000Z</updated>
        <content type="html"><![CDATA[<p>以前，拿到一个closable资源后，如果对它操作，都要先用try包起来，最后一定要在finally里面关掉：</p>
<pre><code class="language-java">Closable resource = xxx; //此处为得到这个resource的逻辑
try {
	// 处理逻辑
} finally {
	if (resource != null) {
		try {
			resource.close();
	}
}
</code></pre>
<p>自从Java 7之后，根据官方文档<a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">tryResouceClose</a>，任何实现了<code>java.lang.AutoClosable</code>，以及<code>java.io.Closable</code>接口的对象都可以在这段代码结束之后被关掉：</p>
<pre><code class="language-java">try (Closable resource = xxx) {
	// 处理逻辑
}
</code></pre>
<p>.NET里面也有个类似的用法，C#里面一般实现了IDisposable接口的对象在使用时最好结束后调用它的dispose方法，也可以使用using的方式来帮助回收：</p>
<pre><code class="language-csharp">using (IDisposable resource = xxx) {
	// 处理逻辑
}
</code></pre>
]]></content>
    </entry>
</feed>