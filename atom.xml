<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://goroyal.github.io</id>
    <title>Goroyal&apos;s blog</title>
    <updated>2020-07-10T08:40:54.111Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://goroyal.github.io"/>
    <link rel="self" href="http://goroyal.github.io/atom.xml"/>
    <subtitle>学习分享</subtitle>
    <logo>http://goroyal.github.io/images/avatar.png</logo>
    <icon>http://goroyal.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Goroyal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Java里的各种Map]]></title>
        <id>http://goroyal.github.io/post/java-map/</id>
        <link href="http://goroyal.github.io/post/java-map/">
        </link>
        <updated>2020-07-10T08:34:59.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="treemap-hashmap-lindedhashmap的区别">TreeMap、HashMap、LindedHashMap的区别</h2>
<p><code>Map</code>主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p>
<p><code>Hashmap</code> 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。<code>HashMap</code>最多只允许一条记录的键为Null;允许多条记录的值为 Null;<code>HashMap</code>不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 <code>Collections</code>的<code>synchronizedMap</code>方法使HashMap具有同步的能力，或者使用<code>ConcurrentHashMap</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="treemap-hashmap-lindedhashmap的区别">TreeMap、HashMap、LindedHashMap的区别</h2>
<p><code>Map</code>主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p>
<p><code>Hashmap</code> 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。<code>HashMap</code>最多只允许一条记录的键为Null;允许多条记录的值为 Null;<code>HashMap</code>不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 <code>Collections</code>的<code>synchronizedMap</code>方法使HashMap具有同步的能力，或者使用<code>ConcurrentHashMap</code>。</p>
<!-- more -->
<p><code>Hashtable</code>与 <code>HashMap</code>类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p>
<p><code>LinkedHashMap</code>保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当<code>HashMap</code>容量很大，实际数据较少时，遍历起来可能会比<code>LinkedHashMap</code>慢，因为<code>LinkedHashMap</code>的遍历速度只和实际数据有关，和容量无关，而<code>HashMap</code>的遍历速度和他的容量有关。</p>
<p><code>TreeMap</code>实现<code>SortMap</code>接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code> 遍历<code>TreeMap</code>时，得到的记录是排过序的。<br>
TreeSet集合排序有两种方式，Comparable和Comparator区别：</p>
<ul>
<li>让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</li>
<li>让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数，方式较为灵活。</li>
</ul>
<p>一般情况下，我们用的最多的是<code>HashMap</code>,HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p>
<p><code>TreeMap</code>取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</p>
<p><code>LinkedHashMap</code> 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。</p>
<ol>
<li>
<p>HashSet是通过HashMap实现的,TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key</p>
</li>
<li>
<p>Map的key和Set都有一个共同的特性就是集合的唯一性.TreeMap更是多了一个排序的功能.</p>
</li>
<li>
<p>hashCode和equal()是HashMap用的, 因为无需排序所以只需要关注定位和唯一性即可.</p>
<p>a. hashCode是用来计算hash值的,hash值是用来确定hash表索引的.</p>
<p>b. hash表中的一个索引处存放的是一张链表, 所以还要通过equal方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry.</p>
<p>c. put时,如果hash表中没定位到,就在链表前加一个Entry,如果定位到了,则更换Entry中的value,并返回旧value</p>
</li>
<li>
<p>由于TreeMap需要排序,所以需要一个Comparator为键值进行大小比较.当然也是用Comparator定位的.</p>
<p>a. Comparator可以在创建TreeMap时指定</p>
<p>b. 如果创建时没有确定,那么就会使用key.compareTo()方法,这就要求key必须实现Comparable接口.</p>
<p>c. TreeMap是使用Tree数据结构实现的,所以使用compare接口就可以完成定位了.</p>
</li>
</ol>
<h1 id="参考资料">参考资料</h1>
<p>http://blog.csdn.net/fg2006/article/details/6411200</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript里的对象]]></title>
        <id>http://goroyal.github.io/post/js-object/</id>
        <link href="http://goroyal.github.io/post/js-object/">
        </link>
        <updated>2020-07-10T08:28:54.000Z</updated>
        <summary type="html"><![CDATA[<p>JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。<br>
对象时属性的容器，其中每个属性都是名字和值。<br>
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。</p>
]]></summary>
        <content type="html"><![CDATA[<p>JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。<br>
对象时属性的容器，其中每个属性都是名字和值。<br>
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。</p>
<!-- more -->
<p><strong>对象字面量</strong></p>
<pre><code class="language-javascript">var empty_object={};

var stoge={
  &quot;firstName&quot;:&quot;Joerome&quot;,
  &quot;lastName&quot;:&quot;Howare&quot;
};
</code></pre>
<p>上面的对象stoge中两个属性，如果他们不是JavaScript的保留字，可以去掉引号。<br>
检索对象里面属性的值可以用中括号去获取，如<code>stoge[&quot;firstName&quot;]</code>，如果该字符串表达式是一个字符串字面量，且是合法的JavaScript标识符不是保留字，那么也可以用点号“.”获取。如果试图获取一个不存在的属性，将得到undefined。</p>
<p>使用typeof操作符对确定属性的类型很有帮助：</p>
<pre><code class="language-javascript">typeof flight.number  // 'number'
</code></pre>
<p>注意，原型链中的任何属性都会产生值：</p>
<pre><code class="language-javascript">typeof flight.toString  // 'function'
typeof flight.constructor // 'function'
</code></pre>
<p>有两种方法处理这些不需要的属性：<br>
第一个是让程序做检查并丢弃值为函数的属性，一般来说，想让对象在运行时动态获取自身信息时，关注更多的是数据。<br>
另一个方法是使用hasOwnProperty方法，如果对象拥有独有的属性，将返回true，该方法不会检查原型链。</p>
<pre><code class="language-javascript">flight.hasOwnProperty('number') // true
</code></pre>
<p>for in 循环中遍历属性的顺序是不确定的，如果想要确保属性以特定的顺序出现，最好的办法是完全避免使用for in语句，而是创建一个数组，在其中以正确的顺序包含属性名，然后使用普通的for循环遍历。</p>
<p>delete可以删除对象中的属性，不会触及原型链中的任何对象，删除对象的属性可能会让原型链中的属性透现出来：</p>
<pre><code class="language-javascript">another.nickname  // 'Moe'

// 删除another的nickname属性，暴露出原型的nickname属性
delete another.nickname;

another.nickname  // 'Curly'
</code></pre>
<p>用Java里面的话理解，就是删除子类中的覆盖父类的属性以及get方法，那么下次再想获取该属性，将是从父类得到的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL不同的存储引擎]]></title>
        <id>http://goroyal.github.io/post/mysql-storage-engine/</id>
        <link href="http://goroyal.github.io/post/mysql-storage-engine/">
        </link>
        <updated>2020-07-10T08:25:32.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL由以下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲（Cache）组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p>
<p><strong>注意：存储引擎是基于表的，而不是数据库。</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL由以下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲（Cache）组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p>
<p><strong>注意：存储引擎是基于表的，而不是数据库。</strong></p>
<!-- more -->
<p>MySQL常用的插件式存储引擎主要包括MyISAM，InnoDB，NDB Cluster，Maria，Falcon，Memory，Archive，Merge，Federated等，其中最著名且使用最广泛的是MyISAM和InnoDB。MyISAM是MySQL的默认存储引擎，是MySQL最早的ISAM存储引擎的升级版本。</p>
<h2 id="myisam存储引擎">MyISAM存储引擎</h2>
<p>MyISAM是MySQL的默认存储引擎，它支持B-tree/FullText/R-tree索引类型。<br>
MyISAM的锁级别是表锁，表锁的开销小，加锁快；锁粒度大，发生锁冲突的概率较高，并发度低；表锁适合查询。MyISAM引擎不支持事务性，也不支持外键。</p>
<p>MyISAM对于一些OLAP（Online Analytical Processing，在线分析处理）操作速度快。除Windows版本外，是所有MySQL版本默认的存储引擎。</p>
<p>MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，当然你也可以通过myisampack来解压数据文件<br>
。<br>
在MySQL 5.0版本之前，MyISAM默认支持的表大小为4G，如果需要支持大于4G的MyISAM表时，则需要制定MAXROWS和 AVGROW_LENGTH属性。从MySQL 5.0版本开始，MyISAM默认支持256T的单表数据，这足够满足一般应用的需求。</p>
<p><strong>注意</strong>：对于MyISAM存储引擎表，MySQL数据库只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他使用LRU算法缓存数据 的大部分数据库大不相同。此外，在MySQL 5.1.23版本之前，无论是在32位还是64位操作系统环境下，缓存索引的缓冲区最大只能设置为4G。在之后的版本中，64位系统可以支持大于4G的索引缓冲区。</p>
<h2 id="innodb存储引擎">InnoDB存储引擎</h2>
<p>InnoDB存储引擎最大的亮点就是支持事务性，支持回滚。它支持Hash/B-tree索引类型。<br>
InnoDB的锁级别是行锁，行锁在锁定上带来的消耗大于表锁，但是在系统并发访问量较高时，InnoDB整体性能远高于MyISAM。InnoDB的索引不仅缓存索引本身，也缓存数据，所以InnoDB需要更大的内存。</p>
<p>InnoDB存储引擎支持事务，主要面向在线事务处理（OLTP）方面的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读取操作不会产生锁。MySQL在Windows版本下的InnoDB是默认的存储引擎，同时InnoDB默认地被包含在所有的MySQL二进制发布版本中。</p>
<p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB自身进行管理。从MySQL 4.1（包括4.1）版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。与Oracle类似，InnoDB存储引擎同样可以使用裸设备（row disk）来建立其表空间。</p>
<p>InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时使用一种被称为next-key locking 的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</p>
<p>对于表中数据的存储，InnoDB存储引擎采用了聚簇（clustered）的方式，这种方式类似于Oracle的索引聚集表（index organized table，IOT）。</p>
<p>每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的 ROWID，并以此作为主键。</p>
<h2 id="memory存储引擎">Memory存储引擎</h2>
<p>Memory存储引擎是一个内存级的存储引擎，它将所有数据都存储在内存中，所以它能够存储的数据量是比较小的。而因为内存的特性，Memory存储引擎对于数据的一致性支持教差。Memory的锁级别和MyISAM一样，是表锁；并且不支持事务性。</p>
<p>Memory存储引擎（之前称为HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。它默认使用哈希索引，而不是我们熟悉的B+树索引。</p>
<p>虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，其只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（这个问题之前已经提到，eBay的Igor Chernyshev工程师已经给出了Patch方案）。<br>
此外有一点常被忽视的是，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。</p>
<h2 id="ndb存储引擎">NDB存储引擎</h2>
<p>2003年，MySQL AB公司从Sony Ericsson公司收购了NDB 集群引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群；不过，与Oracle RAC share everything结构不同的是，其结构是share nothing的集群架构，因此能提供更高级别的高可用性。NDB的特点是数据全部放在内存中（从5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找（primary key lookup）的速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。</p>
<p>关于NDB存储引擎，有一个问题值得注意，那就是NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。</p>
<p><strong>注意</strong>：MySQL NDB Cluster存储引擎有社区版本和企业版本，并且NDB Cluster已作为Carrier Grade Edition单独下载版本而存在，可以通过[http://dev.mysql.com/ downloads/cluster/index.html](http://dev.mysql.com/ downloads/cluster/index.html)获得最新版本的NDB Cluster存储引擎。</p>
<h2 id="archive存储引擎">Archive存储引擎</h2>
<p>Archive存储引擎只支持INSERT和SELECT操作，MySQL 5.1开始支持索引。其使用zlib算法将数据行（row）进行压缩后存储，压缩比率一般可达1∶10。正如其名称所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是本身并不是事物安全的存储引擎，其设计目标主要是提供高速的插入 和压缩功能。</p>
<h2 id="federated存储引擎">Federated存储引擎</h2>
<p>Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。</p>
<h2 id="maria存储引擎">Maria存储引擎</h2>
<p>Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎，开发者是MySQL 的创始人之一的Michael Widenius。因此，它可以看作是MyISAM的后续版本。其特点是：缓存数据和索引文件，行锁设计，提供MVCC功能，支持事务和非事务安全的选项 支持，以及更好的BLOB字符类型的处理性能。</p>
<h2 id="其他存储引擎">其他存储引擎</h2>
<p>除了上面提到的7种存储引擎外，还有很多其他的存储引擎，包括Merge、CSV、Sphinx和Infobright，它们都有各自适用的场合，这里不再一一做介绍了。了解了MySQL拥有这么多存储引擎后，现在我可以回答1.2节中提到的问题了。</p>
<p>为什么MySQL不支持全文索引？不！MySQL支持，MyISAM、Sphinx存储引擎支持全文索引。<br>
MySQL快是因为不支持事务吗？错！MySQL MyISAM存储引擎不支持事务，但是InnoDB支持。快是相对于不同应用来说的，对于ETL这种操作，MyISAM当然有其优势。<br>
当表的数据量大于1000W时，MySQL的性能会急剧下降吗？不！MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，如果 你选择了正确的存储引擎以及正确的配置，再大的数据量MySQL也是能承受的。如官方手册上提及的，Mytrix和Inc.在InnoDB上存储了超过 1TB的数据，还有一些其他网站使用InnoDB存储引擎处理平均每秒800次插入/更新的操作。</p>
<h2 id="myisam和innodb差别">MyISAM和InnoDB差别</h2>
<h3 id="构成差别">构成差别</h3>
<p>每个MyISAM在磁盘上存储成三个文件，文件的名字以表的名字开始，.frm文件存储表定义，.MYI(MYIndex)为索引文件，.MYD(MYData)为数据文件。</p>
<p>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
<h3 id="事务处理差别">事务处理差别</h3>
<p>MyISAM类型的表强调性能，执行速度比InnoDB快，但是不支持事务处理等高级功能。</p>
<p>InnoDB提供事务支持、外部键等高级数据库功能。</p>
<h3 id="crud操作">CRUD操作</h3>
<p>如果执行大量SELECT查询操作，MyISAM是最好的选择。</p>
<p>如果执行大量的UPDATE或者INSERT操作，出于性能方面考虑，应该使用InnoDB。<code>DELETE from table</code>时，InnoDB不会重新建立表，而是一行一行的删除。<br>
<code>LOAD TABLE FROM MASTER</code>操作对InnoDB不起作用，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。</p>
<h3 id="auto_increment操作">AUTO_INCREMENT操作</h3>
<p>MyISAM为INSERT和UPDATE操作自动更新这一列，这使得AUTO_INCREMENT列更快（10%+），在序列项的值删除后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。<br>
AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置。</p>
<p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但 是在MyISAM表中，可以和其他字段一起建立联合索引。<br>
如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。InnoDB自动增长计数器仅被存储在主内存中，而不是存在磁盘上。</p>
<h3 id="表的具体行数">表的具体行数</h3>
<p><code>select count(*) from table</code>，MyISAM只要简单的读出保存好的行数。注意的是，当count(*)语句包含 where 条件时，两种类型表的操作是一样的。</p>
<p>InnoDB 中不保存表的具体行数。也就是说，执行<code>select count(*) from table</code>时，InnoDB要扫描一遍整个表来计算有多少行。</p>
<h3 id="锁">锁</h3>
<p>MyISAM的锁是在表级别。其并发写的性能一直是一个让人比较头疼的问题。</p>
<p>InnoDB提供了行级别的锁(locking on row level)，提供与 Oracle类型一致的不加锁读取(non-locking read in SELECTs)。另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如<code>update table set num=1 where name like '%aaa%'</code>。</p>
<h3 id="索引">索引</h3>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引。</p>
<p>Innodb是索引和数据是存放在相同的文件，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。Innodb 的数据存放格式也比较独特,每个Innodb表 都会将主键以聚簇索引的形式创建。所有的数据都是以主键来作为升序排列在物理磁盘上面,所以主键 查询并且以主键排序的查询效率也会非常高。</p>
<h2 id="如何选择合适的引擎">如何选择合适的引擎</h2>
<h3 id="采用myisam引擎">采用MyISAM引擎</h3>
<p>R/W &gt; 100 ，并且Update较少 (R/W:读写比)<br>
并发不高，不需要支持事务<br>
表数据量小<br>
需要进行全文搜索</p>
<h3 id="采用innodb引擎">采用InnoDB引擎</h3>
<p>R/W比较小，频繁更新大字段<br>
表数据量超过千万，高并发<br>
安全性和可用性要求高</p>
<h3 id="采用memory引擎">采用Memory引擎</h3>
<p>有足够的内存<br>
对数据一致性要求不高，如session/在线人数等<br>
需要定期归档的数据</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.ha97.com/4197.html">MySQL存储引擎MyISAM与InnoDB的主要区别对比</a></li>
<li><a href="http://imysql.com/2015/07/23/something-important-about-mysql-design-reference.shtml">老叶观点：MySQL开发规范之我见</a><br>
<a href="http://simpleframework.net/news/view?newsId=63cd772590e8495bbff4d713e092f772">《MySQL技术内幕:InnoDB存储引擎》-- 第1章 MySQL体系结构和存储引擎</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【数据结构】数组和链表]]></title>
        <id>http://goroyal.github.io/post/array-and-linkedlist/</id>
        <link href="http://goroyal.github.io/post/array-and-linkedlist/">
        </link>
        <updated>2020-07-10T07:55:54.000Z</updated>
        <summary type="html"><![CDATA[<p>在计算机程序里，数据存储的方式无外乎两种：顺序存储和链式存储。顺序存储的结构可以称为顺序表，也可以用数组描述，链式存储的结构可以称为链表。<br>
我们每一个学过数据结构的都知道，它们两者各自有一些鲜明的特性，比如：</p>
<ul>
<li>我们可以通过数组下标去访问数组里的元素，查询、更新的效率高，时间复杂度是O(1)，但是在中间某个位置插入或删除一个元素就要挪动后面所有的元素，时间复杂度是O(n)。</li>
<li>链表里元素之间存在指针指向关联的另一个元素，我们只能通过指针挨个去遍历访问链表里的元素，查询、更新的效率低，时间复杂度是O(n)，在中间某个位置插入或删除一个元素比较方便，只需要修改相邻指针的引用就可以了，时间复杂度是O(1)。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>在计算机程序里，数据存储的方式无外乎两种：顺序存储和链式存储。顺序存储的结构可以称为顺序表，也可以用数组描述，链式存储的结构可以称为链表。<br>
我们每一个学过数据结构的都知道，它们两者各自有一些鲜明的特性，比如：</p>
<ul>
<li>我们可以通过数组下标去访问数组里的元素，查询、更新的效率高，时间复杂度是O(1)，但是在中间某个位置插入或删除一个元素就要挪动后面所有的元素，时间复杂度是O(n)。</li>
<li>链表里元素之间存在指针指向关联的另一个元素，我们只能通过指针挨个去遍历访问链表里的元素，查询、更新的效率低，时间复杂度是O(n)，在中间某个位置插入或删除一个元素比较方便，只需要修改相邻指针的引用就可以了，时间复杂度是O(1)。</li>
</ul>
<!-- more -->
<h2 id="数组">数组</h2>
<p>数组的好处显而易见，它的存储结构比较紧凑，相对节省空间。每个元素都有唯一的索引，支持随机访问。但是数组所需要的空间需要一次分配够，当数组容量满时，新加入元素就要对数组进行扩容。扩容时，往往不能在原地直接扩，因为后面的内存可能已经分配给其他数据结构了，所以要重新申请一块新的更大的内存空间，将原有的数组里的元素全部复制到新的数组里，再释放原有数组的空间，这个过程时间复杂度是O(n)，可以参考Java的<code>ArrayList</code>。如果不加以合理的维护，内存中将产生大量碎片。</p>
<h2 id="链表">链表</h2>
<p>链表有效地解决里数组需要扩容的问题，因为链表里的每个元素节点都不需要连续，链表的节点通过指针进行索引，每个节点只能找到它指针指向的下一个节点。正常的单向链表是从头节点开始，每个节点依次有一个指针指向它后面的节点，尾部节点指向NULL。有时候为了方便拿到前驱节点，我们会采用双向链表，也就是每个节点既包含一个指针指向后面的，也包含一个指针指向前面的。还有一种链表是循环链表，也就是说尾节点指向了头节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 中的 2> /dev/null]]></title>
        <id>http://goroyal.github.io/post/linux-redirect-dev-null/</id>
        <link href="http://goroyal.github.io/post/linux-redirect-dev-null/">
        </link>
        <updated>2020-05-21T15:12:33.000Z</updated>
        <summary type="html"><![CDATA[<p>本文亦发布于<a href="https://thinkbucket.cn/blog/2020/05/21/linux-redirect-dev-null">ThinkBucket</a>。<br>
在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：</p>
<pre><code class="language-shell">2&gt; /dev/null
</code></pre>
<p>这是何意？</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文亦发布于<a href="https://thinkbucket.cn/blog/2020/05/21/linux-redirect-dev-null">ThinkBucket</a>。<br>
在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：</p>
<pre><code class="language-shell">2&gt; /dev/null
</code></pre>
<p>这是何意？</p>
 <!-- more --> 
<h2 id="linux-进程">Linux 进程</h2>
<p>以 bash 为例，shell 中执行一个命令时，其实是由 bash shell fork 出一个子进程，然后在这个子进程中运行相应的命令，直至退出。Linux 里的进程的数据结构如下：</p>
<pre><code class="language-C">struct task_struct {
	// 进程状态
	long state;
	// 虚拟内存结构体
	struct mm_struct *mm;
	// 进程号
	pid_t pid;
	// 指向父进程的指针
	struct task_struct __rcu *parent;
	// 子进程列表
	struct list_head children;
	// 存放文件系统信息的指针
	struct fs_struct *fs;
	// 一个数组，包含该进程打开的文件指针
	struct files_struct *files;
};
</code></pre>
<p><code>task_struct</code> 就是 Linux 对于一个进程的描述，也可以称之为进程描述符。其中的 <code>files</code> 指针指向一个数组，表示当前进程打开的所有文件。</p>
<p><strong>每个进程被创建时，<code>files</code> 指向的数组前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。</strong></p>
<p>:::<strong>tip</strong></p>
<blockquote>
<p>Linux 中的所有设备都是抽象成文件的，设备可以当作文件一样读和写。</p>
</blockquote>
<h2 id="重定向">重定向</h2>
<p>Linux shell 里通过 <code>&gt;</code>、<code>&lt;</code>进行输出、输入的重定向。</p>
<ul>
<li><code>&gt;</code>：将 shell 命令的输出指向某个地方，可以是文件，也可以是内存里的某个变量。比如 <code>ls -l &gt; file.txt</code> 就是把当前路径下的文件信息保存到 file.txt 文本中，如果没有这个重定向，它会将结果输出到显示器屏幕上。</li>
<li><code>&lt;</code>：从某个地方读取内容作为 shell 命令的输入，可以是文件，也可以是内存里的某个变量。比如 <code>{command} &lt; file.txt</code>，如果没有这个重定向，它会从键盘读取输入。</li>
</ul>
<p>此外，shell 还可以通过 <code>|</code> 将前一个命令的输出作为下一个命令的输入，比如：</p>
<pre><code class="language-shell"># 在命令历史中找到包含 ssh 字符串的命令
history | grep ssh
</code></pre>
<h2 id="2-devnull">2&gt; /dev/null</h2>
<p>通过上面的章节可以知道，<code>2</code> 表示标准错误，<code>&gt;</code> 表示将标准错误重定向到某个地方。</p>
<p><code>/dev/null</code> 是一个特殊文件，在Unix系统中称为 null 设备。 通俗地说，它也称为比特桶（bit bucket，也译作比特垃圾桶）或黑洞（blackhole），因为它会立即丢弃写入其中的任何内容，并且在读取时仅返回文件结束EOF。</p>
<p>所以这个命令合起来就是将忽略执行命令产生的错误。比如：</p>
<pre><code class="language-shell"># 删除当前路径下的folder目录，如果不存在则忽略错误
rm -r folder 2&gt; /dev/null
</code></pre>
<p>:::<strong>caution</strong></p>
<blockquote>
<p><code>2</code>和<code>&gt;</code>之间不能有空格</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://bash.cyberciti.biz/guide/What_is_a_Process%3F">What is a Process?</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">Linux的进程、线程、文件描述符是什么</a></li>
<li><a href="https://zh.wikipedia.org/wiki//dev/null">维基百科：/dev/null</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象编程与纯函数]]></title>
        <id>http://goroyal.github.io/post/oop-and-pure-function/</id>
        <link href="http://goroyal.github.io/post/oop-and-pure-function/">
        </link>
        <updated>2019-06-26T16:51:40.000Z</updated>
        <summary type="html"><![CDATA[<p>在面向对象编程里面，我们常常对现实世界建模抽象成一个个类，然后创建它们的对象，通过对象的方法行为去描述逻辑。</p>
<p>纯函数是一种特殊的函数，给它相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在面向对象编程里面，我们常常对现实世界建模抽象成一个个类，然后创建它们的对象，通过对象的方法行为去描述逻辑。</p>
<p>纯函数是一种特殊的函数，给它相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>
<!-- more -->
<p>占位符，待更。</p>
<p>https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1<br>
https://www.jiqizhixin.com/articles/2018-10-22-15</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Shell里管理多个Java版本]]></title>
        <id>http://goroyal.github.io/post/manage-multiple-java-versions/</id>
        <link href="http://goroyal.github.io/post/manage-multiple-java-versions/">
        </link>
        <updated>2019-06-26T16:30:26.000Z</updated>
        <summary type="html"><![CDATA[<p>自从Oracle宣布Java开始收费之后，越来越多的人会考虑从[Open JDK][1]下载安装Java环境。可能自己机器上也会同时并存好几个Java版本，本文以macOS为例介绍一下如何从Open JDK安装并进行管理多版本。</p>
]]></summary>
        <content type="html"><![CDATA[<p>自从Oracle宣布Java开始收费之后，越来越多的人会考虑从<a href="https://openjdk.java.net/install/">Open JDK</a>下载安装Java环境。可能自己机器上也会同时并存好几个Java版本，本文以macOS为例介绍一下如何从Open JDK安装并进行管理多版本。</p>
<!-- more -->
<h2 id="下载安装">下载安装</h2>
<pre><code class="language-shell">curl -O https://download.java.net/java/GA/jdk12/33/GPL/openjdk-12_osx-x64_bin.tar.gz 
tar xvf openjdk-12_osx-x64_bin.tar.gz

# 解压后文件夹比如名为jdk-12.jdk，移动到macOS管理的JVM目录中去
sudo mv jdk-12.jdk /Library/Java/JavaVirtualMachines
</code></pre>
<p>此时，可以输入如下命令查看本机上有几种Java版本：</p>
<pre><code class="language-shell">/usr/libexec/java_home -V
</code></pre>
<p>比如生成如下内容：</p>
<pre><code>Matching Java Virtual Machines (2):
    12, x86_64:	&quot;OpenJDK 12&quot;	/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home
    1.7.0_76, x86_64:	&quot;Java SE 7&quot;	/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home
</code></pre>
<p>也可以输入小写v参数查看具体的版本信息，比如查刚刚下载的Java 12：</p>
<pre><code class="language-shell">/usr/libexec/java_home -v 12
</code></pre>
<p>会显示<code>/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home</code>，这个就是它的Java Home。那么就能通过export设置当前的JAVA_HOME环境变量了。比如：</p>
<pre><code>export JAVA_HOME=`/usr/libexec/java_home -v 12`
</code></pre>
<h2 id="便利管理多版本">便利管理多版本</h2>
<p>Linux或者macOS都有bash或者其他shell，以bash为例，bash在每个用户目录下都有<code>.bashrc</code>文件用于配置用户相关的环境变量（如果没有可以自己创建），可以在该文件下面写如下代码：</p>
<pre><code class="language-shell"># type 'java7' at command prompt to switch to java 7
function java7() {
    export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
    echo &quot;JAVA_HOME is $JAVA_HOME&quot;
    java -version
}

# type 'java12' at command prompt to switch to java 12
function java12() {
    export JAVA_HOME=`/usr/libexec/java_home -v 12`
    echo &quot;JAVA_HOME is $JAVA_HOME&quot;
    java -version
}
</code></pre>
<p>保存之后，输入命令<code>source .bashrc</code>，然后可以通过命令<code>java12</code>或者<code>java7</code>来便捷切换所使用的Java版本。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try with closable resources]]></title>
        <id>http://goroyal.github.io/post/Try with closable resources/</id>
        <link href="http://goroyal.github.io/post/Try with closable resources/">
        </link>
        <updated>2019-06-17T14:41:03.000Z</updated>
        <content type="html"><![CDATA[<p>以前，拿到一个closable资源后，如果对它操作，都要先用try包起来，最后一定要在finally里面关掉：</p>
<pre><code class="language-java">Closable resource = xxx; //此处为得到这个resource的逻辑
try {
	// 处理逻辑
} finally {
	if (resource != null) {
		try {
			resource.close();
	}
}
</code></pre>
<p>自从Java 7之后，根据官方文档<a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">tryResouceClose</a>，任何实现了<code>java.lang.AutoClosable</code>，以及<code>java.io.Closable</code>接口的对象都可以在这段代码结束之后被关掉：</p>
<pre><code class="language-java">try (Closable resource = xxx) {
	// 处理逻辑
}
</code></pre>
<p>.NET里面也有个类似的用法，C#里面一般实现了IDisposable接口的对象在使用时最好结束后调用它的dispose方法，也可以使用using的方式来帮助回收：</p>
<pre><code class="language-csharp">using (IDisposable resource = xxx) {
	// 处理逻辑
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以单元测试的角度聊聊写代码]]></title>
        <id>http://goroyal.github.io/post/wring-code-from-unit-test-side/</id>
        <link href="http://goroyal.github.io/post/wring-code-from-unit-test-side/">
        </link>
        <updated>2019-05-24T12:25:28.000Z</updated>
        <summary type="html"><![CDATA[<p>单元测试，也就是对代码较细粒度单元的测试，一般就是测某个方法或函数。说到单元测试，基本上每个开发者都不陌生，时不时会听到“测试覆盖率太低了！”，然后“We need to increase our code coverage!”。经常出bug？好好准备测试吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>单元测试，也就是对代码较细粒度单元的测试，一般就是测某个方法或函数。说到单元测试，基本上每个开发者都不陌生，时不时会听到“测试覆盖率太低了！”，然后“We need to increase our code coverage!”。经常出bug？好好准备测试吧。</p>
<!-- more -->
<h2 id="1-为什么要提高覆盖率">1. 为什么要提高覆盖率？</h2>
<p>覆盖率为什么这么重要？我们每次修改代码之后都不希望把原有可用的功能搞出问题，如果没有足够的测试覆盖，开发者就没有足够的信心去交付新代码。测试覆盖率高的话，就可以用机器自动去跑高效率地去验证，在覆盖不到的地方需要人工去验证。所以当覆盖率很低的时候，人工需要一遍又一遍的去验证已有的功能，还要去验证新加的功能是否符合预期，这个真的会崩溃。开发者自己去做的话，八成会偷懒抑或是觉得自己改的范围影响不到那么多测得乐观。如果让测试工程师去做，那么需要领导们考虑开发跟测试的比例了。</p>
<p>测试覆盖率不完全是看单元测试，还包括更高层次的集成测试、系统测试。当然了，如果单元测试没写多少，指望粒度更粗层次更高的其他测试，你会非常痛苦的。单元测试的2个优势：跑得快、容易定位问题。</p>
<p>上面说了这么多，就是在强调单元测试覆盖率一定要尽可能高，每个单元测试职责一定要尽可能单一简单。单元测试覆盖无非就是代码行覆盖、分支覆盖，单元测试职责单一简单是说单元测试不要试图测某个方法的所有可能性，多写几个，这样出了问题能根据测试名字迅速找到为什么什么用例失败了以及被测方法的哪行可能有问题。</p>
<h2 id="2-单元测试为何难写">2. 单元测试为何难写？</h2>
<p>你可能听说过“测试驱动开发”，就是先写测试、后写代码，这个要求在写代码之前先好好分析需求、细化用例，把各个用例的测试写出来，每次改动代码都要求让尽可能多的测试结果为绿（成功），直到最后所有测试都绿了，那么代码的功能上也基本没问题了。这个可以了解下，有兴趣多看看这方面拓展一下。<br>
<img src="http://goroyal.github.io/post-images/1560780095750.png" alt="" loading="lazy"></p>
<p>为什么单元测试覆盖率往往上不去？因为有时候真的不好写。什么样的代码不好写单元测试：</p>
<ol>
<li>被测方法传入了比较复杂的类的对象参数（不是依赖接口），当我要测这个方法，我就要去new依赖的那个对象，但是那个对象又依赖其他的，我又要接着new……，可能这个方法还没开始测，光创建它依赖的东西就写了一大堆测试代码。</li>
<li>被测方法传入了某个对象作为参数，调用的复杂方法（不是依赖接口），这个方法有多复杂？可能它也跟上面一样也要new很多个对象才能跑起来，或者它调用了外部服务（网络、数据库等等）。简直没法测。</li>
<li>被测方法自己内部创建了一些复杂对象、或者这个方法所属对象的实例创建了一些复杂对象，往往可能是外部有依赖的，比如对文件系统、数据库、网络等有调用。</li>
<li>被测方法自己内部引用了static变量。</li>
<li>被测方法自己内部引用了单例对象。</li>
<li>被测方法调用了复杂的static方法，无法mock、无法用桩。</li>
<li>被测方法是一个static方法，它可能依赖一个或多个static变量，这个变量还会被其他static方法修改，很难保证当前测试的独立性，包括它本身作为生产代码都是有坑的。</li>
<li>被测方法传入了对象参数，考虑用桩了，但是发现那个类或者方法是final的，无法继承重写（如果是C#语言，sealed类无法被继承，无override关键字的方法不能被重写）。</li>
<li>被测方法本身太长了，很难面面俱到，或者是单元测试出了错之后不好定位是哪行代码引起的问题</li>
</ol>
<h2 id="3-如何写好单元测试">3. 如何写好单元测试</h2>
<p><strong>单元测试应该聚焦于被测方法本身的行为</strong>，而不是被测方法所依赖的其他对象的行为。外部环境有依赖的代码应该尽可能少，并且尽量去调用接口，而不是具体的类。我们经常会听到“面向接口编程”，这个用了之后，写单元测试真的是非常爽。单元测试里面会用mock库或者自己去创建简单的类去模拟某个方法的行为，接口约定根据输入会产生什么样的输出，对于调用接口的方法而言不必去关心具体的实现是什么。Java里有著名的Mockito，C#里有Moq，用起来如行云流水一般。</p>
<p><strong>方法或者类构造器里面自己创建的对象不能太复杂</strong>，复杂了你就没法测了。可以考虑调用该对象的接口，将它作为输入参数，那么就可以用上面说的方式去测了。</p>
<p>个人理解，<strong>static方法要尽可能做到纯函数化</strong>，也就是说一样的输入参数，随便什么情况下调用都应该给一样的输出。这其实就要求static这样的静态方法不要依赖不可控的static变量。如果做不到，尽量缩小它的使用范围吧……普通的实例方法调用static方法尽可能只调用简单的，没事别调用public的static变量，调用不受控制的static变量简直是给自己找麻烦，不可测是一方面，运行时被别的代码改掉的话就是灾难了。</p>
<p><strong>当被测方法太长的时候，实际上就意味着方法要拆了</strong>，便于理解和维护。可以正常的拆，比如新建方法、新建类，也可以花哨地拆。有些人写了一堆if、else语句，如果是创建对象相关的，是否可以考虑工厂模式了？如果if、else里面是比较长的逻辑，可以考虑用策略模式。而如果是普通的前后累积的代码很长，要不试试责任链模式？当拆完之后，原本的非常长的不好测的方法变成若干个易测的小方法。覆盖率自然就上去了。</p>
<h2 id="4-结语">4. 结语</h2>
<p>当每层代码都经过单元测试确保自己这层没问题之后，整个逻辑的链条其实问题不大了。覆盖率不是简简单单为了覆盖而覆盖，单元测试都要有断言，就是如果跟测试目的产生不一致的结果这个测试必须显示失败，否则光数据好看是没用的。<strong>单元测试也不可能做到100%覆盖，但是可以尽可能做得高</strong>，覆盖不到的地方再通过集成测试或者系统层面的测试去做。至于做不到100%覆盖的原因，比如代码里有对外部依赖的地方，再怎么抽离，总有地方需要去初始化。那么对于这个情况，尽可能把这个对外依赖范围缩小，其他地方用的时候传递接口。</p>
<p>关于面向接口编程和减少耦合，还可以了解下依赖注入，能帮助解耦调用模块和具体实现类模块。</p>
<p>为了代码可扩展性高、良好设计、易测试，可能会出现一个复杂业务逻辑的代码一层套一层的情况，一个逻辑看完可能经历了若干个类，这也是人们常常吐槽的Java这种语言的一个“啰嗦”之处。这个我也没有什么更好的想法，如果你有，可以分享一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 响应状态码]]></title>
        <id>http://goroyal.github.io/post/http-response-code/</id>
        <link href="http://goroyal.github.io/post/http-response-code/">
        </link>
        <updated>2019-04-06T12:14:38.000Z</updated>
        <summary type="html"><![CDATA[<p>目前HTTP在Web开发中被广泛使用，REST (Representational State Transfer) 很多人应该或多或少都知道些。当然了，比较熟悉的可能主要是GET、POST方法。这篇文章不是介绍REST的定义和如何创建符合REST风格的API，而是讲讲在Web开发中通用的不同HTTP响应状态码的含义。在普通网站开发、分布式集群开发、团队协作方面，如果采用了HTTP作为组件之间交互的协议，遵守通用的响应状态码是很有必要的（一是有充分的信息量、二是避免歧义）。</p>
<p>HTTP响应状态共有5大类，分别是数字1、2、3、4、5开头。</p>
]]></summary>
        <content type="html"><![CDATA[<p>目前HTTP在Web开发中被广泛使用，REST (Representational State Transfer) 很多人应该或多或少都知道些。当然了，比较熟悉的可能主要是GET、POST方法。这篇文章不是介绍REST的定义和如何创建符合REST风格的API，而是讲讲在Web开发中通用的不同HTTP响应状态码的含义。在普通网站开发、分布式集群开发、团队协作方面，如果采用了HTTP作为组件之间交互的协议，遵守通用的响应状态码是很有必要的（一是有充分的信息量、二是避免歧义）。</p>
<p>HTTP响应状态共有5大类，分别是数字1、2、3、4、5开头。</p>
<!-- more -->
<h2 id="1xx">1XX</h2>
<p>信息性状态码，表示接收的请求正在处理。</p>
<ul>
<li>100：说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应</li>
<li>101：说明服务器正在根据客户端的指定，将协议切换成Update 首部所列的协议</li>
</ul>
<h2 id="2xx">2XX</h2>
<p>成功状态码，表示请求正常处理完毕</p>
<ul>
<li>200：OK，实体的主体部分包含了所请求的资源。（正常请求很多是这种状态）</li>
<li>201： Created，表示创建资源成功，响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location 首部包含的则是最具体的引用。（REST里面，POST或者PUT常常返回这样的状态）</li>
<li>202， Accepted， 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。</li>
<li>204：No Content，响应不包含实体的主体部分，通常在更新服务器上资源的时候成功的情况下不要求返回实体内容就会产生这个状态码。</li>
<li>206：Partial Content，成功执行了一个部分或Range（范围）请求。</li>
</ul>
<h2 id="3xx">3XX</h2>
<p>重定向状态码，表示需要进行附加操作以完成请求。</p>
<ul>
<li>301：Moved Permanently，永久性重定向，表示请求的资源被分配了新的URI，以后应使用资源现在所指的URI。</li>
<li>302：Found，临时性重定向，表示请求的资源被分配了新的URI，希望用户本次使用新的URI访问。</li>
<li>303：See Other，表示请求对应的资源存在这另一个URI，应使用GET方法定向获取请求的资源。</li>
<li>304：Not Modified，表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件。304状态码返回时不包含响应的主体部分（附带条件指：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）。304表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题。另一种情况是,如果服务器认为客户端缓存的资源已经过期了，那么服务器就会返回HTTP/200 OK响应，响应体就是该资源当前最新的内容。客户端收到200响应后，就会用新的响应体覆盖掉旧的缓存资源。</li>
<li>305：Use Proxy， 用来说明必须通过一个代理来访问资源；代理的位置由Location首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞。</li>
<li>307：Temporary Redirect，临时重定向，与302有相同的含义。尽管302标准禁止POST变幻成GET，实际大家并未遵守。307会遵照浏览器标准，不会从POST变为GET，但是对于处理响应时的行为每种浏览器可能出现不同的情况。</li>
</ul>
<h2 id="4xx">4XX</h2>
<p>客户端错误状态码，表示服务器无法处理请求。</p>
<ul>
<li>400：Bad Request， 用于告知客户端它发送了一个错误的请求，比方说请求体不符合预先定义的规则</li>
<li>401：Unauthorized，表示发送的请求需要有通过HTTP认证的认证信息，若之前已进行过请求，则表示认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate手部质询用户信息。</li>
<li>403：Forbidden，表明请求资源的访问被服务器拒绝了。</li>
<li>404：Not Found，用于说明服务器无法找到请求的URL所对应的资源。</li>
<li>405：Method Not Allowed，发起的请求中带有所请求的URL 不支持的方法时，使用此状态码。应该在响应中包含Allow 首部，以告知客户端对所请求的资源可以使用哪些方法。</li>
<li>406：Not Acceptable，客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的URL 相匹配的资源时，使用此代码。</li>
<li>413： Request Entity Too Large， 客户端发送的实体主体部分比服务器能够或者希望处理的要大时，返回此状态码。</li>
<li>429：Too Many Requests，表示客户端在给定时间范围内发送了太多请求。</li>
</ul>
<h2 id="5xx">5XX</h2>
<p>服务器错误状态码，表示服务器处理请求出错</p>
<ul>
<li>500：Intenernal Server Error，服务器在执行请求时发生了错误</li>
<li>501：Not Implemented，客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）</li>
<li>502：Bad Gateway， 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）。</li>
<li>503：Service Unavailable 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况所需时间，最好写入Retry-After首部字段返回给客户端。</li>
</ul>
]]></content>
    </entry>
</feed>