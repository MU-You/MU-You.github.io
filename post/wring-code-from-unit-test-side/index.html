<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Goroyal technical blog">
<meta name="description" content="学习分享">
<meta name="theme-color" content="#000">
<title>以单元测试的角度聊聊写代码 | Goroyal&#39;s blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1596440276563">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="以单元测试的角度聊聊写代码" />
  <meta name="keywords" content="Programming" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Goroyal&#39;s blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">学习分享</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Goroyal</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>后端工程师</p>
      
        <p>最近对分布式有点兴趣</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">36</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8F%90%E9%AB%98%E8%A6%86%E7%9B%96%E7%8E%87">1. 为什么要提高覆盖率？</a></li>
<li><a href="#2-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%BA%E4%BD%95%E9%9A%BE%E5%86%99">2. 单元测试为何难写？</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">3. 如何写好单元测试</a></li>
<li><a href="#4-%E7%BB%93%E8%AF%AD">4. 结语</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
    <h1 class="post-title">
        <a class="post-title-link" href="http://goroyal.github.io/post/wring-code-from-unit-test-side/">
            以单元测试的角度聊聊写代码
        </a>
    </h1>
    <div class="post-meta">
        
                <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
                <span>2019-05-24</span>
                <span class="post-meta-divider pc-show">|</span>
                </span>
                
                    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
                    
                        
                            <a href="http://goroyal.github.io/tag/en071zNCj/">
                                <span>Programming</span>
                            </a>
                            
                                    
                                        </span>
                                        <span class="post-meta-divider">|</span>
                                        
                                            <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>8<span class="language" data-lan="minute">分钟</span></span>
                                            </span>
                                            <span class="meta-item">
      <span class="post-meta-divider">|</span>
                                            <i class="fa fa-file-word-o"></i>
                                            <span>2117<span class="pc-show language" data-lan="words">字数</span></span>
                                            </span>
                                            
                                                
                                                    
                                                                <!-- <span id="/post/wring-code-from-unit-test-side/" data-flag-title="以单元测试的角度聊聊写代码" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span> -->
                                                                
    </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p>单元测试，也就是对代码较细粒度单元的测试，一般就是测某个方法或函数。说到单元测试，基本上每个开发者都不陌生，时不时会听到“测试覆盖率太低了！”，然后“We need to increase our code coverage!”。经常出bug？好好准备测试吧。</p>
<!-- more -->
<h2 id="1-为什么要提高覆盖率">1. 为什么要提高覆盖率？</h2>
<p>覆盖率为什么这么重要？我们每次修改代码之后都不希望把原有可用的功能搞出问题，如果没有足够的测试覆盖，开发者就没有足够的信心去交付新代码。测试覆盖率高的话，就可以用机器自动去跑高效率地去验证，在覆盖不到的地方需要人工去验证。所以当覆盖率很低的时候，人工需要一遍又一遍的去验证已有的功能，还要去验证新加的功能是否符合预期，这个真的会崩溃。开发者自己去做的话，八成会偷懒抑或是觉得自己改的范围影响不到那么多测得乐观。如果让测试工程师去做，那么需要领导们考虑开发跟测试的比例了。</p>
<p>测试覆盖率不完全是看单元测试，还包括更高层次的集成测试、系统测试。当然了，如果单元测试没写多少，指望粒度更粗层次更高的其他测试，你会非常痛苦的。单元测试的2个优势：跑得快、容易定位问题。</p>
<p>上面说了这么多，就是在强调单元测试覆盖率一定要尽可能高，每个单元测试职责一定要尽可能单一简单。单元测试覆盖无非就是代码行覆盖、分支覆盖，单元测试职责单一简单是说单元测试不要试图测某个方法的所有可能性，多写几个，这样出了问题能根据测试名字迅速找到为什么什么用例失败了以及被测方法的哪行可能有问题。</p>
<h2 id="2-单元测试为何难写">2. 单元测试为何难写？</h2>
<p>你可能听说过“测试驱动开发”，就是先写测试、后写代码，这个要求在写代码之前先好好分析需求、细化用例，把各个用例的测试写出来，每次改动代码都要求让尽可能多的测试结果为绿（成功），直到最后所有测试都绿了，那么代码的功能上也基本没问题了。这个可以了解下，有兴趣多看看这方面拓展一下。<br>
<img src="http://goroyal.github.io/post-images/1560780095750.png" alt="" loading="lazy"></p>
<p>为什么单元测试覆盖率往往上不去？因为有时候真的不好写。什么样的代码不好写单元测试：</p>
<ol>
<li>被测方法传入了比较复杂的类的对象参数（不是依赖接口），当我要测这个方法，我就要去new依赖的那个对象，但是那个对象又依赖其他的，我又要接着new……，可能这个方法还没开始测，光创建它依赖的东西就写了一大堆测试代码。</li>
<li>被测方法传入了某个对象作为参数，调用的复杂方法（不是依赖接口），这个方法有多复杂？可能它也跟上面一样也要new很多个对象才能跑起来，或者它调用了外部服务（网络、数据库等等）。简直没法测。</li>
<li>被测方法自己内部创建了一些复杂对象、或者这个方法所属对象的实例创建了一些复杂对象，往往可能是外部有依赖的，比如对文件系统、数据库、网络等有调用。</li>
<li>被测方法自己内部引用了static变量。</li>
<li>被测方法自己内部引用了单例对象。</li>
<li>被测方法调用了复杂的static方法，无法mock、无法用桩。</li>
<li>被测方法是一个static方法，它可能依赖一个或多个static变量，这个变量还会被其他static方法修改，很难保证当前测试的独立性，包括它本身作为生产代码都是有坑的。</li>
<li>被测方法传入了对象参数，考虑用桩了，但是发现那个类或者方法是final的，无法继承重写（如果是C#语言，sealed类无法被继承，无override关键字的方法不能被重写）。</li>
<li>被测方法本身太长了，很难面面俱到，或者是单元测试出了错之后不好定位是哪行代码引起的问题</li>
</ol>
<h2 id="3-如何写好单元测试">3. 如何写好单元测试</h2>
<p><strong>单元测试应该聚焦于被测方法本身的行为</strong>，而不是被测方法所依赖的其他对象的行为。外部环境有依赖的代码应该尽可能少，并且尽量去调用接口，而不是具体的类。我们经常会听到“面向接口编程”，这个用了之后，写单元测试真的是非常爽。单元测试里面会用mock库或者自己去创建简单的类去模拟某个方法的行为，接口约定根据输入会产生什么样的输出，对于调用接口的方法而言不必去关心具体的实现是什么。Java里有著名的Mockito，C#里有Moq，用起来如行云流水一般。</p>
<p><strong>方法或者类构造器里面自己创建的对象不能太复杂</strong>，复杂了你就没法测了。可以考虑调用该对象的接口，将它作为输入参数，那么就可以用上面说的方式去测了。</p>
<p>个人理解，<strong>static方法要尽可能做到纯函数化</strong>，也就是说一样的输入参数，随便什么情况下调用都应该给一样的输出。这其实就要求static这样的静态方法不要依赖不可控的static变量。如果做不到，尽量缩小它的使用范围吧……普通的实例方法调用static方法尽可能只调用简单的，没事别调用public的static变量，调用不受控制的static变量简直是给自己找麻烦，不可测是一方面，运行时被别的代码改掉的话就是灾难了。</p>
<p><strong>当被测方法太长的时候，实际上就意味着方法要拆了</strong>，便于理解和维护。可以正常的拆，比如新建方法、新建类，也可以花哨地拆。有些人写了一堆if、else语句，如果是创建对象相关的，是否可以考虑工厂模式了？如果if、else里面是比较长的逻辑，可以考虑用策略模式。而如果是普通的前后累积的代码很长，要不试试责任链模式？当拆完之后，原本的非常长的不好测的方法变成若干个易测的小方法。覆盖率自然就上去了。</p>
<h2 id="4-结语">4. 结语</h2>
<p>当每层代码都经过单元测试确保自己这层没问题之后，整个逻辑的链条其实问题不大了。覆盖率不是简简单单为了覆盖而覆盖，单元测试都要有断言，就是如果跟测试目的产生不一致的结果这个测试必须显示失败，否则光数据好看是没用的。<strong>单元测试也不可能做到100%覆盖，但是可以尽可能做得高</strong>，覆盖不到的地方再通过集成测试或者系统层面的测试去做。至于做不到100%覆盖的原因，比如代码里有对外部依赖的地方，再怎么抽离，总有地方需要去初始化。那么对于这个情况，尽可能把这个对外依赖范围缩小，其他地方用的时候传递接口。</p>
<p>关于面向接口编程和减少耦合，还可以了解下依赖注入，能帮助解耦调用模块和具体实现类模块。</p>
<p>为了代码可扩展性高、良好设计、易测试，可能会出现一个复杂业务逻辑的代码一层套一层的情况，一个逻辑看完可能经历了若干个类，这也是人们常常吐槽的Java这种语言的一个“啰嗦”之处。这个我也没有什么更好的想法，如果你有，可以分享一下。</p>

            </div>
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Goroyal
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="http://goroyal.github.io/post/wring-code-from-unit-test-side/" title="以单元测试的角度聊聊写代码">http://goroyal.github.io/post/wring-code-from-unit-test-side/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="http://goroyal.github.io/tag/en071zNCj/"># Programming</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Try with closable resources" href="http://goroyal.github.io/post/Try with closable resources/">Try with closable resources</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Try with closable resources" href="http://goroyal.github.io/post/Try with closable resources/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="HTTP 响应状态码" href="http://goroyal.github.io/post/http-response-code/">HTTP 响应状态码</a>
        <a class="nav-mobile-next" title="HTTP 响应状态码" href="http://goroyal.github.io/post/http-response-code/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
    <footer class="footer">
        <div class="copyright">
        </div>
        <div class="poweredby">
            Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2015-2020
        </div>
    </footer>
    
        
                <div class="gemini back-to-top" id="back_to_top">
                    <i class="fa fa-arrow-up"></i>
                    
                        <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
                        </span>
                        
                </div>
                
                            
                                        
</div>
<script>
    let sideBarOpen = 'sidebar-open';
    let body = document.body;
    let back2Top = document.querySelector('#back_to_top'),
        back2TopText = document.querySelector('#back_to_top_text'),
        drawerBox = document.querySelector('#drawer_box'),
        rightSideBar = document.querySelector('.sidebar'),
        viewport = document.querySelector('body');

    function scrollAnimation(currentY, targetY) {

        let needScrollTop = targetY - currentY
        let _currentY = currentY
        setTimeout(() => {
            const dist = Math.ceil(needScrollTop / 10)
            _currentY += dist
            window.scrollTo(_currentY, currentY)
            if (needScrollTop > 10 || needScrollTop < -10) {
                scrollAnimation(_currentY, targetY)
            } else {
                window.scrollTo(_currentY, targetY)
            }
        }, 1)
    }

    back2Top.addEventListener("click", function(e) {
        scrollAnimation(document.scrollingElement.scrollTop, 0);
        e.stopPropagation();
        return false;
    });

    window.addEventListener('scroll', function(e) {
        let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
        if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
            back2Top.classList.add('back-top-active');
        }
        if (percent == 0) {
            back2Top.classList.remove('back-top-active');
        }
        if (back2TopText) {
            back2TopText.textContent = Math.floor(percent);
        }
    });


    let hasCacu = false;
    window.onresize = function() {
        if (window.width > 991) {
            calcuHeight();
        } else {
            hasCacu = false;
        }
    }

    function calcuHeight() {
        // 动态调整站点概览高度
        if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
            let sideBar = document.querySelector('.sidebar');
            let navUl = document.querySelector('#site_nav');
            sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
            hasCacu = true;
        }
    }
    calcuHeight();

    let open = false,
        MOTION_TIME = 300,
        RIGHT_MOVE_DIS = '320px';

    if (drawerBox) {
        let rightMotions = document.querySelectorAll('.right-motion');
        let right = drawerBox.classList.contains('right');

        let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

        let openProp, closeProp;
        if (right) {
            openProp = {
                paddingRight: RIGHT_MOVE_DIS
            };
            closeProp = {
                paddingRight: '0px'
            };
        } else {
            openProp = {
                paddingLeft: RIGHT_MOVE_DIS
            };
            closeProp = {
                paddingLeft: '0px'
            };
        }

        drawerBox.onclick = function() {
            open = !open;
            window.Velocity(rightSideBar, 'stop');
            window.Velocity(viewport, 'stop');
            window.Velocity(rightMotions, 'stop');
            if (open) {
                window.Velocity(rightSideBar, {
                    width: RIGHT_MOVE_DIS
                }, {
                    duration: MOTION_TIME,
                    begin: function() {
                        window.Velocity(rightMotions, transitionDir, {});
                    }
                })
                window.Velocity(viewport, openProp, {
                    duration: MOTION_TIME
                });
            } else {
                window.Velocity(rightSideBar, {
                    width: '0px'
                }, {
                    duration: MOTION_TIME,
                    begin: function() {
                        window.Velocity(rightMotions, {
                            opacity: 0
                        });
                    }
                })
                window.Velocity(viewport, closeProp, {
                    duration: MOTION_TIME
                });
            }
            for (let i = 0; i < drawerBox.children.length; i++) {
                drawerBox.children[i].classList.toggle('muse-line');
            }
            drawerBox.classList.toggle(sideBarOpen);
        }
    }

    // 链接跳转
    let newWindow = 'false'
    if (newWindow === 'true') {
        let links = document.querySelectorAll('.post-body a')
        links.forEach(item => {
            if (!item.classList.contains('btn')) {
                item.setAttribute("target", "_blank");
            }
        })
    }

    let faSearch = document.querySelector('#fa_search');
    faSearch.addEventListener('click', function() {
        document.querySelector('#search_mask').style = ''
    })

    // 代码高亮
    hljs.initHighlightingOnLoad();
</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/msbuild-xue-xi/"" data-c="
          &lt;p&gt;MSBuild是.NET平台下的构建工具。&lt;/p&gt;
&lt;h1 id=&#34;概览&#34;&gt;概览&lt;/h1&gt;
&lt;p&gt;MSBuild也就是用于构建应用的Microsoft Build Engine，它提供一个XML Schema用于project文件来控制构建平台process、build软件。&lt;br&gt;
可以使用Visual Studio或者调用MSBuild.exe来完成这个操作。VS里边的project文件（&lt;code&gt;.csproj&lt;/code&gt;、&lt;code&gt;vbproj&lt;/code&gt;、&lt;code&gt;vcxproj&lt;/code&gt;等）包含MSBuild XML代码，这些代码将在使用IDE build project的时候被运行。&lt;/p&gt;
&lt;p&gt;在VS 2017里面使用的MSBuild版本是15，现在MSBuild装在VS的每个版本的文件夹中，比如&lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild&lt;/code&gt;。也可以使用这个powershell命令来定位MSBuild：&lt;a href=&#34;https://github.com/Microsoft/vssetup.powershell&#34;&gt;&lt;code&gt;vssetup.powershell&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSBuildToolsPath&lt;/code&gt;不再是一个固定的位置。默认情况下将是相对于VS安装位置的&lt;code&gt;MSBuild\15.0\Bin&lt;/code&gt;文件夹中。&lt;/p&gt;
&lt;h2 id=&#34;msbuild的相关概念&#34;&gt;MSBuild的相关概念&lt;/h2&gt;
&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;
&lt;p&gt;Properties是键值对，可以用来配置builds。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;BuildDir&amp;gt;Build&amp;lt;/BuildDir&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在整个project文件中，properties通过&lt;code&gt;$(&amp;lt;PropertyName&amp;gt;)&lt;/code&gt;的方式被引用，比如使用上面的BuildDir属性，则用&lt;code&gt;$(BuildDir)&lt;/code&gt;即可。&lt;br&gt;
Properties的值可以被redefine。&lt;/p&gt;
&lt;p&gt;MSBuild中保留的或众所周知的properties：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MSBuildBinPath&lt;/code&gt;: 当前使用的MSBuild binaries位置的绝对路径，例如&lt;code&gt;C:\Windows\Microsoft.Net\Framework\&amp;lt;versionNumber&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MSBuildExtensionsPath&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MSBuildProjectFile&lt;/code&gt;: project文件的完整文件名，例如&lt;code&gt;MyApp.proj&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的见&lt;a href=&#34;https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2017&#34;&gt;MSBuild reserved and well-known properties&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;Condition&lt;/code&gt; attribute来为一个property提供默认值，如果这个property没有value则给它设置一个。比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;ToolsPath Condition=&amp;quot;&#39;&#39;$(TOOLSPATH)&#39; == &#39;&#39;&amp;quot;&amp;gt;c:\tools&amp;lt;/ToolsPath&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了在project文件中做配置，也可以在命令行执行的时候设置property。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;msbuild file.proj -property:Flavor=Debug
msbuild file.proj -p:Flavor=Debug
msbuild file.proj -p:Flavor=Debug;Platform=x86
msbuild file.proj -p:Flavor=Debug -p:Platform=x86
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;环境变量也会被认为是properties，并且自动被MSBuild装载进来。&lt;/p&gt;
&lt;h3 id=&#34;items&#34;&gt;Items&lt;/h3&gt;
&lt;p&gt;Items是build system的输入，通常代表文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;Compile Include = &amp;quot;file1.cs&amp;quot;/&amp;gt;
    &amp;lt;Compile Include = &amp;quot;file2.cs&amp;quot;/&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;file2.cs是append在file1.cs之后的，也可以结合&lt;code&gt;**&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;？&lt;/code&gt;用wildcard模式，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;CSFile Include=&amp;quot;*.cs&amp;quot;/&amp;gt;
或者
&amp;lt;ItemGroup&amp;gt; 
    &amp;lt;CSFile Include=&amp;quot;*.cs&amp;quot; Exclude=&amp;quot;DoNotBuild.cs&amp;quot;/&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;targets&#34;&gt;Targets&lt;/h3&gt;
&lt;p&gt;解释如何将tasks以特定的顺序组合到一起，并在命令行调用构建过程的各个部分。&lt;br&gt;
感觉类似Ant的targets。详细的见&lt;a href=&#34;https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets?view=vs-2017&#34;&gt;MSBuild targets&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;tasks&#34;&gt;Tasks&lt;/h3&gt;
&lt;p&gt;显示如何创建可以被MSBuild使用的可执行代码单元去执行原子的build操作。&lt;/p&gt;
&lt;h3 id=&#34;special-characters&#34;&gt;Special Characters&lt;/h3&gt;
&lt;p&gt;% $ @ &#39; ; ? *&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2017&#34;&gt;微软官方文档：MSBuild&lt;/a&gt;&lt;/p&gt;
">MSBuild学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/inverted-index/"" data-c="
          &lt;p&gt;Inverted Index, 也就是反向索引（倒排索引）。反向索引结构是典型的搜索引擎算法重要的部分。&lt;/p&gt;
&lt;p&gt;常规的索引是文档到关键词的映射，但是这样的话检索关键词会比较慢，需要遍历一个又一个的文档。反向索引是从关键词到文档，这样可以根据关键词找到它在哪个文档里出现。&lt;/p&gt;
&lt;p&gt;一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档吗。&lt;/p&gt;
&lt;p&gt;以英文为例，下面是要被索引的文本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T0 = &amp;quot;it is what it is&amp;quot;
T1 = &amp;quot;what is it&amp;quot;
T2 = &amp;quot;it is a banana&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以得到下列的反向文件索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;a&amp;quot;: {2}
&amp;quot;banana&amp;quot;: {2}
&amp;quot;it&amp;quot;: {0, 1, 2}
&amp;quot;is&amp;quot;: {0, 1, 2}
&amp;quot;what&amp;quot;: {0, 1}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以在反向索引里面加上单词出现的位置，比如&lt;code&gt;&amp;quot;banana&amp;quot;: {(2, 3)}&lt;/code&gt;表示banana出现在第三个文本的第四个位置。&lt;/p&gt;
&lt;p&gt;反向索引在ElasticSearch里面也被使用到（Lucene)。假设有2个文档，文档的&lt;code&gt;content&lt;/code&gt;域包含下列内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The quick brown fox jumped over the lazy dog&lt;/li&gt;
&lt;li&gt;Quick brown foxes leap over lazy dogs in summer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了创建反向索引，首先将每个文档的&lt;code&gt;content&lt;/code&gt;拆分成词（称为&lt;code&gt;词条&lt;/code&gt;或&lt;code&gt;token&lt;/code&gt;），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Term&lt;/th&gt;
&lt;th&gt;Doc_1&lt;/th&gt;
&lt;th&gt;Doc_2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Quick&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;The&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;brown&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dog&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dogs&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fox&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;foxes&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jumped&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lazy&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leap&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;over&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quick&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;summer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;the&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果我们想搜索&lt;code&gt;quick brown&lt;/code&gt;，我们只需要查找包含每个词条的文档：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Term&lt;/th&gt;
&lt;th&gt;Doc_1&lt;/th&gt;
&lt;th&gt;Doc_2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;brown&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quick&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;两个文档都匹配，但是第一个文档比第二个匹配度更高。当然了，上面的反向索引存在点问题，比如&lt;code&gt;Quick&lt;/code&gt;和&lt;code&gt;quick&lt;/code&gt;，&lt;code&gt;dogs&lt;/code&gt;和&lt;code&gt;dog&lt;/code&gt;，可以作为相同词根进行索引，但还是不够的，需要进一步&lt;a href=&#34;https://www.elastic.co/guide/cn/elasticsearch/guide/current/analysis-intro.html&#34;&gt;分析&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&#34;&gt;维基百科&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html&#34;&gt;ElasticSearch文档&lt;/a&gt;&lt;/p&gt;
">Inverted Index</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/jvm-lei-jia-zai-ji-zhi/"" data-c="
          &lt;p&gt;Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。如编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。&lt;/p&gt;
&lt;p&gt;类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段，其中验证、准备、解析三个部分统称为连接。&lt;/p&gt;
&lt;p&gt;加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，累的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。&lt;/p&gt;
&lt;p&gt;对于初始化阶段，虚拟机规范严格规定有且只有5种情况必须对类立即进行”初始化“（加载、验证、准备自然需要在此之前开始）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遇到new、getstatic、putstatic、invokestatic这4条指令码时，如果类没有进行过初始化，则需要先触发其初始化。这4个常见的Java代码场景：使用new关键字实例化对象时、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候、调用一个类的静态方法时。&lt;/li&gt;
&lt;li&gt;使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要。。&lt;/li&gt;
&lt;li&gt;当初始化一个类时，如果发现其父类还没有进行过初始化，需要。。&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），需要。。&lt;/li&gt;
&lt;li&gt;当使用JDK 1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加载类的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过一个类的全限定名来获取定义此类的二进制字节流&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非数组类的加载是开发者可控性最强的，加载阶段既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器去完成。&lt;/p&gt;
&lt;p&gt;对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，是由Java虚拟机直接创建的。但数组类与类加载器仍有密切关系，因为数组类的元素类型最终是要靠类加载器去创建。一个数组类（下称为C）创建过程遵循以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数组的组件类型（指的是数组去掉一个维度的类型）是引用类型，那就递归去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。（一个类必须与类加载器一起确定唯一性）&lt;/li&gt;
&lt;li&gt;如果数组的组件类型不是引用类型（如int[]），Java虚拟机将会把数组C标记为与引导类加载器关联。&lt;/li&gt;
&lt;li&gt;数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;类加载器：&lt;/strong&gt;&lt;br&gt;
虚拟机设计团队把”通过一个类的全限定名来获取此类的二进制字节流“这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为”类加载器“。&lt;/p&gt;
&lt;p&gt;类加载器可以说是java语言的一项创新，它在类层次划分、OSGi、热部署、代码加密等领域大放异彩。&lt;/p&gt;
&lt;p&gt;每一个类加载器都拥有一个独立的类名称空间，比较两个类是否”相等“，只有这两个类是由同一个类加载器加载的前提下才有意义。这里的相等，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括instanceOf关键字做对象所属关系判定等情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双亲委派模型：&lt;/strong&gt;&lt;br&gt;
从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器在Hotspot虚拟机中使用C++实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader。&lt;/p&gt;
&lt;p&gt;从开发人员角度看，大部分Java程序都会使用以下3种系统提供的类加载器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动类加载器，它复杂将$JAVA_HOME/lib中的并且是虚拟机识别的（仅按照文件名识别，如rt.jar）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。&lt;/li&gt;
&lt;li&gt;扩展类加载器，负责加载$JAVA_HOME/lib/ext中的所有类库，开发者可以直接使用扩展类加载器&lt;/li&gt;
&lt;li&gt;应用程序类加载器，它是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果app中没有自定义过，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类加载器的双亲委派模型，除了要求顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合关系来复用父加载器代码。&lt;br&gt;
自定义类加载器-&amp;gt;应用程序类加载器-&amp;gt;扩展类加载器-&amp;gt;启动类加载器&lt;/p&gt;
&lt;p&gt;双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去 尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;
&lt;p&gt;使用双亲委派模型来组织类加载器之间的关系的显而易见的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。如类java.lang.Object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器去加载，因此Object类在程序的各种累加载器环境中都是同一个类。&lt;/p&gt;
&lt;p&gt;破坏双亲委派模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 1.2之前的loadClass方法，后期为了兼容性做了妥协&lt;/li&gt;
&lt;li&gt;JDNI服务，它的代码由启动类加载器去加载，但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的Classpath下的JNDI接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能”认识”这些代码，怎么处理？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决JNDI的问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader），这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那么这个类加载器默认就是应用程序类加载器。&lt;/p&gt;
&lt;p&gt;有了线程上下文类加载器，JNDI服务使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。Java中所有涉及SPI的加载动作基本上都采用了这种方式，如JNDI、JDBC、JCE、JAXB、JBI等。&lt;/p&gt;
&lt;p&gt;双亲委派模型的第三次破坏是用户对程序动态性的追求导致的，如代码热替换、模块热部署。&lt;/p&gt;
&lt;p&gt;OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。&lt;/p&gt;
&lt;p&gt;在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。OSGi按照下面顺序进行类搜索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将以java.*开头的类委派给父类加载器加载；&lt;/li&gt;
&lt;li&gt;否则将委派列表名单内的类委派给父类加载器加载&lt;/li&gt;
&lt;li&gt;否则将import列表中的类委派给export这个类的Bundle的类加载器加载&lt;/li&gt;
&lt;li&gt;否则查找当前Bundle的Classpath，使用自己的类加载器加载&lt;/li&gt;
&lt;li&gt;否则查找类是否在自己的Fragment Bundle中，如果在，委派给Fragment Bundle的类加载器加载&lt;/li&gt;
&lt;li&gt;否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则类查找失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字节码生成技术与动态代理的实现&#34;&gt;字节码生成技术与动态代理的实现&lt;/h4&gt;
&lt;p&gt;在java里面除了javac和字节码类库外，使用字节码生成的例子还有很多，如Web服务器中的JSP编译器，编译时植入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。我们选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的。&lt;br&gt;
即使没有直接用过java.lang.reflect.Proxy或实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况都会用过动态代理，因为如果Bean是面向接口编程，那么在Spring内部都是通过动态代理的方式来对Bean进行增强的。动态代理中所谓的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的。它的优势不在于省去了编写代理类那一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类和原始类脱离直接联系后，就可以很灵活地重用与不同的应用场景之中。&lt;/p&gt;
&lt;p&gt;下面是最简单的动态代理用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class DynamicProxyTest {
	interface IHello {
		void sayHello();
	}
	
	static class Hello implements IHello {
		@Override
		public void sayHello() {
			System.out.println(&amp;quot;hello world&amp;quot;);
		}
	}
	
	static class DynamicProxy implements InvocationHandler {
		Object originalObj;
		Object bind(Object originalObj){
			this.originalObj = originalObj;
			return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);
		}
		
		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			System.out.println(&amp;quot;welcome&amp;quot;);
			return method.invoke(originalObj, args);
		}
	}
	
	public static void main(String[] args) {
		IHello hello = (IHello) new DynamicProxy().bind(new Hello());
		hello.sayHello();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;welcome
hello world
``
上述代码里唯一的“黑匣子”就是Proxy.newProxyInstance()方法，除此之外再没有任何特殊之处。这个方法返回了一个实现了IHello的接口，并且代理了new Hello()实例行为的对象。跟踪这个方法的源码可以看到程序进行了验证、优化、缓存、同步、生成字节码、显示类加载等操作，最后它调用了sun.misc.ProxyGenerator.generateProxyClass()方法来完成了字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码byte[]数组。如果想看这个在运行时产生的代理类中写了什么，可以在main()方法加入：

``` Java
System.getProperties().put(&amp;quot;sun.misc.ProxyGenerator.saveGeneratedFiles&amp;quot;, true)；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反编译后的代理类实现里面，为传入接口的每个方法以及从Object类继承的equals()、hashCode()、toString()方法都生成了对应的实现，并且统一调用了InvocationHandler对象的invoke()方法来实现这些方法的内容，这个方法的区别不过是传入的参数和Method对象有所不同而已。所以无论调用动态代理的哪一个方法，实际上都是在执行InvocationHandler.invoke()中的代理逻辑。&lt;/p&gt;
">JVM类加载机制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/jvm-la-ji-shou-ji-qi/"" data-c="
          &lt;p&gt;常用垃圾收集器：G1，CMS等&lt;/p&gt;
&lt;h2 id=&#34;serial收集器&#34;&gt;Serial收集器&lt;/h2&gt;
&lt;p&gt;单线程的收集器，它的单线程的意义不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。&lt;/p&gt;
&lt;p&gt;Serial在新生代使用复制算法。Serial Old在老生代使用标记-整理算法。&lt;/p&gt;
&lt;p&gt;虽然到后期的垃圾收集器，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除。&lt;/p&gt;
&lt;p&gt;到目前为止，Serial收集器仍然是虚拟机运行在Client模式下的默认新生代收集器。&lt;/p&gt;
&lt;h2 id=&#34;parnew收集器&#34;&gt;ParNew收集器&lt;/h2&gt;
&lt;p&gt;Serial收集器的多线程版本。&lt;br&gt;
ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有个预性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是Hotspot虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。但是CMS作为老年代收集器却无法与JDK 1.4已经存在的新生代收集器Parallel Scavenge配合工作。&lt;/p&gt;
&lt;p&gt;ParNew收集器是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UserParNewGC选项来强制指定它。&lt;/p&gt;
&lt;p&gt;ParNew在单CPU环境中绝对不会有比Serial收集器更好的效果，甚至存在由于线程交互的开销。&lt;/p&gt;
&lt;h2 id=&#34;parallel-scavenge收集器&#34;&gt;Parallel Scavenge收集器&lt;/h2&gt;
&lt;p&gt;新生代收集器，也是使用复制算法、并行的多线程收集器。它的特点是关注点与其他收集器不同，CMS等收集器关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量（Throughput）。所谓吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。&lt;/p&gt;
&lt;p&gt;停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。&lt;/p&gt;
&lt;p&gt;该收集器提供了两个参数用于精确控制吞吐量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-XX:MAXGCPauseMillis：控制最大垃圾收集停顿时间&lt;/li&gt;
&lt;li&gt;-XX:GCTimeRatio：直接设置吞吐量大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Parallel Old是它在老年代的版本，使用多线程和标记-整理算法。&lt;/p&gt;
&lt;h2 id=&#34;cms收集器&#34;&gt;CMS收集器&lt;/h2&gt;
&lt;p&gt;Current Mark Sweep，一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。整个过程分为四步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;重新标记&lt;/li&gt;
&lt;li&gt;并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初始标记和重新标记仍需要Stop The World。初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快。并发标记就是进校GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短。&lt;/p&gt;
&lt;p&gt;CMS是一款优秀的收集器，但是3个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对CPU资源非常敏感&lt;/li&gt;
&lt;li&gt;无法处理浮动垃圾&lt;/li&gt;
&lt;li&gt;是一款基于标记-清除算法的收集器，会有空间碎片产生&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;g1收集器garbage-first&#34;&gt;G1收集器（Garbage First）&lt;/h2&gt;
&lt;p&gt;并行与并发&lt;br&gt;
分代收集&lt;br&gt;
空间整合：G1整体来看是标记-整理，局部来看是基于复制算法。&lt;br&gt;
可预测的停顿&lt;/p&gt;
&lt;p&gt;大致分为以下几步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;最终标记&lt;/li&gt;
&lt;li&gt;筛选回收&lt;/li&gt;
&lt;/ul&gt;
">JVM垃圾收集器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/jvm-nei-cun-yi-chu/"" data-c="
          &lt;p&gt;JVM内存溢出经常有2种报错：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OutOfMemory（OOM）&lt;/li&gt;
&lt;li&gt;StackOverFlow（SOF ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError异常的可能。为了进行试验，在运行时使用以下的JVM参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;java堆溢出&#34;&gt;Java堆溢出&lt;/h2&gt;
&lt;p&gt;Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemorryError
 * 将对的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展，通过参数-XX:+HeapDumpOnOutOfMemorryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便时候进行分析
 */
public class HeapOOM {
	static class OOMObject {
	}
	
	public static void main(String[] args){
		List&amp;lt;OOMObject&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
		while(true){
			list.add(new OOMObject());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;java.lang.OutOfMemoryError: Java Heap space
Dumping heap to java_pid3404.hprof...
Heap dump file created[22045981 bytes in 0.663 secs]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息”java.lang.OutOfMemoryError“会跟着进一步提示”Java heap space“。&lt;/p&gt;
&lt;p&gt;要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（&lt;strong&gt;Memory Leak&lt;/strong&gt;）还是内存溢出（&lt;strong&gt;Memory Overflow&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;如果是内存泄露，可以进一步提高工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及GC Roots引用链的信息，就可以比较准确地定位出现泄露代码的位置。&lt;/p&gt;
&lt;p&gt;如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。&lt;/p&gt;
&lt;h2 id=&#34;虚拟机栈和本地方法栈溢出&#34;&gt;虚拟机栈和本地方法栈溢出&lt;/h2&gt;
&lt;p&gt;由于在Hotspot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于Hotspot来说，虽然-Xoss参数（用于设置本地方法栈大小）存在，但实际上是无效的。栈容量只由-Xss参数设定。在Java虚拟机规范中描述了两种异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。&lt;/li&gt;
&lt;li&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里把异常分成两种情况，看似更加严谨，但却存在一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上是对同一件事情的两种描述而已。&lt;/p&gt;
&lt;p&gt;在《深入理解Java虚拟机规范》作者的实验中，将实验范围限制于单线程中的操作，尝试了两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是StackOverflowError。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用-Xss参数减少栈内存容量。结果，抛出StackOverflowError异常，异常出现时输出的堆栈深度相应地缩小。&lt;/li&gt;
&lt;li&gt;定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * VM args: -Xss128k
 */
public class JavaVMStackOF {
	private int stackLength = 1;
	
	public void stackLeak() {
		stackLength++;
		stackLeak();
	}
	
	public static void main(String[] args) throws Throwable {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try {
			oom.stackLeak();
		} catch (Throwable e){
			System.out.println(&amp;quot;stack length:&amp;quot; + oom.stackLength);
			throw e;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stack length: 2402
Exception in thread &amp;quot;main&amp;quot; java.lang.StackOverflowError
	at....
.....后续异常堆栈信息省略
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。&lt;br&gt;
如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系。或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。&lt;br&gt;
这一点需要在开发多线程应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说大多数情况下）达到1000~2000完全没有问题。但是如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，&lt;strong&gt;这种通过”减少内存“的手段来解决内存溢出的方式会比较难以想到&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JavaVMStackOOM {
	private void dontStop() {
		while (true) {}
	}
	
	public void stackLeakByThread() {
		while(true) {
			Thread thread = new Thread(new Runnable() {
				@Override
				public void run() {
					dontStop();
				}
			});
			thread.start();
		}
	}
	public static void main(String[] args) throws Throwable {
		JavaVMStackOOM oom = new JavaVMStackOOM();
		oom.stackLeakByThread();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法区和运行时常量池溢出&#34;&gt;方法区和运行时常量池溢出&lt;/h2&gt;
&lt;p&gt;JDK 1.7开始逐步”去永久代“，此处顺便看看这件事情的实际影响。&lt;br&gt;
String.intern()是一个Native方法，作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		// 使用List保持着常量池引用，避免Full GC回收常量池行为
		List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
		// 10MB的PermSize在integer范围内足够产生OOM了
		int i = 0;
		while (true) {
			list.add(String.valueOf(i++).intern());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.OutOfMemoryError: PermGen space
	at java.lang.String.intern(Native Method)
	at ... 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从运行结果可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是”PermGen space“，说明运行时常量池属于方法区（Hotspot虚拟机中的永久代）的一部分。&lt;/p&gt;
&lt;p&gt;而使用JDK 1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RuntimeConstantsPoolOOM {
	public static void main(String[] args){
		String str1 = new StringBuilder(&amp;quot;计算机&amp;quot;).append(&amp;quot;软件&amp;quot;).toString();
		System.out.println(str1.intern() == str1);
		
		String str2 = new StringBuilder(&amp;quot;ja&amp;quot;).append(&amp;quot;va&amp;quot;).toString();
		System.out.println(str2.intern() == str2);
	}
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码在JDK 1.6中运行，会得到两个false；而在JDK 1.7中运行会得到一个true一个false。产生差异的原因是：JDK 1.6中，&lt;code&gt;intern()&lt;/code&gt;方法会把所赐遇到的字符串实例复制到永久代中，返回的也是永久代总这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。&lt;br&gt;
而在JDK 1.7中的&lt;code&gt;intern()&lt;/code&gt;实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此&lt;code&gt;intern()&lt;/code&gt;返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为&amp;quot;java&amp;quot;这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量中已经有它的引用额，不符合”首次出现“的原则，而”计算机软件“这个字符串则是首次出现的。&lt;/p&gt;
&lt;p&gt;方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当前的很多主流框架如Spring、Hibernate对类进行增强时都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。像大量反射、大量JSP文件或动态产生JSP文件的应用、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）也会需要较大的方法区保证。&lt;/p&gt;
&lt;h2 id=&#34;本机直接内存溢出&#34;&gt;本机直接内存溢出&lt;/h2&gt;
&lt;p&gt;DirectMemory容量可以通过&lt;code&gt;-XX:MaxDirectMemory&lt;/code&gt;指定，如果不指定则默认与Java堆最大值一样。如下代码越过了DirectByBuffer类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配于是手动抛出异常，真正申请分配内存的方法是&lt;code&gt;unsafe.allocateMemory()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
 */
public class DirectMemoryOOM {
	private static final int _1MB = 1024 * 1024;
	
	public static void main(String[] args) throws Exception {
		Field unsafeField = Unsafe.class.getDeclaredFields()[0];
		unsafeField.setAccessible(true);
		Unsafe unsafe = (Unsafe) unsafeField.get(null);
		while(true) {
			unsafe.allocateMemory(_1MB);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.OutOfMemoryError
	at ...
&lt;/code&gt;&lt;/pre&gt;
">JVM内存溢出</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/jvm-gc/"" data-c="
          &lt;h2 id=&#34;引用计数法&#34;&gt;引用计数法&lt;/h2&gt;
&lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。&lt;br&gt;
客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下他都是一个不错的算法）。&lt;br&gt;
但是至少主流的Java虚拟机里没有选用该方法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。&lt;/p&gt;
&lt;h2 id=&#34;可达性分析算法&#34;&gt;可达性分析算法&lt;/h2&gt;
&lt;p&gt;这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。&lt;/p&gt;
&lt;p&gt;在Java语言中，可作为GC Roots的对象包括下面几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI（即一般说的Native方法）引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标记-清除算法&#34;&gt;标记-清除算法&lt;/h2&gt;
&lt;p&gt;首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。&lt;/p&gt;
&lt;p&gt;它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。&lt;/p&gt;
&lt;p&gt;它的主要不足有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率问题，标记和清除两个过程的效率都不高&lt;/li&gt;
&lt;li&gt;空间问题，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;复制算法&#34;&gt;复制算法&lt;/h2&gt;
&lt;p&gt;为了解决效率问题，一种称为”复制“的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;
&lt;p&gt;这种算法的代价是将内存缩小为原来的一半，未免太高了一点。&lt;/p&gt;
&lt;p&gt;现在的商业虚拟机都采用这种收集算法来回收新生代。IBM公司的专门研究表明，新生代中的对象98%是”朝生夕死“的，所以不需要按照1：1的比例来划分内存空间，而是将一块内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Hotspot虚拟机默认Eden和Survivor大小比例是8：1。&lt;/p&gt;
&lt;p&gt;当然，我们也没有办法保证每次回收都只有不多于10%对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。&lt;/p&gt;
&lt;h2 id=&#34;标记-整理算法&#34;&gt;标记-整理算法&lt;/h2&gt;
&lt;p&gt;复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。&lt;/p&gt;
&lt;p&gt;根据老年代的特点，有人提出标记-整理算法，标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。&lt;/p&gt;
&lt;h2 id=&#34;分代收集算法&#34;&gt;分代收集算法&lt;/h2&gt;
&lt;p&gt;当前商业虚拟机的垃圾收集都采用”分代收集“算法，这种算法根据对象存活周期的不同将内存分为几块。一般是把Java堆分为新生代和老生代。&lt;/p&gt;
">JVM GC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-memory-model/"" data-c="
          &lt;p&gt;在多核系统中，处理器一般有一层或者多层的缓存，这些的缓存通过加速数据访问（因为数据距离处理器更近）和降低共享内存在总线上的通讯（因为本地缓存能够满足很多内存操作）来提高CPU性能。缓存能够大大提升性能，但是它们也带来了许多挑战。例如，当两个CPU同时检查相同的内存地址时会发生什么？在什么样的条件下它们会看到相同的值？&lt;/p&gt;
&lt;p&gt;在处理器层面上，内存模型定义了一个充要条件：“让当前的处理器可以看到其他的处理器写入到内存数据”以及“其他处理器可以看到当前处理器写入到内存的数据”。有些处理器有很强的内存模型（strong memory model），能够让所有的处理器在任何时候任何指定的内存地址上都可以看到完全相同的值。而另外一些处理器则有较弱的内存模型（weaker memory model），在这种处理器中，必须使用内存屏障（一种特殊的指令）来刷新本地处理器缓存并使本地处理器缓存无效，目的是为了让当前处理器能够看到其他处理器的写操作或者让其他处理器能看到当前处理器的写操作。这些内存屏障通常在lock和unlock操作的时候完成。内存屏障在高级语言中对程序员是不可见的。&lt;/p&gt;
&lt;p&gt;在强内存模型下，有时候编写程序可能会更容易，因为减少了对内存屏障的依赖。但是即使在一些最强的内存模型下，内存屏障仍然是必须的。设置内存屏障往往与我们的直觉并不一致。进来处理器设计的趋势更倾向于弱的内存模型，因为弱内存模型削弱了缓存一致性，所以在多处理器平台和更大容量的内存下可以实现更好的可伸缩性。&lt;/p&gt;
&lt;p&gt;“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反应了缓存的影响。&lt;/p&gt;
&lt;p&gt;此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其性能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。&lt;/p&gt;
&lt;h2 id=&#34;哪个区域存放哪些内容&#34;&gt;哪个区域存放哪些内容&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;方法区：各个线程的共享区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。习惯在Hotspot虚拟机上的开发者很多人把方法区成为“永久代”。&lt;/li&gt;
&lt;li&gt;虚拟机栈：线程私有的，描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口灯信息。每一个方法从调研直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译器可知的各种基本数据类型、对象引用和redurnAddress类型。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;li&gt;本地方法栈：与虚拟机栈类似，但是本地方法栈为虚拟机使用到的Native方法服务。&lt;/li&gt;
&lt;li&gt;堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。是垃圾收集器管理的主要区域。&lt;/li&gt;
&lt;li&gt;程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。&lt;/li&gt;
&lt;li&gt;直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。JDK 1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。&lt;/li&gt;
&lt;/ul&gt;
">Java内存模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-volatile/"" data-c="
          &lt;h2 id=&#34;volatile语义&#34;&gt;volatile语义&lt;/h2&gt;
&lt;p&gt;一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。&lt;/li&gt;
&lt;li&gt;禁止进行指令重排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class VolatileExample extends Thread{
    //设置类静态变量,各线程访问这同一共享变量
    private  static boolean flag = false;
    //无限循环,等待flag变为true时才跳出循环
   public void run() {
       while (!flag){
       };
       System.out.println(&amp;quot;停止了&amp;quot;);
   }

    public static void main(String[] args) throws Exception {
        new VolatileExample().start();
        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了
        Thread.sleep(100);
        flag = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当把上面代码中变量flag改成下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private  static valotile boolean flag = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行的话，你就会发现打印了“停止了”信息，因为用volatile修饰之后就变得不一样了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一：使用volatile关键字会强制将修改的值立即写入主存；&lt;/li&gt;
&lt;li&gt;第二：使用volatile关键字的话，当线程main进行修改时，会导致线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；&lt;/li&gt;
&lt;li&gt;第三：由于线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效，所以线程那么线程VolatileExample再次读取变量flag的值时会去主存读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么在线程main修改flag值时（当然这里包括2个操作，修改线程main工作内存中的值，然后将修改后的值写入内存），会使得线程VolatileExample的工作内存中缓存变量flag的缓存行无效，然后线程读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。&lt;/p&gt;
&lt;p&gt;那么线程VolatileExample读取到的就是最新的正确的值。&lt;br&gt;
使用volatile关键字增加了实例变量在多个线程之间的可见性。但是volatile关键字最致命的缺点是不支持原子性。&lt;/p&gt;
&lt;p&gt;下面将关键字synchronized和volatile进行一下比较：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。&lt;/li&gt;
&lt;li&gt;多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。&lt;/li&gt;
&lt;li&gt;volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它将私有内存和公共内存中的数据做同步。&lt;/li&gt;
&lt;li&gt;再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;volatile非原子的特性&#34;&gt;volatile非原子的特性&lt;/h2&gt;
&lt;p&gt;从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？&lt;br&gt;
下面看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
         
         //保证前面的线程都执行完
        while(Thread.activeCount()&amp;gt;1)
   			Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也许有些朋友认为输出结果是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。可能有人会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。&lt;/p&gt;
&lt;p&gt;这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。&lt;/p&gt;
&lt;p&gt;在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：&lt;/p&gt;
&lt;p&gt;假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；&lt;/p&gt;
&lt;p&gt;然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值是10，然后进行加1操作，并把11写入工作内存，最后写入主存。&lt;/p&gt;
&lt;p&gt;然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。&lt;/p&gt;
&lt;p&gt;那么两个线程分别进行了一次自增操作后，inc只增加了1。&lt;/p&gt;
&lt;p&gt;虽然happens-before规则中的volatile变量规则是保证一个变量在修改volatile变量时，会让缓存行无效吗，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把上面的代码改成以下任何一种都可以达到效果：&lt;br&gt;
采用synchronized：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public  int inc = 0;
    
    public synchronized void increase() {
        inc++;
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&amp;gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;采用Lock：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();
    
    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&amp;gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;采用AtomicInteger：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Test {
    public  AtomicInteger inc = new AtomicInteger();
     
    public  void increase() {
        inc.getAndIncrement();
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&amp;gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。&lt;/p&gt;
&lt;h2 id=&#34;volatile能保证有序性&#34;&gt;volatile能保证有序性&lt;/h2&gt;
&lt;p&gt;在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。&lt;/p&gt;
&lt;p&gt;volatile关键字禁止指令重排序有两层意思：&lt;br&gt;
1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；&lt;/p&gt;
&lt;p&gt;2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。&lt;br&gt;
可能上面说的比较绕，举个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。&lt;/p&gt;
&lt;h2 id=&#34;volatile的原理和实现机制&#34;&gt;volatile的原理和实现机制&lt;/h2&gt;
&lt;p&gt;前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。&lt;/p&gt;
&lt;p&gt;下面这段话摘自《深入理解Java虚拟机》：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。&lt;br&gt;
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；&lt;/li&gt;
&lt;li&gt;它会强制将对缓存的修改操作立即写入主存；&lt;/li&gt;
&lt;li&gt;如果是写操作，它会导致其他CPU中对应的缓存行无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对变量的写操作不依赖于当前值&lt;/li&gt;
&lt;li&gt;该变量没有包含在具有其他变量的不变式中&lt;/li&gt;
&lt;/ul&gt;
">Java volatile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-thread-feature/"" data-c="
          &lt;h2 id=&#34;原子性&#34;&gt;原子性&lt;/h2&gt;
&lt;p&gt;在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。&lt;br&gt;
上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：&lt;br&gt;
请分析以下哪些操作是原子性操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。&lt;/p&gt;
&lt;p&gt;语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。所以上面4个语句只有语句1的操作具备原子性。&lt;/p&gt;
&lt;p&gt;也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。&lt;/p&gt;
&lt;p&gt;不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。&lt;/p&gt;
&lt;p&gt;从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。&lt;/p&gt;
&lt;h2 id=&#34;可见性&#34;&gt;可见性&lt;/h2&gt;
&lt;p&gt;对于可见性，Java提供了&lt;code&gt;volatile&lt;/code&gt;关键字来保证可见性。&lt;/p&gt;
&lt;p&gt;当一个共享变量被&lt;code&gt;volatile&lt;/code&gt;修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。&lt;/p&gt;
&lt;p&gt;而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。&lt;/p&gt;
&lt;p&gt;另外，通过&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;也能够保证可见性，&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。&lt;/p&gt;
&lt;h2 id=&#34;有序性&#34;&gt;有序性&lt;/h2&gt;
&lt;p&gt;在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。&lt;br&gt;
在Java里面，可以通过&lt;code&gt;volatile&lt;/code&gt;关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;来保证有序性，很显然，&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。&lt;/p&gt;
&lt;p&gt;另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。&lt;/p&gt;
&lt;h3 id=&#34;happens-before原则先行发生原则&#34;&gt;happens-before原则（先行发生原则）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作&lt;/li&gt;
&lt;li&gt;锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作&lt;/li&gt;
&lt;li&gt;volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作&lt;/li&gt;
&lt;li&gt;传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C&lt;/li&gt;
&lt;li&gt;线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作&lt;/li&gt;
&lt;li&gt;线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生&lt;/li&gt;
&lt;li&gt;线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行&lt;/li&gt;
&lt;li&gt;对象终结规则：一个对象的初始化完成先行发生于它的&lt;code&gt;finalize()&lt;/code&gt;方法的开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这8条原则摘自《深入理解Java虚拟机》。&lt;br&gt;
这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。&lt;/p&gt;
&lt;p&gt;下面我们来解释一下前4条规则：&lt;br&gt;
对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。&lt;/p&gt;
&lt;p&gt;第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。&lt;/p&gt;
&lt;p&gt;第三条规则是一条比较重要的规则，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。&lt;/p&gt;
&lt;p&gt;第四条规则实际上就是体现happens-before原则具备传递性。&lt;/p&gt;
">Java 线程中的3个特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-lock/"" data-c="
          &lt;h2 id=&#34;锁状态&#34;&gt;锁状态&lt;/h2&gt;
&lt;p&gt;Java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁自旋&lt;/strong&gt;&lt;br&gt;
我们知道在当某个线程在进入同步方法/代码块时若发现该同步方法/代码块被其他现在所占，则它就要等待，进入阻塞状态，这个过程性能是低下的。&lt;/p&gt;
&lt;p&gt;在遇到锁的争用或许等待事，线程可以不那么着急进入阻塞状态，而是等一等，看看锁是不是马上就释放了，这就是锁自旋。锁自旋在一定程度上可以对线程进行优化处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;br&gt;
偏向锁主要为了解决在没有竞争情况下锁的性能问题。在大多数情况下锁锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当某个线程获得锁的情况，该线程是可以多次锁住该对象，但是每次执行这样的操作都会因为CAS（CPU的Compare-And-Swap指令）操作而造成一些开销消耗性能，为了减少这种开销，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。&lt;/p&gt;
&lt;p&gt;当有其他线程在尝试着竞争偏向锁时，持有偏向锁的线程就会释放锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁膨胀&lt;/strong&gt;&lt;br&gt;
多个或多次调用粒度太小的锁，进行加锁解锁的消耗，反而还不如一次大粒度的锁调用来得高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;br&gt;
轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。轻量级锁在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的指向和状态。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。&lt;/p&gt;
&lt;h2 id=&#34;加锁方式&#34;&gt;加锁方式&lt;/h2&gt;
&lt;p&gt;在使用synchronized时，我们是这样使用锁的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadTest {
    public void test(){
        synchronized(this){
            //do something
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;synchronized可以确保在同一时间内只有一个线程在执行dosomething。下面是使用lock替代synchronized：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadTest {
    Lock lock = new Lock();
    public void test(){
        lock.lock();
        //do something
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。&lt;/p&gt;
&lt;h2 id=&#34;锁的公平性&#34;&gt;锁的公平性&lt;/h2&gt;
&lt;p&gt;公平性的对立面是饥饿。那么什么是“饥饿”呢？如果一个线程因为其他线程在一直抢占着CPU而得不到CPU运行时间，那么我们就称该线程被“饥饿致死”。而解决饥饿的方案则被称之为“公平性”——所有线程均可以公平地获得CPU运行机会。&lt;/p&gt;
&lt;p&gt;导致线程饥饿主要有如下几个原因：&lt;br&gt;
高优先级线程吞噬所有的低优先级线程的CPU时间。我们可以为每个线程单独设置其优先级，从1到10。优先级越高的线程获得CPU的时间越多。对大多数应用来说，我们最好是不要改变其优先级值。&lt;/p&gt;
&lt;p&gt;线程被永久堵塞在一个等待进入同步块的状态。Java的同步代码区是导致线程饥饿的重要因素。Java的同步代码块并不会保证进入它的线程的先后顺序。这就意味着理论上存在一个或者多个线程在试图进入同步代码区时永远被堵塞着，因为其他线程总是不断优于他获得访问权，导致它一直得到不到CPU运行机会被“饥饿致死”。&lt;/p&gt;
&lt;p&gt;线程在等待一个本身也处于永久等待完成的对象。如果多个线程处在&lt;code&gt;wait()&lt;/code&gt;方法执行上，而对其调用&lt;code&gt;notify()&lt;/code&gt;不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。&lt;/p&gt;
&lt;p&gt;为了解决线程“饥饿”的问题，我们可以使用锁实现公平性。&lt;/p&gt;
&lt;h2 id=&#34;锁的可重入性&#34;&gt;锁的可重入性&lt;/h2&gt;
&lt;p&gt;我们知道当线程请求一个由其它线程持有锁的对象时，该线程会阻塞，但是当线程请求由自己持有锁的对象时，是否可以成功呢？答案是可以成功的，成功的保障就是线程锁的“可重入性”。&lt;br&gt;
“可重入”意味着自己可以再次获得自己的内部锁，而不需要阻塞。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Father {
    public synchronized void method(){
        //do something
    }
}
public class Child extends Father{
    public synchronized void method(){
        //do something 
        super.method();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果所是不可重入的，上面的代码就会死锁，因为调用child的method(),首先会获取父类Father的内置锁然后获取Child的内置锁，当调用父类的方法时，需要再次后去父类的内置锁，如果不可重入，可能会陷入死锁。&lt;/p&gt;
&lt;p&gt;java多线程的可重入性的实现是通过每个锁关联一个请求计算和一个占有它的线程，当计数为0时，认为该锁是没有被占有的，那么任何线程都可以获得该锁的占有权。当某一个线程请求成功后，JVM会记录该锁的持有线程 并且将计数设置为1，如果这时其他线程请求该锁时则必须等待。当该线程再次请求请求获得锁时，计数会+1；当占有线程退出同步代码块时，计数就会-1，直到为0时，释放该锁。这时其他线程才有机会获得该锁的占有权。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReentrantLock：一个可重入的互斥锁，为lock接口的主要实现。&lt;/li&gt;
&lt;li&gt;ReadWriteLock：ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。&lt;/li&gt;
&lt;li&gt;ReentrantReadWriteLock：可重入读写锁&lt;/li&gt;
&lt;li&gt;Semaphore：一个计数信号量。&lt;/li&gt;
&lt;li&gt;Condition:锁的关联条件，目的是允许线程获取锁并且查看等待的某一个条件是否满足。&lt;/li&gt;
&lt;li&gt;CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。&lt;/li&gt;
&lt;/ul&gt;
">Java锁</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-synchronized/"" data-c="
          &lt;p&gt;synchronized，我们谓之锁，主要用来给方法、代码块加锁。当某个方法或者代码块使用synchronized时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。&lt;/p&gt;
&lt;p&gt;synchronized主要包括两种方法：synchronized 方法、synchronized 代码块。&lt;/p&gt;
&lt;p&gt;synchronized 方法通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized void getResult();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;synchronized方法控制对类成员变量的访问。它是如何来避免类成员变量的访问控制呢？我们知道方法使用了synchronized关键字表明该方法已加锁，在任一线程在访问改方法时都必须要判断该方法是否有其他线程在“独占”。每个类实例对应一个把锁，每个synchronized方法都必须调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，被阻塞的线程方能获得该锁。&lt;/p&gt;
&lt;p&gt;其实synchronized方法是存在缺陷的，如果我们将一个很大的方法声明为synchronized将会大大影响效率的。如果多个线程在访问一个synchronized方法，那么同一时刻只有一个线程在执行该方法，而其他线程都必须等待，但是如果该方法没有使用synchronized，则所有线程可以在同一时刻执行它，减少了执行的总时间。所以如果我们知道一个方法不会被多个线程执行到或者说不存在资源共享的问题，则不需要使用synchronized关键字。但是如果一定要使用synchronized关键字，那么我们可以synchronized代码块来替换synchronized方法。&lt;/p&gt;
&lt;p&gt;synchronized代码块所起到的作用和synchronized方法一样，只不过它使临界区变的尽可能短了，换句话说：它只把需要的共享数据保护起来，其余的长代码块留出此操作。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;synchronized(object) {  
    //允许访问控制的代码  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要以这种方式来使用synchronized关键字,那么必须要通过一个对象引用来作为参数,通常这个参数我们常使用为this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;synchronized (this) {
    //允许访问控制的代码 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于synchronized(this)有如下理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。&lt;/li&gt;
&lt;li&gt;然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问object中的非synchronized(this)同步代码块。&lt;/li&gt;
&lt;li&gt;尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其他synchronized(this)同步代码块得访问将被阻塞。&lt;/li&gt;
&lt;li&gt;第三个例子同样适用其他同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其他线程对该object对象所有同步代码部分的访问都将被暂时阻塞。&lt;/li&gt;
&lt;li&gt;以上规则对其他对象锁同样适用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java中每一个对象都可以作为锁，它主要体现在下面三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于同步方法，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;对于同步方法块，锁是Synchonized括号里配置的对象。&lt;/li&gt;
&lt;li&gt;对于静态同步方法，锁是当前对象的Class对象。&lt;/li&gt;
&lt;/ul&gt;
">Java synchronized</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/git-commands/"" data-c="
          &lt;p&gt;配置账号信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global user.name &amp;quot;your username&amp;quot;
git config --global user.email &amp;quot;your email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看配置相关的信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --list # 查看配置的信息
git help config # 获取帮助信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置自动换行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.autocrlf input # 提交到git时是否自动将换行符转换为lf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置密钥&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh-keygen -t rsa -C &amp;quot;your email&amp;quot; # 生成密钥
ssh -T git@github.com # 测试是否成功
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建仓库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git init # 初始化本地仓库
git clone &amp;lt;url&amp;gt; # 克隆远程版本库
git add –all # 添加所有文件到暂存区（stage，index）
git status # 查看当前git状态
git remote add origin https://github.com/freshdgq/test.git # 关联到远程仓库地址
git push -u origin master # 第一次推送master分支的所有内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改和提交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git status # 查看git当前状态
git diff # 查看改动后和改动前的不同之处
git add . # 跟踪所有改动过的文件
git add &amp;lt;file&amp;gt; # 跟踪指定的文件
git mv &amp;lt;old&amp;gt; &amp;lt;new&amp;gt; # 文件改名
git rm &amp;lt;file&amp;gt; # 删除指定文件
git rm --cached &amp;lt;file&amp;gt; # 停止跟踪文件但不删除
git commit -m &amp;quot;message&amp;quot; # 提交修改的文件到当前分支
git commit --amend # 修改最后一次提交
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;状态与版本处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log # 查看提交的历史记录
git log -p &amp;lt;file&amp;gt; # 查看指定文件的提交记录
git blame &amp;lt;file&amp;gt; # 以列表方式查看指定文件的提交历史
git reset --hard HEAD  # 撤销工作目录中所有未提交文件的修改内容
git checkout HEAD &amp;lt;file&amp;gt; # 撤销指定的未提交文件的修改内容
git revert &amp;lt;commit&amp;gt; 撤销指定的提交
git reset --hard HEAD^ # 回退本地分支到上一个版本
git reset --hard HEAD~n # 回退本地分支到上n个版本
git checkout – readme.txt # 把readme.txt文件在工作区的修改全部撤销
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分支与标签处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git branch # 查看本地所有分支
git checkout &amp;lt;branch/tag&amp;gt; # 切换到指定分支或标签

git branch &amp;lt;new-branch&amp;gt; # 创建新分支
git checkout -b &amp;lt;new-branch&amp;gt; # 创建并切换到新分支
git branch -d &amp;lt;branch&amp;gt; # 删除本地分支

git merge &amp;lt;branch&amp;gt; # 合并指定分支到当前分支
git rebase &amp;lt;branch&amp;gt; # 衍合指定分支到当前分支

git tag # 列出所有本地标签
git tag &amp;lt;tagname&amp;gt; # 基于最新提交创建标签
git tag -d &amp;lt;tagname&amp;gt; # 删除标签
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地远程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git remote # 获得远程库列表
git remote v # 查看远程版本库信息
git remote show &amp;lt;remote&amp;gt; # 查看指定远程版本库信息
git remote add &amp;lt;remote&amp;gt;&amp;lt;url&amp;gt; # 添加远程版本库
git remote rm &amp;lt;name&amp;gt; # 删除对应的远程库
git branch -u origin/master master # 本地跟踪远程

git fetch &amp;lt;remote&amp;gt; # 从远程库获取代码
git pull &amp;lt;remote&amp;gt;&amp;lt;branch&amp;gt; # 拉取远程指定分支代码并快速合并
git push &amp;lt;remote&amp;gt;&amp;lt;branch&amp;gt; # 推送代码到远程指定分支并快速合并
git push &amp;lt;remote&amp;gt;:&amp;lt;branch/tag-name&amp;gt; # 删除远程分支或标签
git push --tags # 上传所有标签

git pull origin master # 从远程的master分支拉取代码到本地
git push origin master # 推送最新修改到远程的主分支
&lt;/code&gt;&lt;/pre&gt;
">常用的Git命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/execute-script-in-web-page/"" data-c="
          &lt;p&gt;在当前页面的执行环境里执行脚本的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接嵌入&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;代码块&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt;加载远程代码&lt;/li&gt;
&lt;li&gt;在各种HTML和CSS参数里通过&lt;code&gt;javascript:URL&lt;/code&gt;触发调用&lt;/li&gt;
&lt;li&gt;CSS &lt;code&gt;expression(...)&lt;/code&gt;和某些浏览器里的XBL绑定&lt;/li&gt;
&lt;li&gt;事件处理器（Event Handlers），譬如onclick、onerror、onload等&lt;/li&gt;
&lt;li&gt;定时器Timers（setTimeout，setInterval）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval(...)&lt;/code&gt;调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表面上这些方法组合起来使用也很正常，但往往会造成极其难以预料的危险解析链传递。&lt;/p&gt;
">网页里面引起脚本执行的方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-baozhuang-class/"" data-c="
          &lt;h2 id=&#34;boolean&#34;&gt;Boolean&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt;内部维护了两个常量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以对于&lt;code&gt;Boolean a = true; Boolean b = true;&lt;/code&gt;，&lt;code&gt;a == b&lt;/code&gt;是得到true的。&lt;/p&gt;
&lt;h2 id=&#34;integer&#34;&gt;Integer&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Integer&lt;/code&gt;对一段范围内的数字有个缓存：IntegerCache.low ~ IntegerCache.high&lt;br&gt;
如果数字在这个范围内，两个integer &lt;code&gt;==&lt;/code&gt;是返回true的；否则就会new一个对象返回，肯定是不相等的。&lt;br&gt;
&lt;code&gt;IntegerCache&lt;/code&gt;的low是固定死的-128，high默认127，可以通过这个配置修改&lt;code&gt;-XX:AutoBoxCacheMax&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;short-long&#34;&gt;Short、Long&lt;/h2&gt;
&lt;p&gt;和Integer差不多，但是它们的high是固定的127。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aCoder2013/blog/issues/14&#34;&gt;Java原生类型包装类初解析&lt;/a&gt;&lt;/p&gt;
">Java包装类的比较</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-thread/"" data-c="
          &lt;h2 id=&#34;线程状态&#34;&gt;线程状态&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新建：创建后尚未启动的线程处于这种状态&lt;/li&gt;
&lt;li&gt;运行：运行状态包括操作系统中的运行态和就绪态，也就是说这个状态下的线程可能正在执行，也有可能在等待CPU为它分配执行时间；&lt;/li&gt;
&lt;li&gt;无限期等待：处于这种状态的线程不会被分配CPU，它们要被其它进程显式唤醒。可能进入这种状态的操作有：
&lt;ul&gt;
&lt;li&gt;没有设置时间参数的wait和join方法；&lt;/li&gt;
&lt;li&gt;LockSupport.park()方法；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限期等待：处于这种状态的线程也不会被分配执行时间，不过不需要其它线程唤醒，等一段时间之后就会由系统自动唤醒。可能进入这种状态的有：
&lt;ul&gt;
&lt;li&gt;设置了时间参数的wait和join方法；&lt;/li&gt;
&lt;li&gt;sleep方法；&lt;/li&gt;
&lt;li&gt;LockSupport.parkNanos()方法、LockSupport.parkUntil()方法；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阻塞状态：线程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获得一个排它锁。而等待状态则是在等待一段时间，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。&lt;/li&gt;
&lt;li&gt;结束：已终止线程的线程状态，线程已经结束执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;线程安全&#34;&gt;线程安全&lt;/h2&gt;
&lt;p&gt;当多个线程访问一个对象的时候，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。&lt;/p&gt;
">Java中的线程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-map/"" data-c="
          &lt;p&gt;&lt;code&gt;Map&lt;/code&gt;就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。&lt;/p&gt;
&lt;p&gt;Java里面基于对Map的不同访问需求创建了它的不同实现类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对键的顺序没有要求&lt;/li&gt;
&lt;li&gt;取出键的顺序按照插入记录时的顺序&lt;/li&gt;
&lt;li&gt;取出键的顺序按照键的升序排序&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Hashmap&lt;/code&gt; 是一个最常用的Map，它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。&lt;/p&gt;
&lt;h3 id=&#34;空键问题&#34;&gt;空键问题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;最多只允许一条记录的键为Null，允许多条记录的值为 Null。&lt;/p&gt;
&lt;h3 id=&#34;线程安全问题&#34;&gt;线程安全问题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;的访问没有锁，即任一时刻可以有多个线程同时写HashMap，对它的访问是线程不安全的，可能会导致数据的不一致。如果需要线程安全，可以使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;的锁是分段加的；另外一种线程安全的Map结构是&lt;code&gt;HashTable&lt;/code&gt;，它与&lt;code&gt;HashMap&lt;/code&gt;类似，继承自Dictionary类，但是它不允许记录的键或者值为空，&lt;code&gt;HashTable&lt;/code&gt;的线程安全是通过对整个数据结构上锁，，即任一时刻只有一个线程能写Hashtable，多线程情况下效率很低。&lt;/p&gt;
&lt;h3 id=&#34;hashcode与equals&#34;&gt;HashCode与equals&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hashCode&lt;/code&gt;是用来计算hash值的，hash值是用来确定hash表索引的。&lt;br&gt;
hash表中的一个索引处存放的是一张链表，所以还要通过&lt;code&gt;equals&lt;/code&gt;方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry。put记录时，如果hash表中没定位到，就在链表前加一个Entry；如果定位到了，则更换Entry中的值，并返回旧的值。&lt;/p&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;p&gt;一般情况下，我们用的最多的是&lt;code&gt;HashMap&lt;/code&gt;，它里面存入的记录在取出的时候是随机的，它根据键的HashCode存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。&lt;/p&gt;
&lt;h2 id=&#34;linkedhashmap&#34;&gt;LinkedHashMap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;保存了记录的插入顺序，在用&lt;code&gt;Iterator&lt;/code&gt;遍历&lt;code&gt;LinkedHashMap&lt;/code&gt;时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当&lt;code&gt;HashMap&lt;/code&gt;容量很大，实际数据较少时，遍历起来可能会比&lt;code&gt;LinkedHashMap&lt;/code&gt;慢，因为&lt;code&gt;LinkedHashMap&lt;/code&gt;的遍历速度只和实际数据有关，和容量无关，而&lt;code&gt;HashMap&lt;/code&gt;的遍历速度和他的容量有关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt; 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。&lt;/p&gt;
&lt;h2 id=&#34;treemap&#34;&gt;TreeMap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt;实现&lt;code&gt;SortMap&lt;/code&gt;接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用&lt;code&gt;Iterator&lt;/code&gt; 遍历&lt;code&gt;TreeMap&lt;/code&gt;时，得到的记录是排过序的。&lt;br&gt;
TreeSet集合排序有两种方式，Comparable和Comparator区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。&lt;/li&gt;
&lt;li&gt;让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数，方式较为灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt;取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么&lt;code&gt;TreeMap&lt;/code&gt;会更好。&lt;code&gt;TreeMap&lt;/code&gt;更是多了一个排序的功能。&lt;/p&gt;
&lt;h3 id=&#34;comparator&#34;&gt;Comparator&lt;/h3&gt;
&lt;p&gt;由于TreeMap需要排序，所以需要一个Comparator为键值进行大小比较，当然也是用Comparator定位的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Comparator可以在创建TreeMap时指定；&lt;/li&gt;
&lt;li&gt;如果创建时没有确定Comparator对象，那么就会使用key.compareTo()方法，这就要求key必须实现Comparable接口；&lt;/li&gt;
&lt;li&gt;TreeMap是使用Tree数据结构实现的，所以使用Comparator接口就可以完成定位了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;相关set&#34;&gt;相关Set&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt;是通过&lt;code&gt;HashMap&lt;/code&gt;实现的，&lt;code&gt;TreeSet&lt;/code&gt;是通过&lt;code&gt;TreeMap&lt;/code&gt;实现的。Java里的Set实现其实用的是Map的key。&lt;br&gt;
Map的key和Set都有一个共同的特性：集合的唯一性。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/fg2006/article/details/6411200&#34;&gt;HashMap,LinkedHashMap,TreeMap的区别&lt;/a&gt;&lt;/p&gt;
">【数据结构】Java里的各种Map</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/js-object/"" data-c="
          &lt;p&gt;JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。&lt;br&gt;
对象时属性的容器，其中每个属性都是名字和值。&lt;br&gt;
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;对象字面量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var empty_object={};

var stoge={
  &amp;quot;firstName&amp;quot;:&amp;quot;Joerome&amp;quot;,
  &amp;quot;lastName&amp;quot;:&amp;quot;Howare&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的对象stoge中两个属性，如果他们不是JavaScript的保留字，可以去掉引号。&lt;br&gt;
检索对象里面属性的值可以用中括号去获取，如&lt;code&gt;stoge[&amp;quot;firstName&amp;quot;]&lt;/code&gt;，如果该字符串表达式是一个字符串字面量，且是合法的JavaScript标识符不是保留字，那么也可以用点号“.”获取。如果试图获取一个不存在的属性，将得到undefined。&lt;/p&gt;
&lt;p&gt;使用typeof操作符对确定属性的类型很有帮助：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof flight.number  // &#39;number&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，原型链中的任何属性都会产生值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof flight.toString  // &#39;function&#39;
typeof flight.constructor // &#39;function&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有两种方法处理这些不需要的属性：&lt;br&gt;
第一个是让程序做检查并丢弃值为函数的属性，一般来说，想让对象在运行时动态获取自身信息时，关注更多的是数据。&lt;br&gt;
另一个方法是使用hasOwnProperty方法，如果对象拥有独有的属性，将返回true，该方法不会检查原型链。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;flight.hasOwnProperty(&#39;number&#39;) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for in 循环中遍历属性的顺序是不确定的，如果想要确保属性以特定的顺序出现，最好的办法是完全避免使用for in语句，而是创建一个数组，在其中以正确的顺序包含属性名，然后使用普通的for循环遍历。&lt;/p&gt;
&lt;p&gt;delete可以删除对象中的属性，不会触及原型链中的任何对象，删除对象的属性可能会让原型链中的属性透现出来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;another.nickname  // &#39;Moe&#39;

// 删除another的nickname属性，暴露出原型的nickname属性
delete another.nickname;

another.nickname  // &#39;Curly&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用Java里面的话理解，就是删除子类中的覆盖父类的属性以及get方法，那么下次再想获取该属性，将是从父类得到的。&lt;/p&gt;
">JavaScript里的对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/mysql-storage-engine/"" data-c="
          &lt;p&gt;MySQL由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接池组件&lt;/li&gt;
&lt;li&gt;管理服务和工具组件&lt;/li&gt;
&lt;li&gt;SQL接口组件&lt;/li&gt;
&lt;li&gt;查询分析器组件&lt;/li&gt;
&lt;li&gt;优化器组件&lt;/li&gt;
&lt;li&gt;缓冲（Cache）组件&lt;/li&gt;
&lt;li&gt;插件式存储引擎&lt;/li&gt;
&lt;li&gt;物理文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：存储引擎是基于表的，而不是数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;MySQL常用的插件式存储引擎主要包括MyISAM，InnoDB，NDB Cluster，Maria，Falcon，Memory，Archive，Merge，Federated等，其中最著名且使用最广泛的是MyISAM和InnoDB。MyISAM是MySQL的默认存储引擎，是MySQL最早的ISAM存储引擎的升级版本。&lt;/p&gt;
&lt;h2 id=&#34;myisam存储引擎&#34;&gt;MyISAM存储引擎&lt;/h2&gt;
&lt;p&gt;MyISAM是MySQL的默认存储引擎，它支持B-tree/FullText/R-tree索引类型。&lt;br&gt;
MyISAM的锁级别是表锁，表锁的开销小，加锁快；锁粒度大，发生锁冲突的概率较高，并发度低；表锁适合查询。MyISAM引擎不支持事务性，也不支持外键。&lt;/p&gt;
&lt;p&gt;MyISAM对于一些OLAP（Online Analytical Processing，在线分析处理）操作速度快。除Windows版本外，是所有MySQL版本默认的存储引擎。&lt;/p&gt;
&lt;p&gt;MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，当然你也可以通过myisampack来解压数据文件&lt;br&gt;
。&lt;br&gt;
在MySQL 5.0版本之前，MyISAM默认支持的表大小为4G，如果需要支持大于4G的MyISAM表时，则需要制定MAXROWS和 AVGROW_LENGTH属性。从MySQL 5.0版本开始，MyISAM默认支持256T的单表数据，这足够满足一般应用的需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：对于MyISAM存储引擎表，MySQL数据库只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他使用LRU算法缓存数据 的大部分数据库大不相同。此外，在MySQL 5.1.23版本之前，无论是在32位还是64位操作系统环境下，缓存索引的缓冲区最大只能设置为4G。在之后的版本中，64位系统可以支持大于4G的索引缓冲区。&lt;/p&gt;
&lt;h2 id=&#34;innodb存储引擎&#34;&gt;InnoDB存储引擎&lt;/h2&gt;
&lt;p&gt;InnoDB存储引擎最大的亮点就是支持事务性，支持回滚。它支持Hash/B-tree索引类型。&lt;br&gt;
InnoDB的锁级别是行锁，行锁在锁定上带来的消耗大于表锁，但是在系统并发访问量较高时，InnoDB整体性能远高于MyISAM。InnoDB的索引不仅缓存索引本身，也缓存数据，所以InnoDB需要更大的内存。&lt;/p&gt;
&lt;p&gt;InnoDB存储引擎支持事务，主要面向在线事务处理（OLTP）方面的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读取操作不会产生锁。MySQL在Windows版本下的InnoDB是默认的存储引擎，同时InnoDB默认地被包含在所有的MySQL二进制发布版本中。&lt;/p&gt;
&lt;p&gt;InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB自身进行管理。从MySQL 4.1（包括4.1）版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。与Oracle类似，InnoDB存储引擎同样可以使用裸设备（row disk）来建立其表空间。&lt;/p&gt;
&lt;p&gt;InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时使用一种被称为next-key locking 的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。&lt;/p&gt;
&lt;p&gt;对于表中数据的存储，InnoDB存储引擎采用了聚簇（clustered）的方式，这种方式类似于Oracle的索引聚集表（index organized table，IOT）。&lt;/p&gt;
&lt;p&gt;每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的 ROWID，并以此作为主键。&lt;/p&gt;
&lt;h2 id=&#34;memory存储引擎&#34;&gt;Memory存储引擎&lt;/h2&gt;
&lt;p&gt;Memory存储引擎是一个内存级的存储引擎，它将所有数据都存储在内存中，所以它能够存储的数据量是比较小的。而因为内存的特性，Memory存储引擎对于数据的一致性支持教差。Memory的锁级别和MyISAM一样，是表锁；并且不支持事务性。&lt;/p&gt;
&lt;p&gt;Memory存储引擎（之前称为HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。它默认使用哈希索引，而不是我们熟悉的B+树索引。&lt;/p&gt;
&lt;p&gt;虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，其只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（这个问题之前已经提到，eBay的Igor Chernyshev工程师已经给出了Patch方案）。&lt;br&gt;
此外有一点常被忽视的是，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。&lt;/p&gt;
&lt;h2 id=&#34;ndb存储引擎&#34;&gt;NDB存储引擎&lt;/h2&gt;
&lt;p&gt;2003年，MySQL AB公司从Sony Ericsson公司收购了NDB 集群引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群；不过，与Oracle RAC share everything结构不同的是，其结构是share nothing的集群架构，因此能提供更高级别的高可用性。NDB的特点是数据全部放在内存中（从5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找（primary key lookup）的速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。&lt;/p&gt;
&lt;p&gt;关于NDB存储引擎，有一个问题值得注意，那就是NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：MySQL NDB Cluster存储引擎有社区版本和企业版本，并且NDB Cluster已作为Carrier Grade Edition单独下载版本而存在，可以通过[http://dev.mysql.com/ downloads/cluster/index.html](http://dev.mysql.com/ downloads/cluster/index.html)获得最新版本的NDB Cluster存储引擎。&lt;/p&gt;
&lt;h2 id=&#34;archive存储引擎&#34;&gt;Archive存储引擎&lt;/h2&gt;
&lt;p&gt;Archive存储引擎只支持INSERT和SELECT操作，MySQL 5.1开始支持索引。其使用zlib算法将数据行（row）进行压缩后存储，压缩比率一般可达1∶10。正如其名称所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是本身并不是事物安全的存储引擎，其设计目标主要是提供高速的插入 和压缩功能。&lt;/p&gt;
&lt;h2 id=&#34;federated存储引擎&#34;&gt;Federated存储引擎&lt;/h2&gt;
&lt;p&gt;Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。&lt;/p&gt;
&lt;h2 id=&#34;maria存储引擎&#34;&gt;Maria存储引擎&lt;/h2&gt;
&lt;p&gt;Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎，开发者是MySQL 的创始人之一的Michael Widenius。因此，它可以看作是MyISAM的后续版本。其特点是：缓存数据和索引文件，行锁设计，提供MVCC功能，支持事务和非事务安全的选项 支持，以及更好的BLOB字符类型的处理性能。&lt;/p&gt;
&lt;h2 id=&#34;其他存储引擎&#34;&gt;其他存储引擎&lt;/h2&gt;
&lt;p&gt;除了上面提到的7种存储引擎外，还有很多其他的存储引擎，包括Merge、CSV、Sphinx和Infobright，它们都有各自适用的场合，这里不再一一做介绍了。了解了MySQL拥有这么多存储引擎后，现在我可以回答1.2节中提到的问题了。&lt;/p&gt;
&lt;p&gt;为什么MySQL不支持全文索引？不！MySQL支持，MyISAM、Sphinx存储引擎支持全文索引。&lt;br&gt;
MySQL快是因为不支持事务吗？错！MySQL MyISAM存储引擎不支持事务，但是InnoDB支持。快是相对于不同应用来说的，对于ETL这种操作，MyISAM当然有其优势。&lt;br&gt;
当表的数据量大于1000W时，MySQL的性能会急剧下降吗？不！MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，如果 你选择了正确的存储引擎以及正确的配置，再大的数据量MySQL也是能承受的。如官方手册上提及的，Mytrix和Inc.在InnoDB上存储了超过 1TB的数据，还有一些其他网站使用InnoDB存储引擎处理平均每秒800次插入/更新的操作。&lt;/p&gt;
&lt;h2 id=&#34;myisam和innodb差别&#34;&gt;MyISAM和InnoDB差别&lt;/h2&gt;
&lt;h3 id=&#34;构成差别&#34;&gt;构成差别&lt;/h3&gt;
&lt;p&gt;每个MyISAM在磁盘上存储成三个文件，文件的名字以表的名字开始，.frm文件存储表定义，.MYI(MYIndex)为索引文件，.MYD(MYData)为数据文件。&lt;/p&gt;
&lt;p&gt;基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。&lt;/p&gt;
&lt;h3 id=&#34;事务处理差别&#34;&gt;事务处理差别&lt;/h3&gt;
&lt;p&gt;MyISAM类型的表强调性能，执行速度比InnoDB快，但是不支持事务处理等高级功能。&lt;/p&gt;
&lt;p&gt;InnoDB提供事务支持、外部键等高级数据库功能。&lt;/p&gt;
&lt;h3 id=&#34;crud操作&#34;&gt;CRUD操作&lt;/h3&gt;
&lt;p&gt;如果执行大量SELECT查询操作，MyISAM是最好的选择。&lt;/p&gt;
&lt;p&gt;如果执行大量的UPDATE或者INSERT操作，出于性能方面考虑，应该使用InnoDB。&lt;code&gt;DELETE from table&lt;/code&gt;时，InnoDB不会重新建立表，而是一行一行的删除。&lt;br&gt;
&lt;code&gt;LOAD TABLE FROM MASTER&lt;/code&gt;操作对InnoDB不起作用，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。&lt;/p&gt;
&lt;h3 id=&#34;auto_increment操作&#34;&gt;AUTO_INCREMENT操作&lt;/h3&gt;
&lt;p&gt;MyISAM为INSERT和UPDATE操作自动更新这一列，这使得AUTO_INCREMENT列更快（10%+），在序列项的值删除后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。&lt;br&gt;
AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置。&lt;/p&gt;
&lt;p&gt;对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但 是在MyISAM表中，可以和其他字段一起建立联合索引。&lt;br&gt;
如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。InnoDB自动增长计数器仅被存储在主内存中，而不是存在磁盘上。&lt;/p&gt;
&lt;h3 id=&#34;表的具体行数&#34;&gt;表的具体行数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;select count(*) from table&lt;/code&gt;，MyISAM只要简单的读出保存好的行数。注意的是，当count(*)语句包含 where 条件时，两种类型表的操作是一样的。&lt;/p&gt;
&lt;p&gt;InnoDB 中不保存表的具体行数。也就是说，执行&lt;code&gt;select count(*) from table&lt;/code&gt;时，InnoDB要扫描一遍整个表来计算有多少行。&lt;/p&gt;
&lt;h3 id=&#34;锁&#34;&gt;锁&lt;/h3&gt;
&lt;p&gt;MyISAM的锁是在表级别。其并发写的性能一直是一个让人比较头疼的问题。&lt;/p&gt;
&lt;p&gt;InnoDB提供了行级别的锁(locking on row level)，提供与 Oracle类型一致的不加锁读取(non-locking read in SELECTs)。另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如&lt;code&gt;update table set num=1 where name like &#39;%aaa%&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;索引&#34;&gt;索引&lt;/h3&gt;
&lt;p&gt;MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引。&lt;/p&gt;
&lt;p&gt;Innodb是索引和数据是存放在相同的文件，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。Innodb 的数据存放格式也比较独特,每个Innodb表 都会将主键以聚簇索引的形式创建。所有的数据都是以主键来作为升序排列在物理磁盘上面,所以主键 查询并且以主键排序的查询效率也会非常高。&lt;/p&gt;
&lt;h2 id=&#34;如何选择合适的引擎&#34;&gt;如何选择合适的引擎&lt;/h2&gt;
&lt;h3 id=&#34;采用myisam引擎&#34;&gt;采用MyISAM引擎&lt;/h3&gt;
&lt;p&gt;R/W &amp;gt; 100 ，并且Update较少 (R/W:读写比)&lt;br&gt;
并发不高，不需要支持事务&lt;br&gt;
表数据量小&lt;br&gt;
需要进行全文搜索&lt;/p&gt;
&lt;h3 id=&#34;采用innodb引擎&#34;&gt;采用InnoDB引擎&lt;/h3&gt;
&lt;p&gt;R/W比较小，频繁更新大字段&lt;br&gt;
表数据量超过千万，高并发&lt;br&gt;
安全性和可用性要求高&lt;/p&gt;
&lt;h3 id=&#34;采用memory引擎&#34;&gt;采用Memory引擎&lt;/h3&gt;
&lt;p&gt;有足够的内存&lt;br&gt;
对数据一致性要求不高，如session/在线人数等&lt;br&gt;
需要定期归档的数据&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ha97.com/4197.html&#34;&gt;MySQL存储引擎MyISAM与InnoDB的主要区别对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://imysql.com/2015/07/23/something-important-about-mysql-design-reference.shtml&#34;&gt;老叶观点：MySQL开发规范之我见&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://simpleframework.net/news/view?newsId=63cd772590e8495bbff4d713e092f772&#34;&gt;《MySQL技术内幕:InnoDB存储引擎》-- 第1章 MySQL体系结构和存储引擎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">MySQL不同的存储引擎</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/array-and-linkedlist/"" data-c="
          &lt;p&gt;在计算机程序里，数据存储的方式无外乎两种：顺序存储和链式存储。顺序存储的结构可以称为顺序表，也可以用数组描述，链式存储的结构可以称为链表。&lt;br&gt;
我们每一个学过数据结构的都知道，它们两者各自有一些鲜明的特性，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以通过数组下标去访问数组里的元素，查询、更新的效率高，时间复杂度是O(1)，但是在中间某个位置插入或删除一个元素就要挪动后面所有的元素，时间复杂度是O(n)。&lt;/li&gt;
&lt;li&gt;链表里元素之间存在指针指向关联的另一个元素，我们只能通过指针挨个去遍历访问链表里的元素，查询、更新的效率低，时间复杂度是O(n)，在中间某个位置插入或删除一个元素比较方便，只需要修改相邻指针的引用就可以了，时间复杂度是O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;数组的好处显而易见，它的存储结构比较紧凑，相对节省空间。每个元素都有唯一的索引，支持随机访问。但是数组所需要的空间需要一次分配够，当数组容量满时，新加入元素就要对数组进行扩容。扩容时，往往不能在原地直接扩，因为后面的内存可能已经分配给其他数据结构了，所以要重新申请一块新的更大的内存空间，将原有的数组里的元素全部复制到新的数组里，再释放原有数组的空间，这个过程时间复杂度是O(n)，可以参考Java的&lt;code&gt;ArrayList&lt;/code&gt;。如果不加以合理的维护，内存中将产生大量碎片。&lt;/p&gt;
&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;
&lt;p&gt;链表有效地解决里数组需要扩容的问题，因为链表里的每个元素节点都不需要连续，链表的节点通过指针进行索引，每个节点只能找到它指针指向的下一个节点。正常的单向链表是从头节点开始，每个节点依次有一个指针指向它后面的节点，尾部节点指向NULL。有时候为了方便拿到前驱节点，我们会采用双向链表，也就是每个节点既包含一个指针指向后面的，也包含一个指针指向前面的。还有一种链表是循环链表，也就是说尾节点指向了头节点。&lt;/p&gt;
&lt;h3 id=&#34;dummy-node&#34;&gt;Dummy Node&lt;/h3&gt;
&lt;p&gt;翻译为哑节点或者假人头节点。&lt;/p&gt;
&lt;p&gt;Dummy node 是一个虚拟节点，也可以认为是标杆节点。Dummy node 就是在链表表头 head 前加一个节点指向 head，即dummy -&amp;gt; head。Dummy node 的使用多针对单链表没有前向指针的问题，保证链表的 head 不会在删除操作中丢失。还有一种用法比较少见，就是使用 dummy node 来进行head的删除操作。所以，当链表的 head 有可能变化（被修改或者被删除）时，使用 dummy node 可以很好的简化代码，最终返回&lt;code&gt;dummy.next&lt;/code&gt;即新的链表。&lt;/p&gt;
&lt;h3 id=&#34;快慢指针&#34;&gt;快慢指针&lt;/h3&gt;
&lt;p&gt;快慢指针指的是2个指针沿着链表向前移动的步数不一样，比如一个每次移2步，另一个每次移1步。可以通过它找到链表中间的节点以及判断链表是否循环。&lt;/p&gt;
">【数据结构】数组和链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/linux-redirect-dev-null/"" data-c="
          &lt;p&gt;本文亦发布于&lt;a href=&#34;https://thinkbucket.cn/blog/2020/05/21/linux-redirect-dev-null&#34;&gt;ThinkBucket&lt;/a&gt;。&lt;br&gt;
在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是何意？&lt;/p&gt;
 &lt;!-- more --&gt; 
&lt;h2 id=&#34;linux-进程&#34;&gt;Linux 进程&lt;/h2&gt;
&lt;p&gt;以 bash 为例，shell 中执行一个命令时，其实是由 bash shell fork 出一个子进程，然后在这个子进程中运行相应的命令，直至退出。Linux 里的进程的数据结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;struct task_struct {
	// 进程状态
	long state;
	// 虚拟内存结构体
	struct mm_struct *mm;
	// 进程号
	pid_t pid;
	// 指向父进程的指针
	struct task_struct __rcu *parent;
	// 子进程列表
	struct list_head children;
	// 存放文件系统信息的指针
	struct fs_struct *fs;
	// 一个数组，包含该进程打开的文件指针
	struct files_struct *files;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 就是 Linux 对于一个进程的描述，也可以称之为进程描述符。其中的 &lt;code&gt;files&lt;/code&gt; 指针指向一个数组，表示当前进程打开的所有文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个进程被创建时，&lt;code&gt;files&lt;/code&gt; 指向的数组前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 中的所有设备都是抽象成文件的，设备可以当作文件一样读和写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述所说的文件描述符如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;文件描述符&lt;/th&gt;
&lt;th&gt;默认情况&lt;/th&gt;
&lt;th&gt;对应文件句柄位置&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标准输入（standard input）&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;从键盘获得输入&lt;/td&gt;
&lt;td&gt;/proc/slef/fd/0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标准输出（standard output）&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;输出到屏幕（即控制台）&lt;/td&gt;
&lt;td&gt;/proc/slef/fd/1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;错误输出（error output）&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;输出到屏幕（即控制台）&lt;/td&gt;
&lt;td&gt;/proc/slef/fd/2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;重定向&#34;&gt;重定向&lt;/h2&gt;
&lt;p&gt;Linux shell 里通过 &lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;进行输出、输入的重定向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;：将 shell 命令的输出指向某个地方，可以是文件，也可以是内存里的某个变量。比如 &lt;code&gt;ls -l &amp;gt; file.txt&lt;/code&gt; 就是把当前路径下的文件信息保存到 file.txt 文本中，如果没有这个重定向，它会将结果输出到显示器屏幕上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;：从某个地方读取内容作为 shell 命令的输入，可以是文件，也可以是内存里的某个变量。比如 &lt;code&gt;{command} &amp;lt; file.txt&lt;/code&gt;，如果没有这个重定向，它会从键盘读取输入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用&lt;code&gt;&amp;gt;&lt;/code&gt;进行输出重定向时，默认是把某个命令的标准输出进行重定向。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 把标准输出重定向到新文件中
command &amp;gt;filename

# 把标准输出重定向到新文件中
command 1&amp;gt;filename

# 把标准错误重定向到新文件中
command 2&amp;gt;filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当使用&lt;code&gt;&amp;lt;&lt;/code&gt;进行输入重定向时，默认时把它右边的内容作为标准输入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 以filename文件作为标准输入
command &amp;lt;filename

# 以filename文件作为标准输入
command 0&amp;lt;filename

# 从标准输入中读入，直到遇到delimiter分隔符
command &amp;lt;&amp;lt;delimiter
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;管道&#34;&gt;管道&lt;/h3&gt;
&lt;p&gt;shell 还可以通过 &lt;code&gt;|&lt;/code&gt; 这样的管道将前一个命令的输出作为下一个命令的输入，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在命令历史中找到包含 ssh 字符串的命令
history | grep ssh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-devnull&#34;&gt;2&amp;gt; /dev/null&lt;/h2&gt;
&lt;p&gt;通过上面的章节可以知道，&lt;code&gt;2&lt;/code&gt; 表示标准错误，&lt;code&gt;&amp;gt;&lt;/code&gt; 表示将标准错误重定向到某个地方。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/dev/null&lt;/code&gt; 是一个特殊文件，在Unix系统中称为 null 设备。 通俗地说，它也称为比特桶（bit bucket，也译作比特垃圾桶）或黑洞（blackhole），因为它会立即丢弃写入其中的任何内容，并且在读取时仅返回文件结束EOF。&lt;/p&gt;
&lt;p&gt;所以这个命令合起来就是将忽略执行命令产生的错误。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 删除当前路径下的folder目录，如果不存在则忽略错误
rm -r folder 2&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;之间不能有空格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;更多用法&#34;&gt;更多用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;：将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。这种写法的好处是可以避免同样的输出文件的描述符不用打开两次，标准输出和错误输出也不会抢占性往文件输出内容。&lt;br&gt;
&lt;code&gt;&amp;gt; /dev/null&lt;/code&gt;：将标准输出1重定向到&lt;code&gt;/dev/null&lt;/code&gt;中。&lt;br&gt;
&lt;code&gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;：就是让标准输出和错误输出重定向到&lt;code&gt;/dev/null&lt;/code&gt;中（就是所有输出都丢弃了）。错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了&lt;code&gt;/dev/null&lt;/code&gt;中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。&lt;br&gt;
&lt;code&gt;2&amp;gt;&amp;amp;1 &amp;gt;/dev/null&lt;/code&gt;：标准输出丢弃，错误输出显示在屏幕上。&lt;/p&gt;
&lt;p&gt;我们会用&lt;code&gt;nohup&lt;/code&gt;命令在后台启动Java程序，为了不让一些执行信息输出到控制台，会用如下命令丢弃输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nohup java -jar xxxx.jar &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bash.cyberciti.biz/guide/What_is_a_Process%3F&#34;&gt;What is a Process?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md&#34;&gt;Linux的进程、线程、文件描述符是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki//dev/null&#34;&gt;维基百科：/dev/null&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Linux 中的 2> /dev/null</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/oop-and-pure-function/"" data-c="
          &lt;p&gt;在面向对象编程里面，我们常常对现实世界建模抽象成一个个类，然后创建它们的对象，通过对象的方法行为去描述逻辑。&lt;/p&gt;
&lt;p&gt;纯函数是一种特殊的函数，给它相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;占位符，待更。&lt;/p&gt;
&lt;p&gt;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1&lt;br&gt;
https://www.jiqizhixin.com/articles/2018-10-22-15&lt;/p&gt;
">面向对象编程与纯函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/manage-multiple-java-versions/"" data-c="
          &lt;p&gt;自从Oracle宣布Java开始收费之后，越来越多的人会考虑从[Open JDK][1]下载安装Java环境。可能自己机器上也会同时并存好几个Java版本，本文以macOS为例介绍一下如何从Open JDK安装并进行管理多版本。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;下载安装&#34;&gt;下载安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -O https://download.java.net/java/GA/jdk12/33/GPL/openjdk-12_osx-x64_bin.tar.gz 
tar xvf openjdk-12_osx-x64_bin.tar.gz

# 解压后文件夹比如名为jdk-12.jdk，移动到macOS管理的JVM目录中去
sudo mv jdk-12.jdk /Library/Java/JavaVirtualMachines
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，可以输入如下命令查看本机上有几种Java版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/usr/libexec/java_home -V
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如生成如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Matching Java Virtual Machines (2):
    12, x86_64:	&amp;quot;OpenJDK 12&amp;quot;	/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home
    1.7.0_76, x86_64:	&amp;quot;Java SE 7&amp;quot;	/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以输入小写v参数查看具体的版本信息，比如查刚刚下载的Java 12：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/usr/libexec/java_home -v 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会显示&lt;code&gt;/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home&lt;/code&gt;，这个就是它的Java Home。那么就能通过export设置当前的JAVA_HOME环境变量了。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=`/usr/libexec/java_home -v 12`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;便捷管理多版本&#34;&gt;便捷管理多版本&lt;/h2&gt;
&lt;p&gt;Linux或者macOS都有bash或者其他shell，以bash为例，bash在每个用户目录下都有&lt;code&gt;.bashrc&lt;/code&gt;文件用于配置用户相关的环境变量（如果没有可以自己创建），可以在该文件下面写如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# type &#39;java7&#39; at command prompt to switch to java 7
function java7() {
    export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
    echo &amp;quot;JAVA_HOME is $JAVA_HOME&amp;quot;
    java -version
}

# type &#39;java12&#39; at command prompt to switch to java 12
function java12() {
    export JAVA_HOME=`/usr/libexec/java_home -v 12`
    echo &amp;quot;JAVA_HOME is $JAVA_HOME&amp;quot;
    java -version
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存之后，输入命令&lt;code&gt;source .bashrc&lt;/code&gt;，然后可以通过命令&lt;code&gt;java12&lt;/code&gt;或者&lt;code&gt;java7&lt;/code&gt;来便捷切换所使用的Java版本。&lt;/p&gt;
&lt;p&gt;[1]:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;https://openjdk.java.net/install/&lt;/p&gt;
">在Shell里管理多个Java版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/Try with closable resources/"" data-c="
          &lt;p&gt;以前，拿到一个closable资源后，如果对它操作，都要先用try包起来，最后一定要在finally里面关掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Closable resource = xxx; //此处为得到这个resource的逻辑
try {
	// 处理逻辑
} finally {
	if (resource != null) {
		try {
			resource.close();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自从Java 7之后，根据官方文档&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html&#34;&gt;tryResouceClose&lt;/a&gt;，任何实现了&lt;code&gt;java.lang.AutoClosable&lt;/code&gt;，以及&lt;code&gt;java.io.Closable&lt;/code&gt;接口的对象都可以在这段代码结束之后被关掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try (Closable resource = xxx) {
	// 处理逻辑
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.NET里面也有个类似的用法，C#里面一般实现了IDisposable接口的对象在使用时最好结束后调用它的dispose方法，也可以使用using的方式来帮助回收：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using (IDisposable resource = xxx) {
	// 处理逻辑
}
&lt;/code&gt;&lt;/pre&gt;
">Try with closable resources</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/wring-code-from-unit-test-side/"" data-c="
          &lt;p&gt;单元测试，也就是对代码较细粒度单元的测试，一般就是测某个方法或函数。说到单元测试，基本上每个开发者都不陌生，时不时会听到“测试覆盖率太低了！”，然后“We need to increase our code coverage!”。经常出bug？好好准备测试吧。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-为什么要提高覆盖率&#34;&gt;1. 为什么要提高覆盖率？&lt;/h2&gt;
&lt;p&gt;覆盖率为什么这么重要？我们每次修改代码之后都不希望把原有可用的功能搞出问题，如果没有足够的测试覆盖，开发者就没有足够的信心去交付新代码。测试覆盖率高的话，就可以用机器自动去跑高效率地去验证，在覆盖不到的地方需要人工去验证。所以当覆盖率很低的时候，人工需要一遍又一遍的去验证已有的功能，还要去验证新加的功能是否符合预期，这个真的会崩溃。开发者自己去做的话，八成会偷懒抑或是觉得自己改的范围影响不到那么多测得乐观。如果让测试工程师去做，那么需要领导们考虑开发跟测试的比例了。&lt;/p&gt;
&lt;p&gt;测试覆盖率不完全是看单元测试，还包括更高层次的集成测试、系统测试。当然了，如果单元测试没写多少，指望粒度更粗层次更高的其他测试，你会非常痛苦的。单元测试的2个优势：跑得快、容易定位问题。&lt;/p&gt;
&lt;p&gt;上面说了这么多，就是在强调单元测试覆盖率一定要尽可能高，每个单元测试职责一定要尽可能单一简单。单元测试覆盖无非就是代码行覆盖、分支覆盖，单元测试职责单一简单是说单元测试不要试图测某个方法的所有可能性，多写几个，这样出了问题能根据测试名字迅速找到为什么什么用例失败了以及被测方法的哪行可能有问题。&lt;/p&gt;
&lt;h2 id=&#34;2-单元测试为何难写&#34;&gt;2. 单元测试为何难写？&lt;/h2&gt;
&lt;p&gt;你可能听说过“测试驱动开发”，就是先写测试、后写代码，这个要求在写代码之前先好好分析需求、细化用例，把各个用例的测试写出来，每次改动代码都要求让尽可能多的测试结果为绿（成功），直到最后所有测试都绿了，那么代码的功能上也基本没问题了。这个可以了解下，有兴趣多看看这方面拓展一下。&lt;br&gt;
&lt;img src=&#34;http://goroyal.github.io/post-images/1560780095750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;为什么单元测试覆盖率往往上不去？因为有时候真的不好写。什么样的代码不好写单元测试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;被测方法传入了比较复杂的类的对象参数（不是依赖接口），当我要测这个方法，我就要去new依赖的那个对象，但是那个对象又依赖其他的，我又要接着new……，可能这个方法还没开始测，光创建它依赖的东西就写了一大堆测试代码。&lt;/li&gt;
&lt;li&gt;被测方法传入了某个对象作为参数，调用的复杂方法（不是依赖接口），这个方法有多复杂？可能它也跟上面一样也要new很多个对象才能跑起来，或者它调用了外部服务（网络、数据库等等）。简直没法测。&lt;/li&gt;
&lt;li&gt;被测方法自己内部创建了一些复杂对象、或者这个方法所属对象的实例创建了一些复杂对象，往往可能是外部有依赖的，比如对文件系统、数据库、网络等有调用。&lt;/li&gt;
&lt;li&gt;被测方法自己内部引用了static变量。&lt;/li&gt;
&lt;li&gt;被测方法自己内部引用了单例对象。&lt;/li&gt;
&lt;li&gt;被测方法调用了复杂的static方法，无法mock、无法用桩。&lt;/li&gt;
&lt;li&gt;被测方法是一个static方法，它可能依赖一个或多个static变量，这个变量还会被其他static方法修改，很难保证当前测试的独立性，包括它本身作为生产代码都是有坑的。&lt;/li&gt;
&lt;li&gt;被测方法传入了对象参数，考虑用桩了，但是发现那个类或者方法是final的，无法继承重写（如果是C#语言，sealed类无法被继承，无override关键字的方法不能被重写）。&lt;/li&gt;
&lt;li&gt;被测方法本身太长了，很难面面俱到，或者是单元测试出了错之后不好定位是哪行代码引起的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-如何写好单元测试&#34;&gt;3. 如何写好单元测试&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单元测试应该聚焦于被测方法本身的行为&lt;/strong&gt;，而不是被测方法所依赖的其他对象的行为。外部环境有依赖的代码应该尽可能少，并且尽量去调用接口，而不是具体的类。我们经常会听到“面向接口编程”，这个用了之后，写单元测试真的是非常爽。单元测试里面会用mock库或者自己去创建简单的类去模拟某个方法的行为，接口约定根据输入会产生什么样的输出，对于调用接口的方法而言不必去关心具体的实现是什么。Java里有著名的Mockito，C#里有Moq，用起来如行云流水一般。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法或者类构造器里面自己创建的对象不能太复杂&lt;/strong&gt;，复杂了你就没法测了。可以考虑调用该对象的接口，将它作为输入参数，那么就可以用上面说的方式去测了。&lt;/p&gt;
&lt;p&gt;个人理解，&lt;strong&gt;static方法要尽可能做到纯函数化&lt;/strong&gt;，也就是说一样的输入参数，随便什么情况下调用都应该给一样的输出。这其实就要求static这样的静态方法不要依赖不可控的static变量。如果做不到，尽量缩小它的使用范围吧……普通的实例方法调用static方法尽可能只调用简单的，没事别调用public的static变量，调用不受控制的static变量简直是给自己找麻烦，不可测是一方面，运行时被别的代码改掉的话就是灾难了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当被测方法太长的时候，实际上就意味着方法要拆了&lt;/strong&gt;，便于理解和维护。可以正常的拆，比如新建方法、新建类，也可以花哨地拆。有些人写了一堆if、else语句，如果是创建对象相关的，是否可以考虑工厂模式了？如果if、else里面是比较长的逻辑，可以考虑用策略模式。而如果是普通的前后累积的代码很长，要不试试责任链模式？当拆完之后，原本的非常长的不好测的方法变成若干个易测的小方法。覆盖率自然就上去了。&lt;/p&gt;
&lt;h2 id=&#34;4-结语&#34;&gt;4. 结语&lt;/h2&gt;
&lt;p&gt;当每层代码都经过单元测试确保自己这层没问题之后，整个逻辑的链条其实问题不大了。覆盖率不是简简单单为了覆盖而覆盖，单元测试都要有断言，就是如果跟测试目的产生不一致的结果这个测试必须显示失败，否则光数据好看是没用的。&lt;strong&gt;单元测试也不可能做到100%覆盖，但是可以尽可能做得高&lt;/strong&gt;，覆盖不到的地方再通过集成测试或者系统层面的测试去做。至于做不到100%覆盖的原因，比如代码里有对外部依赖的地方，再怎么抽离，总有地方需要去初始化。那么对于这个情况，尽可能把这个对外依赖范围缩小，其他地方用的时候传递接口。&lt;/p&gt;
&lt;p&gt;关于面向接口编程和减少耦合，还可以了解下依赖注入，能帮助解耦调用模块和具体实现类模块。&lt;/p&gt;
&lt;p&gt;为了代码可扩展性高、良好设计、易测试，可能会出现一个复杂业务逻辑的代码一层套一层的情况，一个逻辑看完可能经历了若干个类，这也是人们常常吐槽的Java这种语言的一个“啰嗦”之处。这个我也没有什么更好的想法，如果你有，可以分享一下。&lt;/p&gt;
">以单元测试的角度聊聊写代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/http-response-code/"" data-c="
          &lt;p&gt;目前HTTP在Web开发中被广泛使用，REST (Representational State Transfer) 很多人应该或多或少都知道些。当然了，比较熟悉的可能主要是GET、POST方法。这篇文章不是介绍REST的定义和如何创建符合REST风格的API，而是讲讲在Web开发中通用的不同HTTP响应状态码的含义。在普通网站开发、分布式集群开发、团队协作方面，如果采用了HTTP作为组件之间交互的协议，遵守通用的响应状态码是很有必要的（一是有充分的信息量、二是避免歧义）。&lt;/p&gt;
&lt;p&gt;HTTP响应状态共有5大类，分别是数字1、2、3、4、5开头。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1xx&#34;&gt;1XX&lt;/h2&gt;
&lt;p&gt;信息性状态码，表示接收的请求正在处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;100：说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应&lt;/li&gt;
&lt;li&gt;101：说明服务器正在根据客户端的指定，将协议切换成Update 首部所列的协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2xx&#34;&gt;2XX&lt;/h2&gt;
&lt;p&gt;成功状态码，表示请求正常处理完毕&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200：OK，实体的主体部分包含了所请求的资源。（正常请求很多是这种状态）&lt;/li&gt;
&lt;li&gt;201： Created，表示创建资源成功，响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location 首部包含的则是最具体的引用。（REST里面，POST或者PUT常常返回这样的状态）&lt;/li&gt;
&lt;li&gt;202， Accepted， 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。&lt;/li&gt;
&lt;li&gt;204：No Content，响应不包含实体的主体部分，通常在更新服务器上资源的时候成功的情况下不要求返回实体内容就会产生这个状态码。&lt;/li&gt;
&lt;li&gt;206：Partial Content，成功执行了一个部分或Range（范围）请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3xx&#34;&gt;3XX&lt;/h2&gt;
&lt;p&gt;重定向状态码，表示需要进行附加操作以完成请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;301：Moved Permanently，永久性重定向，表示请求的资源被分配了新的URI，以后应使用资源现在所指的URI。&lt;/li&gt;
&lt;li&gt;302：Found，临时性重定向，表示请求的资源被分配了新的URI，希望用户本次使用新的URI访问。&lt;/li&gt;
&lt;li&gt;303：See Other，表示请求对应的资源存在这另一个URI，应使用GET方法定向获取请求的资源。&lt;/li&gt;
&lt;li&gt;304：Not Modified，表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件。304状态码返回时不包含响应的主体部分（附带条件指：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）。304表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题。另一种情况是,如果服务器认为客户端缓存的资源已经过期了，那么服务器就会返回HTTP/200 OK响应，响应体就是该资源当前最新的内容。客户端收到200响应后，就会用新的响应体覆盖掉旧的缓存资源。&lt;/li&gt;
&lt;li&gt;305：Use Proxy， 用来说明必须通过一个代理来访问资源；代理的位置由Location首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞。&lt;/li&gt;
&lt;li&gt;307：Temporary Redirect，临时重定向，与302有相同的含义。尽管302标准禁止POST变幻成GET，实际大家并未遵守。307会遵照浏览器标准，不会从POST变为GET，但是对于处理响应时的行为每种浏览器可能出现不同的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4xx&#34;&gt;4XX&lt;/h2&gt;
&lt;p&gt;客户端错误状态码，表示服务器无法处理请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;400：Bad Request， 用于告知客户端它发送了一个错误的请求，比方说请求体不符合预先定义的规则&lt;/li&gt;
&lt;li&gt;401：Unauthorized，表示发送的请求需要有通过HTTP认证的认证信息，若之前已进行过请求，则表示认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate手部质询用户信息。&lt;/li&gt;
&lt;li&gt;403：Forbidden，表明请求资源的访问被服务器拒绝了。&lt;/li&gt;
&lt;li&gt;404：Not Found，用于说明服务器无法找到请求的URL所对应的资源。&lt;/li&gt;
&lt;li&gt;405：Method Not Allowed，发起的请求中带有所请求的URL 不支持的方法时，使用此状态码。应该在响应中包含Allow 首部，以告知客户端对所请求的资源可以使用哪些方法。&lt;/li&gt;
&lt;li&gt;406：Not Acceptable，客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的URL 相匹配的资源时，使用此代码。&lt;/li&gt;
&lt;li&gt;413： Request Entity Too Large， 客户端发送的实体主体部分比服务器能够或者希望处理的要大时，返回此状态码。&lt;/li&gt;
&lt;li&gt;429：Too Many Requests，表示客户端在给定时间范围内发送了太多请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5xx&#34;&gt;5XX&lt;/h2&gt;
&lt;p&gt;服务器错误状态码，表示服务器处理请求出错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;500：Intenernal Server Error，服务器在执行请求时发生了错误&lt;/li&gt;
&lt;li&gt;501：Not Implemented，客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）&lt;/li&gt;
&lt;li&gt;502：Bad Gateway， 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）。&lt;/li&gt;
&lt;li&gt;503：Service Unavailable 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况所需时间，最好写入Retry-After首部字段返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 权威指南&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/yuyii/archive/2008/10/16/1312238.html&#34;&gt;HTTP头的Expires与Cache-control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">HTTP 响应状态码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-annotation/"" data-c="
          &lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;注解，也就是Annotation，是Java 5 开始引入的特征，它提供了一种安全的类似注释的机制，用来将任何的信息或元数据与程序元素（类、方法、属性等）进行关联。&lt;br&gt;
Annotation通过Java反射机制来访问注解信息，相关类根据这些信息决定对这些程序元素采用什么行为。Java语言解释器在工作时会忽略这些注解，因此注解在JVM中是“不起作用”的，只能通过配套工具对这些注解类型的信息进行访问和处理。&lt;br&gt;
在软件框架或者工具中常常用到注解，比如Struts，JUnit，TestNG，Spring等。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;定义注解&#34;&gt;定义注解&lt;/h2&gt;
&lt;p&gt;注解使用关键字&lt;code&gt;@interface&lt;/code&gt;定义，而不是&lt;code&gt;interface&lt;/code&gt;。所有注解都是继承的&lt;code&gt;java.lang.annotation.Annotation&lt;/code&gt;接口，但是如果直接创建一个interface继承&lt;code&gt;java.lang.annotation.Annotation&lt;/code&gt;接口并不是定义一个注解类型。&lt;br&gt;
创建的注解类型中可以定义常量、静态成员，也可以定义方法。但是这些方法的声明里必须是无参数、无抛出异常的。方法的返回值必须为primitive类型（包括&lt;code&gt;String&lt;/code&gt;类型）、&lt;code&gt;Class&lt;/code&gt;类型、枚举类型、注解类型中的一个或者以上之一组成的一维数组。方法的后面可以用default和一个值来表示这个方法的默认返回值，注意，默认值不能设为null。只有返回值是&lt;code&gt;Class&lt;/code&gt;的方法可以在注解类型中使用泛型，因为该方法能够将各种类型通过类转换变成&lt;code&gt;Class&lt;/code&gt;。&lt;br&gt;
举一个定义注解的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Property{
    boolean nullable default false;
    String value default &amp;quot;&amp;quot;;
}

public class User{
    @Property(value = &amp;quot;林雷&amp;quot;)
    private String userName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如以上先定义了一个注解类型&lt;code&gt;@Property&lt;/code&gt;，然后定义一个Bean，也就是User类，其中有个userName的属性，对其用&lt;code&gt;@Property&lt;/code&gt;注解进行了标记，那么也就是说userName被标记为值为“林雷”，而且它是不可空的，&lt;code&gt;@Property&lt;/code&gt;后面括号里用等号连接的是个赋值操作，等号左边的内容实际上就是注解中定义的方法，等号右边的内容就是让注解中对应的方法返回一个什么样的值，如果不定义的话就采用注解里设的默认值。可以定义多个，以逗号隔开。&lt;/p&gt;
&lt;h2 id=&#34;三种标准注解&#34;&gt;三种标准注解&lt;/h2&gt;
&lt;p&gt;从Java 5开始就已经自带了三种标准注解，如下：&lt;/p&gt;
&lt;h3 id=&#34;override&#34;&gt;@Override&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Override&lt;/code&gt;是一种标记型注解。表示当前的方法定义覆盖了父类中的方法，起到断言作用，方法签名必须相同（即方法名、参数类型、参数顺序、参数个数都一样），否则无法通过编译。这个注解常用作试图覆盖父类方法而又写错了方法名时的一个保障性校验。&lt;/p&gt;
&lt;h3 id=&#34;deprecated&#34;&gt;@Deprecated&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Deprecated&lt;/code&gt;是一种标记型注解。对不应该再使用的程序元素添加该注解，当调用被注解的方法时，在编译器会显示提示信息不鼓励使用被这个注解了的程序元素。&lt;br&gt;
注意，该注解与JavaDoc注释中的&lt;code&gt;@deprecated&lt;/code&gt;标记是有区别的：前者是用于Java编译器识别的，而后者是在生成文档时被JavaDoc识别。&lt;/p&gt;
&lt;h3 id=&#34;suppresswarnings&#34;&gt;@SuppressWarnings&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此注解能告诉Java编译器关闭对类、方法及成员变量的警告。有时编译时会提出一些警告，对于这些警告有的隐藏着Bug，有的是无法避免的，对于某些不想看到的警告信息，可以通过这个注解来屏蔽。&lt;code&gt;@SuppressWarning&lt;/code&gt;不是一个marker annotation。它有一个类型为&lt;code&gt;String[]&lt;/code&gt;的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对&lt;code&gt;@SuppressWarings&lt;/code&gt;有效，同时编译器忽略掉无法识别的警告名。&lt;/p&gt;
&lt;h2 id=&#34;四种元注解&#34;&gt;四种元注解&lt;/h2&gt;
&lt;h3 id=&#34;target&#34;&gt;@Target&lt;/h3&gt;
&lt;p&gt;表示注解可以用在什么地方，它的值是ElementType枚举中的枚举类型：&lt;br&gt;
CONSTRUCTOR 构造器声明；&lt;br&gt;
FIELD 域声明；&lt;br&gt;
METHOD 方法声明；&lt;br&gt;
TYPE 类、接口或enum声明；&lt;br&gt;
PARAMETER 参数声明；&lt;br&gt;
LOCAL_VARIABLE 局部变量声明；&lt;br&gt;
ANNOTATION_TYPE 注释类型声明&lt;br&gt;
PACKAGE 包声明&lt;/p&gt;
&lt;h3 id=&#34;retention&#34;&gt;@Retention&lt;/h3&gt;
&lt;p&gt;表示需要在什么级别保存该注解信息。设值时需要提供java.lang.annotation.RetentionPolicy中的枚举类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum RetentionPolicy{
    SOURCE, //编译程序处理完Annotation信息后就完成任务
    CLASS, //编译程序将Annotation储存于class中，但会被虚拟机丢弃，@Retention默认是Class级别
    RUNTIME //编译程序将Annotation储存于class中，虚拟机在运行期也保留注解，可以通过反射机制读取注解信息
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;documented&#34;&gt;@Documented&lt;/h3&gt;
&lt;p&gt;将此注解包含到Javadoc中。&lt;/p&gt;
&lt;h3 id=&#34;inherited&#34;&gt;@Inherited&lt;/h3&gt;
&lt;p&gt;允许子类继承父类的注解。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在自定义注解的时候可以综合使用这四个元注解定义自己定义的注解的作用范围等信息。&lt;/p&gt;
&lt;h2 id=&#34;通过反射加载注解&#34;&gt;通过反射加载注解&lt;/h2&gt;
&lt;p&gt;还用之前举的例子，下面简单写个通过反射获得注解信息的例子。&lt;br&gt;
先定义注解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface Property {
    boolean nullable() default false;

    String value() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义POJO Bean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {

    @Property(value = &amp;quot;李雷&amp;quot;)
    private String username;

    @Property(nullable = true, value = &amp;quot;test@a.com&amp;quot;)
    private String email;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来就是获取这个注解了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.Field;

public class AnnotationTest {
    public static void main(String[] args){
        //获取User类的Class实例
        Class&amp;lt;?&amp;gt; clazz = User.class;
        //获取这个类的所有属性
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields){
            //判断这个属性中是否有Property注解
            if (field.isAnnotationPresent(Property.class)){
                Property property = field.getAnnotation(Property.class);
                System.out.println(field.getName()+&amp;quot;: &amp;quot;+property.nullable()+&amp;quot; &amp;quot;+property.value());
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行之后结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;username: false 李雷
email: true test@a.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的结果也可以看到，即使类中的属性定义为private类型，也可以通过注解对其进行标记赋值，这个方法在Spring等框架中常常使用。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://computerdragon.blog.51cto.com/6235984/1210969&#34;&gt;Java注解annotation用法和自定义注解处理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/mandroid/archive/2011/07/18/2109829.html&#34;&gt;Java基础之理解Annotation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itzhai.com/java-based-notebook-annotation-annotation-introduction-and-use-custom-annotations.html&#34;&gt;Java基础笔记 - Annotation注解的介绍和使用 自定义注解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Java中的注解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/exit-command-in-linux/"" data-c="
          &lt;p&gt;本文亦发布于&lt;a href=&#34;https://thinkbucket.cn/blog/2020/02/11/linux-exit/&#34;&gt;ThinkBucket&lt;/a&gt;。&lt;br&gt;
我们在 Linux 的命令行里面会用到&lt;code&gt;exit&lt;/code&gt;，比方说退出某个 shell。在 shell 脚本中这个命令可以终止脚本的执行。&lt;code&gt;exit&lt;/code&gt;后面是可以接一个数字表示退出时候的状态。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;code&gt;exit(0)&lt;/code&gt;一般表示成功结束，其他的是不成功的，如&lt;code&gt;exit(1)&lt;/code&gt;。对于一些系统程序而言，这些错误编号是有含义的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;exit 错误编号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;一般性未知错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;不适合的 shell 命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;126&lt;/td&gt;
&lt;td&gt;命令不可执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;没找到命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;无效的退出参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128 + x&lt;/td&gt;
&lt;td&gt;与 Linux 信号&lt;code&gt;x&lt;/code&gt;相关的严重错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;130&lt;/td&gt;
&lt;td&gt;通过&lt;code&gt;Ctrl + C&lt;/code&gt;终止的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;正常范围之外的退出状态码&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不带数字直接&lt;code&gt;exit&lt;/code&gt;，脚本的退出状态码就由脚本里面最后执行的命令来决定（即&lt;code&gt;exit&lt;/code&gt;之前的命令）。&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;exit $?&lt;/code&gt;，它和&lt;code&gt;exit&lt;/code&gt;是一样的作用。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://man.linuxde.net/exit&#34;&gt;Linux 命令大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ixdba.net/docs/shell/exit-status.html&#34;&gt;退出和退出状态码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Linux 中的 exit 命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/install-oracle-db-in-suse/"" data-c="
          &lt;p&gt;从官网下载64位rpm安装包，解压，打开terminal进入rpm安装包所在目录，输入&lt;code&gt;rpm -i install oralce-xe-xxx.rpm&lt;/code&gt;&lt;br&gt;
然后会提示输入&lt;code&gt;/etc/init.d/oracle-xe configure&lt;/code&gt;，按照步骤照做。&lt;br&gt;
在设置http端口的时候，默认为8080，可能会影响jboss、tomcat，可以改成8088。&lt;/p&gt;
&lt;p&gt;配置ORACLE_HOME和path:&lt;br&gt;
打开&lt;code&gt;/etc/bash.bashrc.local&lt;/code&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export ORACLE_HOME=/u01/app/oracle/product/11.2.0/xe
export PATH=$PATH:$ORACLE_HOME/bin:
export ORACLE_SID=XE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置结束后，在尝试sqlplus连接数据库的时候会出现密码不正确或者权限不够等问题，因为oracle express在安装的时候讲ORACLE用户作为这个软件的owner，而这个owner没有加到dba组里。&lt;br&gt;
可以输入命令&lt;code&gt;/etc/group&lt;/code&gt;查看当前系统中的用户组，&lt;code&gt;/etc/passwd&lt;/code&gt;查看系统中的用户。遇到一个问题就是实际上并不存在ORACLE这个用户，然后采取了一个方法，就是&lt;code&gt;vi /etc/group&lt;/code&gt;强制在dba这个组加上ORACLE这个用户。&lt;br&gt;
打开新的终端，&lt;code&gt;su - oracle&lt;/code&gt;从而切换到ORACLE用户，然后输入&lt;code&gt;groups&lt;/code&gt;，可以查看它属于dba组。（其实挺奇怪，&lt;code&gt;su - oracle&lt;/code&gt;可以切换到oracle用户，但是之前在其他地方找不到这个用户）&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;/etc/init.d/oracle-xe start&lt;/code&gt;(或&lt;code&gt;lsnrctl start&lt;/code&gt;)启动oracle。&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;sqlplus system/密码&lt;/code&gt;，进行连接，如果说用户名或密码错误的话，可以输入&lt;code&gt;sqlplus / as sysdba&lt;/code&gt;(注意，需要在ORACLE用户下)，然后建立连接后，输入&lt;code&gt;alter user system identified by 密码&lt;/code&gt;;&lt;br&gt;
quit后在以&lt;code&gt;sqlplus system/密码&lt;/code&gt;就能连上了。&lt;/p&gt;
&lt;p&gt;密码不正确或者权限不够等问题，应该也可以通过更改oracle安装后的目录及文件的owner来实现，这里就暂不讨论。&lt;/p&gt;
&lt;p&gt;还有可能和&lt;code&gt;$ORACLE_HOME/network/admin&lt;/code&gt;下面的几个ora文件有关。附件里列出了它们。&lt;/p&gt;
&lt;p&gt;如果安装的时候忘了改http端口，可以输入如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sqlplus /nolog
connect
(input username and password)
exec dbms_xdb.sethttpport(8088)
&lt;/code&gt;&lt;/pre&gt;
">SUSE Linux中安装Oracle数据库</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/references-in-java/"" data-c="
          &lt;p&gt;Java中的引用主要有以下几种类型：&lt;br&gt;
• 强引用（StrongReference）：强引用是使用最普遍的引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。&lt;/p&gt;
&lt;p&gt;• 软引用（SoftReference）：软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，内存空间足够，垃圾回收器就不会回收它，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;• 弱引用（WeakReference）：弱引用也是用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;• 虚引用（PhantomReference）：“虚引用”顾名思义，就是形同虚设，也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面主要来谈谈软引用。&lt;br&gt;
对于软引用对象本身，至少有两个强引用指向它：由应用创建的原始的强引用，还有就是JVM创建的在所引对象队列上的一个新的强引用。软引用本质上是一个比较大的、最近最久未用的对象池。获得较好性能的关键是确保它们会被及时清理。&lt;/p&gt;
&lt;p&gt;不要使用太多软引用，它们很容易填满整个堆。&lt;/p&gt;
&lt;p&gt;当问题中的所引对象会同时被几个线程使用时，应该考虑弱引用。否则，弱引用很可能会被垃圾收集器回收：只有弱引用的对象在每个GC周期都可以回收。当强引用被移除时，弱引用会立即释放。&lt;/p&gt;
&lt;p&gt;软：只要有足够内存，而且看上去有人会偶尔访问它，就留着它。&lt;br&gt;
弱：只要有其他人对这个对象感兴趣就让我知道它在哪，但是如果他们不再需要它了，就丢了，我自己会重新创建。&lt;/p&gt;
&lt;p&gt;软引用的对象通常可以存活几分钟甚至几小时，但是只要所引读写仍然存在，弱引用对象就会一直存活（下一个GC周期会清理）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Java中，集合类经常是内存泄露的根源。比如某个应用将对象放入一个HashMap对象中，但从不移除。随着时间推移，这个HashMap对象会越来越大，而且消耗堆。&lt;/strong&gt;&lt;/p&gt;
">Java中的几种引用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/abstract-class-and-interface/"" data-c="
          &lt;p&gt;本文亦发布于&lt;a href=&#34;https://thinkbucket.cn/docs/java/object-oriented-programming/abstract-class-interface&#34;&gt;ThinkBucket&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;抽象类和接口是 Java 面向对象编程中非常重要的元素，在面向接口的编程中两者更是经常用到。类是对象的模版，抽象类和接口可以看作是具体的类的模版。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;抽象类&#34;&gt;抽象类&lt;/h2&gt;
&lt;p&gt;如果一个 &lt;code&gt;class&lt;/code&gt; 用 &lt;code&gt;abstract&lt;/code&gt;修饰，它就是抽象类。除了正常的方法定义外，抽象类里的方法可以是空的，直接以分号结尾，没有具体执行代码，这个方法就是抽象方法，它必须用 &lt;code&gt;abstract&lt;/code&gt; 修饰。&lt;/p&gt;
&lt;p&gt;我们无法实例化一个抽象类，抽象类必须通过一个具体的子类实例化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Person p = new Person(); // 编译错误
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Demo {
  public static void main(String[] args) {
    Teacher t = new Teacher();
    t.setName(&amp;quot;王明&amp;quot;);
    t.work();
    Driver d = new Driver();
    d.setName(&amp;quot;小陈&amp;quot;);
    d.work();
  }
}
// 定义一个抽象类
abstract class People {
  private String name; // 实例变量
  // 共有的 setter 和 getter 方法
  public void setName(String name){
    this.name = name;
  }
  public String getName(){
    return this.name;
  }
  // 抽象方法
  public abstract void work();
}

class Teacher extends People {
  // 必须实现该方法
  public void work() {
    System.out.println(&amp;quot;我的名字叫&amp;quot; + this.getName() + &amp;quot;，我正在讲课，请大家不要东张西望…&amp;quot;);
  }
}

class Driver extends People {
  // 必须实现该方法
  public void work() {
    System.out.println(&amp;quot;我的名字叫&amp;quot; + this.getName() + &amp;quot;，我正在开车，不能接听电话…&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了可以拥有抽象方法和不能实例化的特性外，抽象类拥有普通类的所有特点，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以继承父类（但抽象类的父类必须是抽象类）&lt;/li&gt;
&lt;li&gt;可以实现接口&lt;/li&gt;
&lt;li&gt;可以写 &lt;code&gt;private&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt;、 &lt;code&gt;public&lt;/code&gt; 的成员变量和方法&lt;/li&gt;
&lt;li&gt;可以写 &lt;code&gt;static final&lt;/code&gt; 的常量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口&#34;&gt;接口&lt;/h2&gt;
&lt;p&gt;接口一般是描述一些行为，是对接口使用者的一个承诺。在面向接口的编程中，接口的使用者只需要调用接口的某个方法达到其目的，而无需关心是哪个类实现的。接口的一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Person {
  void run();
  String getName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口的一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有方法都是 &lt;code&gt;public abstract&lt;/code&gt; 的，必须被接口的实现类实现（Java 8之前）&lt;/li&gt;
&lt;li&gt;所有的变量都是 &lt;code&gt;public static final&lt;/code&gt; 的，其实就是常量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;strong&gt;tip&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为接口定义的所有方法默认都是 &lt;code&gt;public abstract&lt;/code&gt; 的，所以这两个修饰符不需要写出来（写不写效果都一样）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个具体的 &lt;code&gt;class&lt;/code&gt; 去实现一个 &lt;code&gt;interface&lt;/code&gt; 时，需要使用 &lt;code&gt;implements&lt;/code&gt; 关键字。举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Student implements Person {
  private String name;

  public Student(String name) {
    this.name = name;
  }

  @Override
  public void run() {
    System.out.println(this.name + &amp;quot; run&amp;quot;);
  }

  @Override
  public String getName() {
    return this.name;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;空接口&#34;&gt;空接口&lt;/h3&gt;
&lt;p&gt;我们常常看到 Java 程序里有定义的一些空接口，那么空接口是什么作用呢？&lt;/p&gt;
&lt;p&gt;空接口的主要是用来做判断的，也就是作为一个标记。为了判断某一个类是否满足其筛选条件时可以做一个空接口，然后利用 &lt;code&gt;instanceof&lt;/code&gt; 方法来判断某一类是否使用了该接口，以达到你要筛选指定类型类的需求。&lt;/p&gt;
&lt;h2 id=&#34;接口和抽象类比较&#34;&gt;接口和抽象类比较&lt;/h2&gt;
&lt;h3 id=&#34;相同点&#34;&gt;相同点&lt;/h3&gt;
&lt;p&gt;从某种角度讲，接口是一种特殊的抽象类，它们有很大的相似处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，&lt;strong&gt;使方法的定义和实现分离&lt;/strong&gt;，这样做对于代码有松散耦合的好处。&lt;/li&gt;
&lt;li&gt;都不能被实例化。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;都能包含抽象方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;接口里只能有常量，而且会“污染”实现类里的作用域；抽象类可以拥有 &lt;code&gt;private&lt;/code&gt; 的变量，有一定程度的封装。&lt;/li&gt;
&lt;li&gt;接口只能继承接口；抽象类既可以继承抽象类，也可以实现接口。&lt;/li&gt;
&lt;li&gt;接口里的所有方法使用者都能直接调用；抽象类里可以封装一些 &lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt; 或者包访问级别的方法&lt;/li&gt;
&lt;li&gt;接口里的所有方法都是抽象的，没有方法体（Java 8 之前）；抽象类里的非抽象方法可以拥有方法体。&lt;/li&gt;
&lt;li&gt;一个实现类一旦继承了某个抽象类，可以实现别的接口，但是不能继承其他类了；而如果它实现了某个接口，还可以实现别的接口，也可以继承别的类。体为空），但抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现。&lt;/li&gt;
&lt;li&gt;接口是对行为的一种抽象，而抽象类是对类的抽象，包括属性、方法。继承抽象类的类往往是具有一些相似特点的类，而实现接口的类可以跨不同的域，仅仅实现了接口定义的契约。类继承抽象类像是一个 &lt;strong&gt;”is-a”&lt;/strong&gt; 特点，类实现接口像是 &lt;strong&gt;”like-a”&lt;/strong&gt; 特点。&lt;/li&gt;
&lt;li&gt;在设计时，对接口往往是自上而下的，先定义接口行为，然后再针对其做具体实现；抽象类往往是自下而上的，我们先知道子类后才对其进行抽象出父类。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Student implements Person, Hello { // 实现了两个interface
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口继承&#34;&gt;接口继承&lt;/h3&gt;
&lt;p&gt;一个 &lt;code&gt;interface&lt;/code&gt; 可以使用 &lt;code&gt;extends&lt;/code&gt; 继承自另一个 &lt;code&gt;interface&lt;/code&gt; 。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Hello {
  void hello();
}

interface Person extends Hello {
  void run();
  String getName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时， &lt;code&gt;Person&lt;/code&gt; 接口继承自 &lt;code&gt;Hello&lt;/code&gt; 接口，因此， &lt;code&gt;Person&lt;/code&gt; 接口现在实际上有 3 个抽象方法签名，其中一个来自继承的 &lt;code&gt;Hello&lt;/code&gt; 接口。&lt;/p&gt;
&lt;h3 id=&#34;类与接口的继承关系&#34;&gt;类与接口的继承关系&lt;/h3&gt;
&lt;p&gt;合理设计 interface 和 abstract class 的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在 abstract class 中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考 Java 的集合类定义的一组接口、抽象类以及具体子类的继承关系：&lt;/p&gt;
&lt;Img w=&#34;380&#34; src=&#39;https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/rt4hsL.png&#39; /&gt;
&lt;p&gt;在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List list = new ArrayList(); // 用List接口引用具体子类的实例
Collection coll = list; // 向上转型为Collection接口
Iterable it = coll; // 向上转型为Iterable接口
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;接口里的默认方法&#34;&gt;接口里的默认方法&lt;/h2&gt;
&lt;p&gt;从 Java 8 开始，Java 为接口提供了默认方法的功能，用 &lt;code&gt;default&lt;/code&gt; 关键字表示，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface InterfaceA {
  default void foo() {
    System.out.println(&amp;quot;InterfaceA foo&amp;quot;);
  }
}

class ClassA implements InterfaceA {
}

public class Test {
  public static void main(String[] args) {
    new ClassA().foo(); // Will print &amp;quot;InterfaceA foo&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ClassA&lt;/code&gt; 没有实现 &lt;code&gt;InterfaceA&lt;/code&gt; 的 &lt;code&gt;foo&lt;/code&gt; 方法，但是 &lt;code&gt;InterfaceA&lt;/code&gt; 提供了默认实现，当 &lt;code&gt;ClassA&lt;/code&gt; 的实例调用到 &lt;code&gt;foo&lt;/code&gt; 方法时，实际上是调用了接口里的默认实现。&lt;/p&gt;
&lt;h3 id=&#34;为什么引入默认方法&#34;&gt;为什么引入默认方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在 Java 8 之前&lt;/strong&gt;，接口和实现类之间高度耦合，当接口中添加一个方法时，它的所有实现类都需要修改，否则会发生编译错误。无法在不破坏现有实现的条件下向接口添加&lt;strong&gt;新&lt;/strong&gt;方法。&lt;/p&gt;
&lt;p&gt;:::&lt;strong&gt;tip&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To use default method, JDK &amp;gt;= 1.8 is a must.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Java 8 里面，引入默认方法的意图是&lt;strong&gt;允许向现有接口添加方法&lt;/strong&gt;，Java 8 里有一个重要新功能： lamda 表达式，这需要升级旧接口并保持向后兼容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] array = new String[] {
  &amp;quot;hello&amp;quot;,
  &amp;quot;, &amp;quot;,
  &amp;quot;world&amp;quot;,
};
List&amp;lt;String&amp;gt; list = Arrays.asList(array);
list.forEach(System.out::println); // additional method in JDK 1.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;forEach&lt;/code&gt; 方法是 Java 8 里为 &lt;code&gt;Iterable&lt;/code&gt; 接口添加的新默认方法，实现类不需要做任何修改就可以直接用它。下面是 &lt;code&gt;Iterable&lt;/code&gt; 接口里的 &lt;code&gt;forEach&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang;

import java.util.Objects;
import java.util.function.Consumer;

public interface Iterable&amp;lt;T&amp;gt; {
  default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
    Objects.requireNonNull(action);
    for (T t : this) {
      action.accept(t);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多细节，可以参考这篇文章：https://ebnbin.com/2015/12/20/java-8-default-methods/&lt;/p&gt;
&lt;p&gt;:::&lt;strong&gt;caution&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;向现有接口添加新方法充满了风险。在存在默认方法的情况下，接口的现有实现&lt;strong&gt;可能&lt;/strong&gt;编译没有错误或警告，但在运行时会失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;:::&lt;strong&gt;good&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除非有必要，否则应避免使用默认方法向现有接口添加新方法，在这种情况下，你应该认真考虑一下现有接口实现是否会被默认方法实现破坏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上都是需要注意的，但是默认方法对于在创建接口时提供标准方法实现非常有用，它能简化实现接口的任务。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/30412517/&#34;&gt;Effective Java, By Joshua Bloch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ebnbin.com/2015/12/20/java-8-default-methods/&#34;&gt;Java 8 Default Methods, By Ebn Zhang&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">Java 抽象类和接口</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/add-icon-to-ubuntu-dash/"" data-c="
          &lt;p&gt;我们建设以创建 Eclipse 程序图标为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进入图标存放目录|：&lt;code&gt;cd /usr/share/applications&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建文件并编辑：&lt;code&gt;sudo gedit eclipse.desktop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[Desktop Entry]
Name=eclipse
Name[zh_CN]=eclipse
Comment=eclipse Client
Exec=/usr/programa/tools/eclipse/eclipse
Icon=/usr/programa/tools/eclipse/icon.xpm
Terminal=false
Type=Application
Categories=Application;
Encoding=UTF-8
StartupNotify=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点参数说明（注意：路径使用完整路径）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Name 为你想要显示在 Launcher 中的名称&lt;/li&gt;
&lt;li&gt;Comment 为说明。&lt;/li&gt;
&lt;li&gt;Exec 为程序执行位置&lt;/li&gt;
&lt;li&gt;Icon 为图标所在路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，打开 Dash，在顶部搜索框搜索 eclipse，此时你应该能搜到它，先单击试一下看能不能打开，如果可以打开，拖到该图标启动器上，下次就可以直接从启动器打开了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://my.oschina.net/Obahua/blog/110612&#34;&gt;Ubuntu 将 Sublime Text 添加到 Launcher 和其它方式 原&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/enein/articles/2818864.html&#34;&gt;Ubuntu 12.10 程序图标放到启动器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-26404477-id-3462663.html&#34;&gt;向Ubuntu Dash中添加图标&lt;/a&gt;\&lt;/li&gt;
&lt;/ul&gt;
">Ubuntu中给Dash创建图标</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/final-finally-finalize-in-java/"" data-c="
          &lt;h2 id=&#34;final&#34;&gt;final&lt;/h2&gt;
&lt;p&gt;final是Java里面的一个关键字，可以用来修饰成员变量、局部变量、类、方法。&lt;/p&gt;
&lt;p&gt;final修饰的类不能被继承，比方说String，Integer以及其他包装类。&lt;/p&gt;
&lt;p&gt;final修饰的方法不能被重写。&lt;/p&gt;
&lt;p&gt;final修饰的基本类型变量不可以被修改，修饰的其他类型变量的引用不能被修改。也就是说如果&lt;code&gt;final int a=10&lt;/code&gt;，那么这个&lt;code&gt;a&lt;/code&gt;变量以后就不能再给它赋值成别的值了。而修饰的非基本类型变量的话，该变量的引用指向的堆里面的内容是可以修改的，比如说：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;final List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&amp;quot;item1&amp;quot;);
list.add(&amp;quot;item2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述操作是合法的。&lt;/p&gt;
&lt;p&gt;final修饰的String类型再第一次赋值之后，也不能再重新赋值了，因为不管是采用下面哪种方式创建的String对象，如果再次赋值，该对象指向的引用就会变化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;final String string1 = new String(&amp;quot;string1&amp;quot;);
final String string2 = &amp;quot;string2&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，匿名内部类如果需要用到外面的局部变量，该变量必须是final类型。&lt;/p&gt;
&lt;p&gt;final修饰局部变量时，局部变量必须在声明时就赋值。&lt;/p&gt;
&lt;p&gt;没有在声明时初始化的final成员变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。&lt;/p&gt;
&lt;p&gt;接口中的声明的变量始终都是 &lt;code&gt;publis static final&lt;/code&gt; 类型的。&lt;/p&gt;
&lt;h2 id=&#34;finally&#34;&gt;finally&lt;/h2&gt;
&lt;p&gt;finally用于在异常处理时处理一些收尾工作，比方说输入输出流、JDBC数据库连接打开后不管成功成功还是失败，都要将其关闭，释放资源。常用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;try{
  ......
}catch (Exception e){
  ......
}finally {
  ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;finalize&#34;&gt;finalize&lt;/h2&gt;
&lt;p&gt;finalize是Object类中定义的方法，用于垃圾回收。Object类中该方法的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;protected void finalize() throws Throwable { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当对某个对象垃圾收集确定没有更多引用时被垃圾收集器调用。子类重写&lt;code&gt;finalize&lt;/code&gt;方法来处理系统资源或者做其他清理工作。&lt;/p&gt;
&lt;p&gt;一般来说，finalize方法都是在Java虚拟机发现去除那些已经被执行了finalize的对象之外，没有任何活动的线程能够引用到该对象的时候调用。finalize方法可以做任何事情，包括使这个对象可以被其他进程访问；但是通常finalize的目的是在对象被真正回收之前做一些清理工作。例如，一个对象的finalize方法表示输入/输出连接可能在对象被永久回收前执行显式I/O事务来中断连接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt;类的finalize方法不执行特别的操作，它只是简单地返回。&lt;code&gt;Object&lt;/code&gt;子类可以重写这个方法。&lt;/p&gt;
&lt;p&gt;Java编程语言不保证对于任何给定的对象哪个线程将调用finalize方法，但是它保证执行finalize的线程在调用finalize方法后不会一直保持任何用户可见的同步锁。如果finalize方法中抛出一个没有catch的异常，这个异常将会被忽略并且对象的finalize将终止。&lt;/p&gt;
&lt;p&gt;在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。&lt;/p&gt;
&lt;p&gt;对于任何给定的对象，finalize最多被Java虚拟机执行一次。&lt;/p&gt;
&lt;p&gt;finalize方法抛出的任何异常将导致这个对象的终结操作停止，但也会被忽略。（抛出异常后，该对象还是不可以继续操作，不会影响其他对象，直到被虚拟机回收）&lt;/p&gt;
&lt;p&gt;建议尽量避免使用它，它不是C/C++中的析构函数，而是Java诞生时为了使c/c++程序员更容易接受它所做的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对对象的调用顺序。虽然注释中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种安慰，finalize()能做的所用工作，使用try-finally或者其他方式都可以做的更好，更及时。&lt;/p&gt;
&lt;h2 id=&#34;参考资源&#34;&gt;参考资源&lt;/h2&gt;
&lt;p&gt;JDK 1.7 源码&lt;/p&gt;
&lt;p&gt;Effective Java&lt;/p&gt;
&lt;p&gt;http://www.importnew.com/7553.html&lt;/p&gt;
&lt;p&gt;http://s1099.iteye.com/blog/1447714&lt;/p&gt;
&lt;p&gt;http://www.xuebuyuan.com/813760.html&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/cyp331203/article/details/44461021&lt;/p&gt;
&lt;p&gt;http://www.debugease.com/j2se/820363.html&lt;/p&gt;
&lt;p&gt;http://www.programgo.com/article/6855606134/&lt;/p&gt;
">Java中的final、finally和finalize</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/release-it-design-and-deploy-production-ready-software/"" data-c="
          &lt;h1 id=&#34;笔记&#34;&gt;笔记&lt;/h1&gt;
&lt;p&gt;早期决策对系统的最终形态影响最大，最初的决策最难以更改。这个时候团队对软件的最终结构最无知，但必须要做出某些不可更改的决策。&lt;/p&gt;
&lt;p&gt;敏捷强调及早发布并持续改进，意味着软件可以尽快投入使用，因为软件投入使用是唯一得知软件如何响应真实世界刺激的途径。&lt;/p&gt;
&lt;p&gt;发布1.0版是软件生命的开始，而不是项目的结束。1.0版发布后，你的生活质量取决于你在这个重要里程碑之前所做的选择。&lt;/p&gt;
&lt;p&gt;对于那些还没有被取消或废弃的系统来说，系统的运营时间要远远多于开发时间，靠承担经常性运营成本来避免一次性成本，是没有意义的。&lt;/p&gt;
&lt;p&gt;宕机后恢复服务是优先级最高的任务。重大事故之后的管理认知和管理事故本身同样重要。&lt;/p&gt;
&lt;p&gt;系统寿命受到的主要威胁是内存泄露和数据疯涨。&lt;/p&gt;
&lt;p&gt;有条墨菲定律，只要你不针对某种失效情况特别做测试，它一定会发生。&lt;/p&gt;
&lt;p&gt;最初的触发点，裂痕扩散的方式和损坏的结果，并称为故障模式。&lt;/p&gt;
&lt;p&gt;代码耦合得越紧，代码错误扩散的机会也越大。反之，代码越松散，就如同减震器一样越能消除而非扩大这种错误的影响。&lt;/p&gt;
&lt;p&gt;考虑下面各种可能存在的冲击和压力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果我不启动连接？&lt;/li&gt;
&lt;li&gt;如果连接需要10分钟？&lt;/li&gt;
&lt;li&gt;如果已经连接，那它如何断开连接？&lt;/li&gt;
&lt;li&gt;如果已经连接，而我却不能得到另一端的任何响应？&lt;/li&gt;
&lt;li&gt;如果需要2分钟来回应我的查询请求？&lt;/li&gt;
&lt;li&gt;如果同时有10000个请求？&lt;/li&gt;
&lt;li&gt;如果网络陷入蠕虫的攻击而瘫痪，而我要将关于SQLException异常发生的错误信息写入日志时，我的磁盘已满？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络永远是不可靠的，超时是让你放弃等待你认为不会到来的响应的一种简单机制。设置合理的超时可以隔离故障，在其他系统、子系统或设备中的问题不会成为你的问题。所有阻塞线程的资源池都应设置一个超时，以确保不管资源最后是否可用，线程都可以被解除阻塞。如果不这么做，就可能会永远等待了。&lt;/p&gt;
&lt;p&gt;电路中的保险丝，自己先失效，从而控制整体失效。但是有人自己使用高电流低电阻的保险丝，从而不起到保险作用。软件系统中也可以使用断路器来保护。检测过度使用，然后先失效（跳闸），可以再重新设置恢复系统使用。&lt;/p&gt;
">发布！软件的设计与部署</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/handle-password-expire-in-oracle/"" data-c="
          &lt;p&gt;Oracle的用户密码默认是有一定的有效期限，前一阵子有提示密码快过期但是没理睬，于是等过期之后就无法用那个用户名连接oracle数据库了。&lt;/p&gt;
&lt;p&gt;首先看看服务器里面的数据库连接配置使用了哪些用户名和密码，然后进入oracle用system用户连接，接下来，执行下面的SQL语句查看当前数据库中所有用户的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT USERNAME,ACCOUNT_STATUS FROM DBA_USERS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询结果类似这样：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;USERNAME&lt;/th&gt;
&lt;th&gt;ACCOUNT_STATUS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TEST1&lt;/td&gt;
&lt;td&gt;OPEN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEST2&lt;/td&gt;
&lt;td&gt;LOCKED&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEST3&lt;/td&gt;
&lt;td&gt;EXPIRED &amp;amp;LOCKED&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SYSTEM&lt;/td&gt;
&lt;td&gt;LOCKER&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果嫌密码总是会过期比较麻烦的话，可以执行下面的SQL语句，让密码生命周期不受限制：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对已经过期的用户，如TEST3，需要重置它的密码（如密码设为test3）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER USER TEST3 IDENTIFIED BY test3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后解除用户的锁定，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER USER TEST3 ACCOUNT UNLOCK;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hecpv.wordpress.com/2014/10/16/how-to-solve-ora-28001-the-password-has-expired/&#34;&gt;https://hecpv.wordpress.com/2014/10/16/how-to-solve-ora-28001-the-password-has-expired/&lt;/a&gt;&lt;/p&gt;
">Oracle用户密码过期解决</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/reetrantlock-in-java/"" data-c="
          &lt;h2 id=&#34;类说明&#34;&gt;类说明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ReetrantLock&lt;/code&gt;是一个可重入排它&lt;code&gt;Lock&lt;/code&gt;，和使用&lt;code&gt;synchronized&lt;/code&gt;方法和语句的隐式监视器锁有着相同的基本行为和语义，但是有着扩展性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;由上次成功加锁但是还没有解锁的线程所持有。在锁没有被其他线程持有时，一个线程调用&lt;code&gt;lock&lt;/code&gt;将返回成功获取锁。如果当前线程已经持有锁那么该方法将立即返回。这个可以使用方法&lt;code&gt;isHeldByCurrentThread&lt;/code&gt;和&lt;code&gt;getHoldCount&lt;/code&gt;检查。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;这个类的构造器接收一个可选的公平性参数。当设为 true 时，在争用的情况下，锁倾向于授权给等待时间最长的线程。另外，这个锁不保证任何特定访问顺序。使用被多个线程访问的公平锁的程序将呈现比使用默认设置的情况较低的总吞吐量（也就是变慢了，通常是慢很多），但是在获取锁和保证不饥饿的时间上有较小的方差。&lt;/p&gt;
&lt;p&gt;公平锁可以保证锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程饥饿，但是较少线程切换，保证了很大的吞吐量。&lt;/p&gt;
&lt;p&gt;同样需要注意的是，不计时的&lt;code&gt;tryLock()&lt;/code&gt;方法不赞成公平设置。如果锁是可用的它将成功获得锁，而不管其他线程是否正在等待。&lt;/p&gt;
&lt;p&gt;建议实践时永远在&lt;code&gt;lock&lt;/code&gt;后面立即跟上一个&lt;code&gt;try&lt;/code&gt;块，大多数典型的在构造之前/之后的情况是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class X{
	private final ReentrantLock lock = new ReentrantLock();
	//...
	public void m(){
		lock.lock(); // block until condition holds
		try{
			// ... method body
		} finally {
			lock.unlock();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了实现&lt;code&gt;Lock&lt;/code&gt;接口，这个类定义了大量 public 和 protected 方法来检查锁的状态。其中有一些方法只用于仪表和监控。&lt;/p&gt;
&lt;p&gt;这个类的序列化和内置锁的行为方式一致：反序列化的锁是处于解锁状态，在序列化的时候不管当前它的状态。&lt;/p&gt;
&lt;p&gt;这个锁支持相同线程递归锁最大2147483647次。尝试超过这个限制将导致从加锁方法抛出&lt;code&gt;Error&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;JDK 1.7&lt;/p&gt;
">Java中的可重入锁ReetrantLock</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/readwrite-lock-in-java/"" data-c="
          &lt;p&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;是&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;下面的接口，其内部方法结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public interface ReadWriteLock{
	Lock readLock();
	Lock writeLock();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;
&lt;p&gt;一个&lt;code&gt;ReadWriteLock&lt;/code&gt;维护一组关联的锁，一个用于只读的操作，另一个用来写。读锁可以被多个读线程同时持有，只要当前没有写线程。而写锁是排它的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;的所有实现必须保证&lt;code&gt;writeLock&lt;/code&gt;操作的内存同步影响（在&lt;code&gt;Lock&lt;/code&gt;接口中定义的），也保持关联的&lt;code&gt;readLock&lt;/code&gt;的影响。也就是说，一个成功获取读锁的线程将看到写锁之前版本所做的所有更新。&lt;/p&gt;
&lt;p&gt;读写锁访问共享数据比允许一个排它锁的并发性大很多。它利用一次只有一个线程可以修改共享数据，大多数情况下任意数量可以同步读取数据的现实（所以叫读线程）。理论上，允许读写锁的使用对并发性的提高将导致比使用一个排它锁带来性能提升。在实践中，这个并发改善只有在多处理器上能够完全实现，并且只有共享数据的访问模式是合适的。&lt;/p&gt;
&lt;p&gt;读写锁与排它锁是否提高性能取决于数据被读以及被修改的频率比较，读和写操作的持续时间，以及数据的争用情况——也就是说，同一时间尝试去读或尝试去写数据的线程的数量。例如，最初填充数据的集合此后很少被修改，而且频繁被搜索（比如一个目录），这就是读写锁使用的理想选择。但是，如果更新变的频繁，那么数据花费大量时间被排它锁定，那么就很少有并发上的提升。而且，如果读操作时间太短，读写锁实现的开销（读写锁所固有的比一个排它锁更复杂）可能在执行消耗中占主要部分，尤其是很多读写锁实现仍然通过一小段代码序列化所有线程。最终，只有分析和测量才能确定使用读写锁是否适合于你的应用。&lt;/p&gt;
&lt;p&gt;尽管读写锁的基本操作是很简单，实现需要做出很多政策决定，这个将影响给定应用中的读写锁的效率。这些政策包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当写线程释放写锁时，此时有读线程和写线程都在等待，确定是授权读锁还是写锁。通常倾向于给写线程，因为写操作一般比较短而且不频繁。通常不倾向于给读线程，因为如一般情况下那样如果读线程频繁写存活时间长读操作可能导致写的时间延迟。公平的讲，或者“按照顺序”的实现也是可以的。&lt;/li&gt;
&lt;li&gt;当一个读线程活跃且一个写线程等待时，确定是否有读线程请求读锁，然后授权读锁。倾向于给读线程可能使得写线程无限期延迟，而倾向于写线程可能减少并发的潜力。&lt;/li&gt;
&lt;li&gt;确定锁是否是可重入的：一个带写锁的线程能否重复获取写锁？当持有写锁的时候能否获取读锁？读锁本身是否可重入？&lt;/li&gt;
&lt;li&gt;写锁能否在不允许干预写线程的情况下降级到读锁？读锁能否升级到写锁，优先于其他等待的读线程和写线程？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你应该在评估你应用的给定实现时考虑以上全部4点。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;JDK 1.7&lt;/p&gt;
">Java中的ReadWriteLock</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/about/"" data-c="
          &lt;ul&gt;
&lt;li&gt;后端工程师&lt;/li&gt;
&lt;li&gt;最近对分布式有点兴趣&lt;/li&gt;
&lt;li&gt;以前在上海和苏州，现在在上海和苏州之间&lt;/li&gt;
&lt;/ul&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>



</html>