<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Goroyal technical blog">
<meta name="description" content="学习分享">
<meta name="theme-color" content="#000">
<title>Java中的ReadWriteLock | Goroyal&#39;s blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1596369367640">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="Java中的ReadWriteLock" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Goroyal&#39;s blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">学习分享</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Goroyal</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>后端工程师</p>
      
        <p>最近对分布式有点兴趣</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">30</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E">接口说明</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
    <h1 class="post-title">
        <a class="post-title-link" href="http://goroyal.github.io/post/readwrite-lock-in-java/">
            Java中的ReadWriteLock
        </a>
    </h1>
    <div class="post-meta">
        
                <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
                <span>2015-08-06</span>
                <span class="post-meta-divider pc-show">|</span>
                </span>
                
                                            <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4<span class="language" data-lan="minute">分钟</span></span>
                                            </span>
                                            <span class="meta-item">
      <span class="post-meta-divider">|</span>
                                            <i class="fa fa-file-word-o"></i>
                                            <span>922<span class="pc-show language" data-lan="words">字数</span></span>
                                            </span>
                                            
                                                
                                                    
                                                                <!-- <span id="/post/readwrite-lock-in-java/" data-flag-title="Java中的ReadWriteLock" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span> -->
                                                                
    </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p><code>ReadWriteLock</code>是<code>java.util.concurrent.locks</code>下面的接口，其内部方法结构如下：</p>
<pre><code class="language-Java">public interface ReadWriteLock{
	Lock readLock();
	Lock writeLock();
}
</code></pre>
<h2 id="接口说明">接口说明</h2>
<p>一个<code>ReadWriteLock</code>维护一组关联的锁，一个用于只读的操作，另一个用来写。读锁可以被多个读线程同时持有，只要当前没有写线程。而写锁是排它的。</p>
<p><code>ReadWriteLock</code>的所有实现必须保证<code>writeLock</code>操作的内存同步影响（在<code>Lock</code>接口中定义的），也保持关联的<code>readLock</code>的影响。也就是说，一个成功获取读锁的线程将看到写锁之前版本所做的所有更新。</p>
<p>读写锁访问共享数据比允许一个排它锁的并发性大很多。它利用一次只有一个线程可以修改共享数据，大多数情况下任意数量可以同步读取数据的现实（所以叫读线程）。理论上，允许读写锁的使用对并发性的提高将导致比使用一个排它锁带来性能提升。在实践中，这个并发改善只有在多处理器上能够完全实现，并且只有共享数据的访问模式是合适的。</p>
<p>读写锁与排它锁是否提高性能取决于数据被读以及被修改的频率比较，读和写操作的持续时间，以及数据的争用情况——也就是说，同一时间尝试去读或尝试去写数据的线程的数量。例如，最初填充数据的集合此后很少被修改，而且频繁被搜索（比如一个目录），这就是读写锁使用的理想选择。但是，如果更新变的频繁，那么数据花费大量时间被排它锁定，那么就很少有并发上的提升。而且，如果读操作时间太短，读写锁实现的开销（读写锁所固有的比一个排它锁更复杂）可能在执行消耗中占主要部分，尤其是很多读写锁实现仍然通过一小段代码序列化所有线程。最终，只有分析和测量才能确定使用读写锁是否适合于你的应用。</p>
<p>尽管读写锁的基本操作是很简单，实现需要做出很多政策决定，这个将影响给定应用中的读写锁的效率。这些政策包括：</p>
<ul>
<li>当写线程释放写锁时，此时有读线程和写线程都在等待，确定是授权读锁还是写锁。通常倾向于给写线程，因为写操作一般比较短而且不频繁。通常不倾向于给读线程，因为如一般情况下那样如果读线程频繁写存活时间长读操作可能导致写的时间延迟。公平的讲，或者“按照顺序”的实现也是可以的。</li>
<li>当一个读线程活跃且一个写线程等待时，确定是否有读线程请求读锁，然后授权读锁。倾向于给读线程可能使得写线程无限期延迟，而倾向于写线程可能减少并发的潜力。</li>
<li>确定锁是否是可重入的：一个带写锁的线程能否重复获取写锁？当持有写锁的时候能否获取读锁？读锁本身是否可重入？</li>
<li>写锁能否在不允许干预写线程的情况下降级到读锁？读锁能否升级到写锁，优先于其他等待的读线程和写线程？</li>
</ul>
<p>你应该在评估你应用的给定实现时考虑以上全部4点。</p>
<h2 id="参考资料">参考资料</h2>
<p>JDK 1.7</p>

            </div>
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Goroyal
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="http://goroyal.github.io/post/readwrite-lock-in-java/" title="Java中的ReadWriteLock">http://goroyal.github.io/post/readwrite-lock-in-java/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Java中的可重入锁ReetrantLock" href="http://goroyal.github.io/post/reetrantlock-in-java/">Java中的可重入锁ReetrantLock</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Java中的可重入锁ReetrantLock" href="http://goroyal.github.io/post/reetrantlock-in-java/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
    <footer class="footer">
        <div class="copyright">
        </div>
        <div class="poweredby">
            Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2015-2020
        </div>
    </footer>
    
        
                <div class="gemini back-to-top" id="back_to_top">
                    <i class="fa fa-arrow-up"></i>
                    
                        <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
                        </span>
                        
                </div>
                
                            
                                        
</div>
<script>
    let sideBarOpen = 'sidebar-open';
    let body = document.body;
    let back2Top = document.querySelector('#back_to_top'),
        back2TopText = document.querySelector('#back_to_top_text'),
        drawerBox = document.querySelector('#drawer_box'),
        rightSideBar = document.querySelector('.sidebar'),
        viewport = document.querySelector('body');

    function scrollAnimation(currentY, targetY) {

        let needScrollTop = targetY - currentY
        let _currentY = currentY
        setTimeout(() => {
            const dist = Math.ceil(needScrollTop / 10)
            _currentY += dist
            window.scrollTo(_currentY, currentY)
            if (needScrollTop > 10 || needScrollTop < -10) {
                scrollAnimation(_currentY, targetY)
            } else {
                window.scrollTo(_currentY, targetY)
            }
        }, 1)
    }

    back2Top.addEventListener("click", function(e) {
        scrollAnimation(document.scrollingElement.scrollTop, 0);
        e.stopPropagation();
        return false;
    });

    window.addEventListener('scroll', function(e) {
        let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
        if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
            back2Top.classList.add('back-top-active');
        }
        if (percent == 0) {
            back2Top.classList.remove('back-top-active');
        }
        if (back2TopText) {
            back2TopText.textContent = Math.floor(percent);
        }
    });


    let hasCacu = false;
    window.onresize = function() {
        if (window.width > 991) {
            calcuHeight();
        } else {
            hasCacu = false;
        }
    }

    function calcuHeight() {
        // 动态调整站点概览高度
        if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
            let sideBar = document.querySelector('.sidebar');
            let navUl = document.querySelector('#site_nav');
            sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
            hasCacu = true;
        }
    }
    calcuHeight();

    let open = false,
        MOTION_TIME = 300,
        RIGHT_MOVE_DIS = '320px';

    if (drawerBox) {
        let rightMotions = document.querySelectorAll('.right-motion');
        let right = drawerBox.classList.contains('right');

        let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

        let openProp, closeProp;
        if (right) {
            openProp = {
                paddingRight: RIGHT_MOVE_DIS
            };
            closeProp = {
                paddingRight: '0px'
            };
        } else {
            openProp = {
                paddingLeft: RIGHT_MOVE_DIS
            };
            closeProp = {
                paddingLeft: '0px'
            };
        }

        drawerBox.onclick = function() {
            open = !open;
            window.Velocity(rightSideBar, 'stop');
            window.Velocity(viewport, 'stop');
            window.Velocity(rightMotions, 'stop');
            if (open) {
                window.Velocity(rightSideBar, {
                    width: RIGHT_MOVE_DIS
                }, {
                    duration: MOTION_TIME,
                    begin: function() {
                        window.Velocity(rightMotions, transitionDir, {});
                    }
                })
                window.Velocity(viewport, openProp, {
                    duration: MOTION_TIME
                });
            } else {
                window.Velocity(rightSideBar, {
                    width: '0px'
                }, {
                    duration: MOTION_TIME,
                    begin: function() {
                        window.Velocity(rightMotions, {
                            opacity: 0
                        });
                    }
                })
                window.Velocity(viewport, closeProp, {
                    duration: MOTION_TIME
                });
            }
            for (let i = 0; i < drawerBox.children.length; i++) {
                drawerBox.children[i].classList.toggle('muse-line');
            }
            drawerBox.classList.toggle(sideBarOpen);
        }
    }

    // 链接跳转
    let newWindow = 'false'
    if (newWindow === 'true') {
        let links = document.querySelectorAll('.post-body a')
        links.forEach(item => {
            if (!item.classList.contains('btn')) {
                item.setAttribute("target", "_blank");
            }
        })
    }

    let faSearch = document.querySelector('#fa_search');
    faSearch.addEventListener('click', function() {
        document.querySelector('#search_mask').style = ''
    })

    // 代码高亮
    hljs.initHighlightingOnLoad();
</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-volatile/"" data-c="
          &lt;h2 id=&#34;volatile语义&#34;&gt;volatile语义&lt;/h2&gt;
&lt;p&gt;一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。&lt;/li&gt;
&lt;li&gt;禁止进行指令重排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class VolatileExample extends Thread{
    //设置类静态变量,各线程访问这同一共享变量
    private  static boolean flag = false;
    //无限循环,等待flag变为true时才跳出循环
   public void run() {
       while (!flag){
       };
       System.out.println(&amp;quot;停止了&amp;quot;);
   }

    public static void main(String[] args) throws Exception {
        new VolatileExample().start();
        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了
        Thread.sleep(100);
        flag = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当把上面代码中变量flag改成下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private  static valotile boolean flag = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行的话，你就会发现打印了“停止了”信息，因为用volatile修饰之后就变得不一样了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一：使用volatile关键字会强制将修改的值立即写入主存；&lt;/li&gt;
&lt;li&gt;第二：使用volatile关键字的话，当线程main进行修改时，会导致线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；&lt;/li&gt;
&lt;li&gt;第三：由于线程那么线程VolatileExample的工作内存中缓存变量flag的缓存行无效，所以线程那么线程VolatileExample再次读取变量flag的值时会去主存读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么在线程main修改flag值时（当然这里包括2个操作，修改线程main工作内存中的值，然后将修改后的值写入内存），会使得线程VolatileExample的工作内存中缓存变量flag的缓存行无效，然后线程读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。&lt;/p&gt;
&lt;p&gt;那么线程VolatileExample读取到的就是最新的正确的值。&lt;br&gt;
使用volatile关键字增加了实例变量在多个线程之间的可见性。但是volatile关键字最致命的缺点是不支持原子性。&lt;/p&gt;
&lt;p&gt;下面将关键字synchronized和volatile进行一下比较：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。&lt;/li&gt;
&lt;li&gt;多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。&lt;/li&gt;
&lt;li&gt;volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它将私有内存和公共内存中的数据做同步。&lt;/li&gt;
&lt;li&gt;再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;volatile非原子的特性&#34;&gt;volatile非原子的特性&lt;/h2&gt;
&lt;p&gt;从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？&lt;br&gt;
下面看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
         
         //保证前面的线程都执行完
        while(Thread.activeCount()&amp;gt;1)
   			Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也许有些朋友认为输出结果是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。可能有人会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。&lt;/p&gt;
&lt;p&gt;这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。&lt;/p&gt;
&lt;p&gt;在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：&lt;/p&gt;
&lt;p&gt;假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；&lt;/p&gt;
&lt;p&gt;然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值是10，然后进行加1操作，并把11写入工作内存，最后写入主存。&lt;/p&gt;
&lt;p&gt;然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。&lt;/p&gt;
&lt;p&gt;那么两个线程分别进行了一次自增操作后，inc只增加了1。&lt;/p&gt;
&lt;p&gt;虽然happens-before规则中的volatile变量规则是保证一个变量在修改volatile变量时，会让缓存行无效吗，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把上面的代码改成以下任何一种都可以达到效果：&lt;br&gt;
采用synchronized：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public  int inc = 0;
    
    public synchronized void increase() {
        inc++;
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&amp;gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;采用Lock：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();
    
    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&amp;gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;采用AtomicInteger：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Test {
    public  AtomicInteger inc = new AtomicInteger();
     
    public  void increase() {
        inc.getAndIncrement();
    }
    
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&amp;lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&amp;lt;1000;j++)
                        test.increase();
                };
            }.start();
        }
        
        while(Thread.activeCount()&amp;gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。&lt;/p&gt;
&lt;h2 id=&#34;volatile能保证有序性&#34;&gt;volatile能保证有序性&lt;/h2&gt;
&lt;p&gt;在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。&lt;/p&gt;
&lt;p&gt;volatile关键字禁止指令重排序有两层意思：&lt;br&gt;
1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；&lt;/p&gt;
&lt;p&gt;2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。&lt;br&gt;
可能上面说的比较绕，举个简单的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。&lt;/p&gt;
&lt;h2 id=&#34;volatile的原理和实现机制&#34;&gt;volatile的原理和实现机制&lt;/h2&gt;
&lt;p&gt;前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。&lt;/p&gt;
&lt;p&gt;下面这段话摘自《深入理解Java虚拟机》：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。&lt;br&gt;
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；&lt;/li&gt;
&lt;li&gt;它会强制将对缓存的修改操作立即写入主存；&lt;/li&gt;
&lt;li&gt;如果是写操作，它会导致其他CPU中对应的缓存行无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对变量的写操作不依赖于当前值&lt;/li&gt;
&lt;li&gt;该变量没有包含在具有其他变量的不变式中&lt;/li&gt;
&lt;/ul&gt;
">Java volatile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/xian-cheng-zhong-de-3-ge-te-xing/"" data-c="
          &lt;h2 id=&#34;原子性&#34;&gt;原子性&lt;/h2&gt;
&lt;p&gt;在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。&lt;br&gt;
上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：&lt;br&gt;
请分析以下哪些操作是原子性操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。&lt;/p&gt;
&lt;p&gt;语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。所以上面4个语句只有语句1的操作具备原子性。&lt;/p&gt;
&lt;p&gt;也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。&lt;/p&gt;
&lt;p&gt;不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。&lt;/p&gt;
&lt;p&gt;从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。&lt;/p&gt;
&lt;h2 id=&#34;可见性&#34;&gt;可见性&lt;/h2&gt;
&lt;p&gt;对于可见性，Java提供了&lt;code&gt;volatile&lt;/code&gt;关键字来保证可见性。&lt;/p&gt;
&lt;p&gt;当一个共享变量被&lt;code&gt;volatile&lt;/code&gt;修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。&lt;/p&gt;
&lt;p&gt;而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。&lt;/p&gt;
&lt;p&gt;另外，通过&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;也能够保证可见性，&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。&lt;/p&gt;
&lt;h2 id=&#34;有序性&#34;&gt;有序性&lt;/h2&gt;
&lt;p&gt;在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。&lt;br&gt;
在Java里面，可以通过&lt;code&gt;volatile&lt;/code&gt;关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;来保证有序性，很显然，&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;Lock&lt;/code&gt;保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。&lt;/p&gt;
&lt;p&gt;另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。&lt;/p&gt;
&lt;h3 id=&#34;happens-before原则先行发生原则&#34;&gt;happens-before原则（先行发生原则）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作&lt;/li&gt;
&lt;li&gt;锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作&lt;/li&gt;
&lt;li&gt;volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作&lt;/li&gt;
&lt;li&gt;传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C&lt;/li&gt;
&lt;li&gt;线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作&lt;/li&gt;
&lt;li&gt;线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生&lt;/li&gt;
&lt;li&gt;线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行&lt;/li&gt;
&lt;li&gt;对象终结规则：一个对象的初始化完成先行发生于它的&lt;code&gt;finalize()&lt;/code&gt;方法的开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这8条原则摘自《深入理解Java虚拟机》。&lt;br&gt;
这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。&lt;/p&gt;
&lt;p&gt;下面我们来解释一下前4条规则：&lt;br&gt;
对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。&lt;/p&gt;
&lt;p&gt;第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。&lt;/p&gt;
&lt;p&gt;第三条规则是一条比较重要的规则，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。&lt;/p&gt;
&lt;p&gt;第四条规则实际上就是体现happens-before原则具备传递性。&lt;/p&gt;
">线程中的3个特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-lock/"" data-c="
          &lt;h2 id=&#34;锁状态&#34;&gt;锁状态&lt;/h2&gt;
&lt;p&gt;Java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁自旋&lt;/strong&gt;&lt;br&gt;
我们知道在当某个线程在进入同步方法/代码块时若发现该同步方法/代码块被其他现在所占，则它就要等待，进入阻塞状态，这个过程性能是低下的。&lt;/p&gt;
&lt;p&gt;在遇到锁的争用或许等待事，线程可以不那么着急进入阻塞状态，而是等一等，看看锁是不是马上就释放了，这就是锁自旋。锁自旋在一定程度上可以对线程进行优化处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;br&gt;
偏向锁主要为了解决在没有竞争情况下锁的性能问题。在大多数情况下锁锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当某个线程获得锁的情况，该线程是可以多次锁住该对象，但是每次执行这样的操作都会因为CAS（CPU的Compare-And-Swap指令）操作而造成一些开销消耗性能，为了减少这种开销，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。&lt;/p&gt;
&lt;p&gt;当有其他线程在尝试着竞争偏向锁时，持有偏向锁的线程就会释放锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁膨胀&lt;/strong&gt;&lt;br&gt;
多个或多次调用粒度太小的锁，进行加锁解锁的消耗，反而还不如一次大粒度的锁调用来得高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;br&gt;
轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。轻量级锁在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的指向和状态。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。&lt;/p&gt;
&lt;h2 id=&#34;加锁方式&#34;&gt;加锁方式&lt;/h2&gt;
&lt;p&gt;在使用synchronized时，我们是这样使用锁的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadTest {
    public void test(){
        synchronized(this){
            //do something
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;synchronized可以确保在同一时间内只有一个线程在执行dosomething。下面是使用lock替代synchronized：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadTest {
    Lock lock = new Lock();
    public void test(){
        lock.lock();
        //do something
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。&lt;/p&gt;
&lt;h2 id=&#34;锁的公平性&#34;&gt;锁的公平性&lt;/h2&gt;
&lt;p&gt;公平性的对立面是饥饿。那么什么是“饥饿”呢？如果一个线程因为其他线程在一直抢占着CPU而得不到CPU运行时间，那么我们就称该线程被“饥饿致死”。而解决饥饿的方案则被称之为“公平性”——所有线程均可以公平地获得CPU运行机会。&lt;/p&gt;
&lt;p&gt;导致线程饥饿主要有如下几个原因：&lt;br&gt;
高优先级线程吞噬所有的低优先级线程的CPU时间。我们可以为每个线程单独设置其优先级，从1到10。优先级越高的线程获得CPU的时间越多。对大多数应用来说，我们最好是不要改变其优先级值。&lt;/p&gt;
&lt;p&gt;线程被永久堵塞在一个等待进入同步块的状态。Java的同步代码区是导致线程饥饿的重要因素。Java的同步代码块并不会保证进入它的线程的先后顺序。这就意味着理论上存在一个或者多个线程在试图进入同步代码区时永远被堵塞着，因为其他线程总是不断优于他获得访问权，导致它一直得到不到CPU运行机会被“饥饿致死”。&lt;/p&gt;
&lt;p&gt;线程在等待一个本身也处于永久等待完成的对象。如果多个线程处在&lt;code&gt;wait()&lt;/code&gt;方法执行上，而对其调用&lt;code&gt;notify()&lt;/code&gt;不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。&lt;/p&gt;
&lt;p&gt;为了解决线程“饥饿”的问题，我们可以使用锁实现公平性。&lt;/p&gt;
&lt;h2 id=&#34;锁的可重入性&#34;&gt;锁的可重入性&lt;/h2&gt;
&lt;p&gt;我们知道当线程请求一个由其它线程持有锁的对象时，该线程会阻塞，但是当线程请求由自己持有锁的对象时，是否可以成功呢？答案是可以成功的，成功的保障就是线程锁的“可重入性”。&lt;br&gt;
“可重入”意味着自己可以再次获得自己的内部锁，而不需要阻塞。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Father {
    public synchronized void method(){
        //do something
    }
}
public class Child extends Father{
    public synchronized void method(){
        //do something 
        super.method();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果所是不可重入的，上面的代码就会死锁，因为调用child的method(),首先会获取父类Father的内置锁然后获取Child的内置锁，当调用父类的方法时，需要再次后去父类的内置锁，如果不可重入，可能会陷入死锁。&lt;/p&gt;
&lt;p&gt;java多线程的可重入性的实现是通过每个锁关联一个请求计算和一个占有它的线程，当计数为0时，认为该锁是没有被占有的，那么任何线程都可以获得该锁的占有权。当某一个线程请求成功后，JVM会记录该锁的持有线程 并且将计数设置为1，如果这时其他线程请求该锁时则必须等待。当该线程再次请求请求获得锁时，计数会+1；当占有线程退出同步代码块时，计数就会-1，直到为0时，释放该锁。这时其他线程才有机会获得该锁的占有权。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReentrantLock：一个可重入的互斥锁，为lock接口的主要实现。&lt;/li&gt;
&lt;li&gt;ReadWriteLock：ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。&lt;/li&gt;
&lt;li&gt;ReentrantReadWriteLock：可重入读写锁&lt;/li&gt;
&lt;li&gt;Semaphore：一个计数信号量。&lt;/li&gt;
&lt;li&gt;Condition:锁的关联条件，目的是允许线程获取锁并且查看等待的某一个条件是否满足。&lt;/li&gt;
&lt;li&gt;CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。&lt;/li&gt;
&lt;/ul&gt;
">Java锁</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-synchronized/"" data-c="
          &lt;p&gt;synchronized，我们谓之锁，主要用来给方法、代码块加锁。当某个方法或者代码块使用synchronized时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。&lt;/p&gt;
&lt;p&gt;synchronized主要包括两种方法：synchronized 方法、synchronized 代码块。&lt;/p&gt;
&lt;p&gt;synchronized 方法通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized void getResult();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;synchronized方法控制对类成员变量的访问。它是如何来避免类成员变量的访问控制呢？我们知道方法使用了synchronized关键字表明该方法已加锁，在任一线程在访问改方法时都必须要判断该方法是否有其他线程在“独占”。每个类实例对应一个把锁，每个synchronized方法都必须调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，被阻塞的线程方能获得该锁。&lt;/p&gt;
&lt;p&gt;其实synchronized方法是存在缺陷的，如果我们将一个很大的方法声明为synchronized将会大大影响效率的。如果多个线程在访问一个synchronized方法，那么同一时刻只有一个线程在执行该方法，而其他线程都必须等待，但是如果该方法没有使用synchronized，则所有线程可以在同一时刻执行它，减少了执行的总时间。所以如果我们知道一个方法不会被多个线程执行到或者说不存在资源共享的问题，则不需要使用synchronized关键字。但是如果一定要使用synchronized关键字，那么我们可以synchronized代码块来替换synchronized方法。&lt;/p&gt;
&lt;p&gt;synchronized代码块所起到的作用和synchronized方法一样，只不过它使临界区变的尽可能短了，换句话说：它只把需要的共享数据保护起来，其余的长代码块留出此操作。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;synchronized(object) {  
    //允许访问控制的代码  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要以这种方式来使用synchronized关键字,那么必须要通过一个对象引用来作为参数,通常这个参数我们常使用为this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;synchronized (this) {
    //允许访问控制的代码 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于synchronized(this)有如下理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。&lt;/li&gt;
&lt;li&gt;然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问object中的非synchronized(this)同步代码块。&lt;/li&gt;
&lt;li&gt;尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其他synchronized(this)同步代码块得访问将被阻塞。&lt;/li&gt;
&lt;li&gt;第三个例子同样适用其他同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其他线程对该object对象所有同步代码部分的访问都将被暂时阻塞。&lt;/li&gt;
&lt;li&gt;以上规则对其他对象锁同样适用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java中每一个对象都可以作为锁，它主要体现在下面三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于同步方法，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;对于同步方法块，锁是Synchonized括号里配置的对象。&lt;/li&gt;
&lt;li&gt;对于静态同步方法，锁是当前对象的Class对象。&lt;/li&gt;
&lt;/ul&gt;
">Java synchronized</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-reetrantlock/"" data-c="
          &lt;p&gt;&lt;code&gt;ReetrantLock&lt;/code&gt;是一个可重入排它锁，和使用&lt;code&gt;synchronized&lt;/code&gt;方法和语句的隐式监视器锁有着相同的基本行为和语义，但是性能有所扩展。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;由上次成功加锁但是还没有解锁的线程所持有。在锁没有被其他线程持有时，一个线程调用&lt;code&gt;lock&lt;/code&gt;将返回成功获取锁。如果当前线程已经持有锁那么该方法将立即返回。这个可以使用方法&lt;code&gt;isHeldByCurrentThread&lt;/code&gt;和&lt;code&gt;getHoldCount&lt;/code&gt;检查。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;这个类的构造器接收一个可选的公平性参数。当设为 true 时，在争用的情况下，锁倾向于授权给等待时间最长的线程。另外，这个锁不保证任何特定访问顺序。使用被多个线程访问的公平锁的程序将呈现比使用默认设置的情况较低的总吞吐量（也就是变慢了，通常是慢很多），但是在获取锁和保证不饥饿的时间上有较小的方差。&lt;/p&gt;
&lt;p&gt;公平锁可以保证锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程饥饿，但是较少线程切换，保证了很大的吞吐量。&lt;/p&gt;
&lt;p&gt;同样需要注意的是，不计时的&lt;code&gt;tryLock()&lt;/code&gt;方法不赞成公平设置。如果锁是可用的它将成功获得锁，而不管其他线程是否正在等待。&lt;/p&gt;
&lt;p&gt;建议实践时永远在&lt;code&gt;lock&lt;/code&gt;后面立即跟上一个&lt;code&gt;try&lt;/code&gt;块，大多数典型的在构造之前/之后的情况是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class X {
	private final ReentrantLock lock = new ReentrantLock();
	//...
	public void m(){
		lock.lock(); // block until condition holds
		try{
			// ... method body
		} finally {
			lock.unlock();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了实现&lt;code&gt;Lock&lt;/code&gt;接口，&lt;code&gt;ReetrantLock&lt;/code&gt;类定义了大量 public 和 protected 方法来检查锁的状态，其中有一些方法只用于仪表和监控。这个类的序列化和内置锁的行为方式一致：反序列化的锁是处于解锁状态，在序列化的时候不管当前它的状态。&lt;/p&gt;
&lt;p&gt;这个锁支持相同线程递归锁最大2147483647次。尝试超过这个限制将导致从加锁方法抛出&lt;code&gt;Error&lt;/code&gt;。&lt;/p&gt;
">Java ReetrantLock</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/git-commands/"" data-c="
          &lt;p&gt;配置账号信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global user.name &amp;quot;your username&amp;quot;
git config --global user.email &amp;quot;your email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看配置相关的信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --list # 查看配置的信息
git help config # 获取帮助信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置自动换行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.autocrlf input # 提交到git时是否自动将换行符转换为lf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置密钥&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh-keygen -t rsa -C &amp;quot;your email&amp;quot; # 生成密钥
ssh -T git@github.com # 测试是否成功
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建仓库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git init # 初始化本地仓库
git clone &amp;lt;url&amp;gt; # 克隆远程版本库
git add –all # 添加所有文件到暂存区（stage，index）
git status # 查看当前git状态
git remote add origin https://github.com/freshdgq/test.git # 关联到远程仓库地址
git push -u origin master # 第一次推送master分支的所有内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改和提交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git status # 查看git当前状态
git diff # 查看改动后和改动前的不同之处
git add . # 跟踪所有改动过的文件
git add &amp;lt;file&amp;gt; # 跟踪指定的文件
git mv &amp;lt;old&amp;gt; &amp;lt;new&amp;gt; # 文件改名
git rm &amp;lt;file&amp;gt; # 删除指定文件
git rm --cached &amp;lt;file&amp;gt; # 停止跟踪文件但不删除
git commit -m &amp;quot;message&amp;quot; # 提交修改的文件到当前分支
git commit --amend # 修改最后一次提交
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;状态与版本处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log # 查看提交的历史记录
git log -p &amp;lt;file&amp;gt; # 查看指定文件的提交记录
git blame &amp;lt;file&amp;gt; # 以列表方式查看指定文件的提交历史
git reset --hard HEAD  # 撤销工作目录中所有未提交文件的修改内容
git checkout HEAD &amp;lt;file&amp;gt; # 撤销指定的未提交文件的修改内容
git revert &amp;lt;commit&amp;gt; 撤销指定的提交
git reset --hard HEAD^ # 回退本地分支到上一个版本
git reset --hard HEAD~n # 回退本地分支到上n个版本
git checkout – readme.txt # 把readme.txt文件在工作区的修改全部撤销
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分支与标签处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git branch # 查看本地所有分支
git checkout &amp;lt;branch/tag&amp;gt; # 切换到指定分支或标签

git branch &amp;lt;new-branch&amp;gt; # 创建新分支
git checkout -b &amp;lt;new-branch&amp;gt; # 创建并切换到新分支
git branch -d &amp;lt;branch&amp;gt; # 删除本地分支

git merge &amp;lt;branch&amp;gt; # 合并指定分支到当前分支
git rebase &amp;lt;branch&amp;gt; # 衍合指定分支到当前分支

git tag # 列出所有本地标签
git tag &amp;lt;tagname&amp;gt; # 基于最新提交创建标签
git tag -d &amp;lt;tagname&amp;gt; # 删除标签
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地远程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git remote # 获得远程库列表
git remote v # 查看远程版本库信息
git remote show &amp;lt;remote&amp;gt; # 查看指定远程版本库信息
git remote add &amp;lt;remote&amp;gt;&amp;lt;url&amp;gt; # 添加远程版本库
git remote rm &amp;lt;name&amp;gt; # 删除对应的远程库
git branch -u origin/master master # 本地跟踪远程

git fetch &amp;lt;remote&amp;gt; # 从远程库获取代码
git pull &amp;lt;remote&amp;gt;&amp;lt;branch&amp;gt; # 拉取远程指定分支代码并快速合并
git push &amp;lt;remote&amp;gt;&amp;lt;branch&amp;gt; # 推送代码到远程指定分支并快速合并
git push &amp;lt;remote&amp;gt;:&amp;lt;branch/tag-name&amp;gt; # 删除远程分支或标签
git push --tags # 上传所有标签

git pull origin master # 从远程的master分支拉取代码到本地
git push origin master # 推送最新修改到远程的主分支
&lt;/code&gt;&lt;/pre&gt;
">常用的Git命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/execute-script-in-web-page/"" data-c="
          &lt;p&gt;在当前页面的执行环境里执行脚本的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接嵌入&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;代码块&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt;加载远程代码&lt;/li&gt;
&lt;li&gt;在各种HTML和CSS参数里通过&lt;code&gt;javascript:URL&lt;/code&gt;触发调用&lt;/li&gt;
&lt;li&gt;CSS &lt;code&gt;expression(...)&lt;/code&gt;和某些浏览器里的XBL绑定&lt;/li&gt;
&lt;li&gt;事件处理器（Event Handlers），譬如onclick、onerror、onload等&lt;/li&gt;
&lt;li&gt;定时器Timers（setTimeout，setInterval）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval(...)&lt;/code&gt;调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表面上这些方法组合起来使用也很正常，但往往会造成极其难以预料的危险解析链传递。&lt;/p&gt;
">网页里面引起脚本执行的方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-baozhuang-class/"" data-c="
          &lt;h2 id=&#34;boolean&#34;&gt;Boolean&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt;内部维护了两个常量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以对于&lt;code&gt;Boolean a = true; Boolean b = true;&lt;/code&gt;，&lt;code&gt;a == b&lt;/code&gt;是得到true的。&lt;/p&gt;
&lt;h2 id=&#34;integer&#34;&gt;Integer&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Integer&lt;/code&gt;对一段范围内的数字有个缓存：IntegerCache.low ~ IntegerCache.high&lt;br&gt;
如果数字在这个范围内，两个integer &lt;code&gt;==&lt;/code&gt;是返回true的；否则就会new一个对象返回，肯定是不相等的。&lt;br&gt;
&lt;code&gt;IntegerCache&lt;/code&gt;的low是固定死的-128，high默认127，可以通过这个配置修改&lt;code&gt;-XX:AutoBoxCacheMax&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;short-long&#34;&gt;Short、Long&lt;/h2&gt;
&lt;p&gt;和Integer差不多，但是它们的high是固定的127。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aCoder2013/blog/issues/14&#34;&gt;Java原生类型包装类初解析&lt;/a&gt;&lt;/p&gt;
">Java包装类的比较</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-thread/"" data-c="
          &lt;h2 id=&#34;线程状态&#34;&gt;线程状态&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新建：创建后尚未启动的线程处于这种状态&lt;/li&gt;
&lt;li&gt;运行：运行状态包括操作系统中的运行态和就绪态，也就是说这个状态下的线程可能正在执行，也有可能在等待CPU为它分配执行时间；&lt;/li&gt;
&lt;li&gt;无限期等待：处于这种状态的线程不会被分配CPU，它们要被其它进程显式唤醒。可能进入这种状态的操作有：
&lt;ul&gt;
&lt;li&gt;没有设置时间参数的wait和join方法；&lt;/li&gt;
&lt;li&gt;LockSupport.park()方法；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限期等待：处于这种状态的线程也不会被分配执行时间，不过不需要其它线程唤醒，等一段时间之后就会由系统自动唤醒。可能进入这种状态的有：
&lt;ul&gt;
&lt;li&gt;设置了时间参数的wait和join方法；&lt;/li&gt;
&lt;li&gt;sleep方法；&lt;/li&gt;
&lt;li&gt;LockSupport.parkNanos()方法、LockSupport.parkUntil()方法；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阻塞状态：线程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获得一个排它锁。而等待状态则是在等待一段时间，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。&lt;/li&gt;
&lt;li&gt;结束：已终止线程的线程状态，线程已经结束执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;线程安全&#34;&gt;线程安全&lt;/h2&gt;
&lt;p&gt;当多个线程访问一个对象的时候，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。&lt;/p&gt;
">Java中的线程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-map/"" data-c="
          &lt;p&gt;&lt;code&gt;Map&lt;/code&gt;就如它字面意思，是一个从键（key）到值（value）的映射。我们在Map里面存储键值对，根据键得到值，因此键是不能重复的（如果插入一个有重复键的记录，则会覆盖原有的值），但是值可以重复。&lt;/p&gt;
&lt;p&gt;Java里面基于对Map的不同访问需求创建了它的不同实现类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对键的顺序没有要求&lt;/li&gt;
&lt;li&gt;取出键的顺序按照插入记录时的顺序&lt;/li&gt;
&lt;li&gt;取出键的顺序按照键的升序排序&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Hashmap&lt;/code&gt; 是一个最常用的Map，它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。&lt;/p&gt;
&lt;h3 id=&#34;空键问题&#34;&gt;空键问题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;最多只允许一条记录的键为Null，允许多条记录的值为 Null。&lt;/p&gt;
&lt;h3 id=&#34;线程安全问题&#34;&gt;线程安全问题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;的访问没有锁，即任一时刻可以有多个线程同时写HashMap，对它的访问是线程不安全的，可能会导致数据的不一致。如果需要线程安全，可以使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;的锁是分段加的；另外一种线程安全的Map结构是&lt;code&gt;HashTable&lt;/code&gt;，它与&lt;code&gt;HashMap&lt;/code&gt;类似，继承自Dictionary类，但是它不允许记录的键或者值为空，&lt;code&gt;HashTable&lt;/code&gt;的线程安全是通过对整个数据结构上锁，，即任一时刻只有一个线程能写Hashtable，多线程情况下效率很低。&lt;/p&gt;
&lt;h3 id=&#34;hashcode与equals&#34;&gt;HashCode与equals&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hashCode&lt;/code&gt;是用来计算hash值的，hash值是用来确定hash表索引的。&lt;br&gt;
hash表中的一个索引处存放的是一张链表，所以还要通过&lt;code&gt;equals&lt;/code&gt;方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry。put记录时，如果hash表中没定位到，就在链表前加一个Entry；如果定位到了，则更换Entry中的值，并返回旧的值。&lt;/p&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;p&gt;一般情况下，我们用的最多的是&lt;code&gt;HashMap&lt;/code&gt;，它里面存入的记录在取出的时候是随机的，它根据键的HashCode存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。&lt;/p&gt;
&lt;h2 id=&#34;linkedhashmap&#34;&gt;LinkedHashMap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;保存了记录的插入顺序，在用&lt;code&gt;Iterator&lt;/code&gt;遍历&lt;code&gt;LinkedHashMap&lt;/code&gt;时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当&lt;code&gt;HashMap&lt;/code&gt;容量很大，实际数据较少时，遍历起来可能会比&lt;code&gt;LinkedHashMap&lt;/code&gt;慢，因为&lt;code&gt;LinkedHashMap&lt;/code&gt;的遍历速度只和实际数据有关，和容量无关，而&lt;code&gt;HashMap&lt;/code&gt;的遍历速度和他的容量有关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt; 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。&lt;/p&gt;
&lt;h2 id=&#34;treemap&#34;&gt;TreeMap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt;实现&lt;code&gt;SortMap&lt;/code&gt;接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用&lt;code&gt;Iterator&lt;/code&gt; 遍历&lt;code&gt;TreeMap&lt;/code&gt;时，得到的记录是排过序的。&lt;br&gt;
TreeSet集合排序有两种方式，Comparable和Comparator区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。&lt;/li&gt;
&lt;li&gt;让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数，方式较为灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt;取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么&lt;code&gt;TreeMap&lt;/code&gt;会更好。&lt;code&gt;TreeMap&lt;/code&gt;更是多了一个排序的功能。&lt;/p&gt;
&lt;h3 id=&#34;comparator&#34;&gt;Comparator&lt;/h3&gt;
&lt;p&gt;由于TreeMap需要排序，所以需要一个Comparator为键值进行大小比较，当然也是用Comparator定位的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Comparator可以在创建TreeMap时指定；&lt;/li&gt;
&lt;li&gt;如果创建时没有确定Comparator对象，那么就会使用key.compareTo()方法，这就要求key必须实现Comparable接口；&lt;/li&gt;
&lt;li&gt;TreeMap是使用Tree数据结构实现的，所以使用Comparator接口就可以完成定位了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;相关set&#34;&gt;相关Set&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt;是通过&lt;code&gt;HashMap&lt;/code&gt;实现的，&lt;code&gt;TreeSet&lt;/code&gt;是通过&lt;code&gt;TreeMap&lt;/code&gt;实现的。Java里的Set实现其实用的是Map的key。&lt;br&gt;
Map的key和Set都有一个共同的特性：集合的唯一性。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/fg2006/article/details/6411200&#34;&gt;HashMap,LinkedHashMap,TreeMap的区别&lt;/a&gt;&lt;/p&gt;
">【数据结构】Java里的各种Map</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/js-object/"" data-c="
          &lt;p&gt;JavaScript简单数据结构包括数字、字符串、布尔值、null值、undefined值，其他都是对象。&lt;br&gt;
对象时属性的容器，其中每个属性都是名字和值。&lt;br&gt;
JavaScript里面的对象时无类型的，对新属性的名字和值没有限制，适合用于聚集和管理数据，对象里也可以包含其他对象。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;对象字面量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var empty_object={};

var stoge={
  &amp;quot;firstName&amp;quot;:&amp;quot;Joerome&amp;quot;,
  &amp;quot;lastName&amp;quot;:&amp;quot;Howare&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的对象stoge中两个属性，如果他们不是JavaScript的保留字，可以去掉引号。&lt;br&gt;
检索对象里面属性的值可以用中括号去获取，如&lt;code&gt;stoge[&amp;quot;firstName&amp;quot;]&lt;/code&gt;，如果该字符串表达式是一个字符串字面量，且是合法的JavaScript标识符不是保留字，那么也可以用点号“.”获取。如果试图获取一个不存在的属性，将得到undefined。&lt;/p&gt;
&lt;p&gt;使用typeof操作符对确定属性的类型很有帮助：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof flight.number  // &#39;number&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，原型链中的任何属性都会产生值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof flight.toString  // &#39;function&#39;
typeof flight.constructor // &#39;function&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有两种方法处理这些不需要的属性：&lt;br&gt;
第一个是让程序做检查并丢弃值为函数的属性，一般来说，想让对象在运行时动态获取自身信息时，关注更多的是数据。&lt;br&gt;
另一个方法是使用hasOwnProperty方法，如果对象拥有独有的属性，将返回true，该方法不会检查原型链。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;flight.hasOwnProperty(&#39;number&#39;) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for in 循环中遍历属性的顺序是不确定的，如果想要确保属性以特定的顺序出现，最好的办法是完全避免使用for in语句，而是创建一个数组，在其中以正确的顺序包含属性名，然后使用普通的for循环遍历。&lt;/p&gt;
&lt;p&gt;delete可以删除对象中的属性，不会触及原型链中的任何对象，删除对象的属性可能会让原型链中的属性透现出来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;another.nickname  // &#39;Moe&#39;

// 删除another的nickname属性，暴露出原型的nickname属性
delete another.nickname;

another.nickname  // &#39;Curly&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用Java里面的话理解，就是删除子类中的覆盖父类的属性以及get方法，那么下次再想获取该属性，将是从父类得到的。&lt;/p&gt;
">JavaScript里的对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/mysql-storage-engine/"" data-c="
          &lt;p&gt;MySQL由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接池组件&lt;/li&gt;
&lt;li&gt;管理服务和工具组件&lt;/li&gt;
&lt;li&gt;SQL接口组件&lt;/li&gt;
&lt;li&gt;查询分析器组件&lt;/li&gt;
&lt;li&gt;优化器组件&lt;/li&gt;
&lt;li&gt;缓冲（Cache）组件&lt;/li&gt;
&lt;li&gt;插件式存储引擎&lt;/li&gt;
&lt;li&gt;物理文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：存储引擎是基于表的，而不是数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;MySQL常用的插件式存储引擎主要包括MyISAM，InnoDB，NDB Cluster，Maria，Falcon，Memory，Archive，Merge，Federated等，其中最著名且使用最广泛的是MyISAM和InnoDB。MyISAM是MySQL的默认存储引擎，是MySQL最早的ISAM存储引擎的升级版本。&lt;/p&gt;
&lt;h2 id=&#34;myisam存储引擎&#34;&gt;MyISAM存储引擎&lt;/h2&gt;
&lt;p&gt;MyISAM是MySQL的默认存储引擎，它支持B-tree/FullText/R-tree索引类型。&lt;br&gt;
MyISAM的锁级别是表锁，表锁的开销小，加锁快；锁粒度大，发生锁冲突的概率较高，并发度低；表锁适合查询。MyISAM引擎不支持事务性，也不支持外键。&lt;/p&gt;
&lt;p&gt;MyISAM对于一些OLAP（Online Analytical Processing，在线分析处理）操作速度快。除Windows版本外，是所有MySQL版本默认的存储引擎。&lt;/p&gt;
&lt;p&gt;MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，当然你也可以通过myisampack来解压数据文件&lt;br&gt;
。&lt;br&gt;
在MySQL 5.0版本之前，MyISAM默认支持的表大小为4G，如果需要支持大于4G的MyISAM表时，则需要制定MAXROWS和 AVGROW_LENGTH属性。从MySQL 5.0版本开始，MyISAM默认支持256T的单表数据，这足够满足一般应用的需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：对于MyISAM存储引擎表，MySQL数据库只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他使用LRU算法缓存数据 的大部分数据库大不相同。此外，在MySQL 5.1.23版本之前，无论是在32位还是64位操作系统环境下，缓存索引的缓冲区最大只能设置为4G。在之后的版本中，64位系统可以支持大于4G的索引缓冲区。&lt;/p&gt;
&lt;h2 id=&#34;innodb存储引擎&#34;&gt;InnoDB存储引擎&lt;/h2&gt;
&lt;p&gt;InnoDB存储引擎最大的亮点就是支持事务性，支持回滚。它支持Hash/B-tree索引类型。&lt;br&gt;
InnoDB的锁级别是行锁，行锁在锁定上带来的消耗大于表锁，但是在系统并发访问量较高时，InnoDB整体性能远高于MyISAM。InnoDB的索引不仅缓存索引本身，也缓存数据，所以InnoDB需要更大的内存。&lt;/p&gt;
&lt;p&gt;InnoDB存储引擎支持事务，主要面向在线事务处理（OLTP）方面的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读取操作不会产生锁。MySQL在Windows版本下的InnoDB是默认的存储引擎，同时InnoDB默认地被包含在所有的MySQL二进制发布版本中。&lt;/p&gt;
&lt;p&gt;InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB自身进行管理。从MySQL 4.1（包括4.1）版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。与Oracle类似，InnoDB存储引擎同样可以使用裸设备（row disk）来建立其表空间。&lt;/p&gt;
&lt;p&gt;InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时使用一种被称为next-key locking 的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。&lt;/p&gt;
&lt;p&gt;对于表中数据的存储，InnoDB存储引擎采用了聚簇（clustered）的方式，这种方式类似于Oracle的索引聚集表（index organized table，IOT）。&lt;/p&gt;
&lt;p&gt;每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的 ROWID，并以此作为主键。&lt;/p&gt;
&lt;h2 id=&#34;memory存储引擎&#34;&gt;Memory存储引擎&lt;/h2&gt;
&lt;p&gt;Memory存储引擎是一个内存级的存储引擎，它将所有数据都存储在内存中，所以它能够存储的数据量是比较小的。而因为内存的特性，Memory存储引擎对于数据的一致性支持教差。Memory的锁级别和MyISAM一样，是表锁；并且不支持事务性。&lt;/p&gt;
&lt;p&gt;Memory存储引擎（之前称为HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。它默认使用哈希索引，而不是我们熟悉的B+树索引。&lt;/p&gt;
&lt;p&gt;虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，其只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存（这个问题之前已经提到，eBay的Igor Chernyshev工程师已经给出了Patch方案）。&lt;br&gt;
此外有一点常被忽视的是，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。&lt;/p&gt;
&lt;h2 id=&#34;ndb存储引擎&#34;&gt;NDB存储引擎&lt;/h2&gt;
&lt;p&gt;2003年，MySQL AB公司从Sony Ericsson公司收购了NDB 集群引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群；不过，与Oracle RAC share everything结构不同的是，其结构是share nothing的集群架构，因此能提供更高级别的高可用性。NDB的特点是数据全部放在内存中（从5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找（primary key lookup）的速度极快，并且通过添加NDB数据存储节点（Data Node）可以线性地提高数据库性能，是高可用、高性能的集群系统。&lt;/p&gt;
&lt;p&gt;关于NDB存储引擎，有一个问题值得注意，那就是NDB存储引擎的连接操作（JOIN）是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：MySQL NDB Cluster存储引擎有社区版本和企业版本，并且NDB Cluster已作为Carrier Grade Edition单独下载版本而存在，可以通过[http://dev.mysql.com/ downloads/cluster/index.html](http://dev.mysql.com/ downloads/cluster/index.html)获得最新版本的NDB Cluster存储引擎。&lt;/p&gt;
&lt;h2 id=&#34;archive存储引擎&#34;&gt;Archive存储引擎&lt;/h2&gt;
&lt;p&gt;Archive存储引擎只支持INSERT和SELECT操作，MySQL 5.1开始支持索引。其使用zlib算法将数据行（row）进行压缩后存储，压缩比率一般可达1∶10。正如其名称所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是本身并不是事物安全的存储引擎，其设计目标主要是提供高速的插入 和压缩功能。&lt;/p&gt;
&lt;h2 id=&#34;federated存储引擎&#34;&gt;Federated存储引擎&lt;/h2&gt;
&lt;p&gt;Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。&lt;/p&gt;
&lt;h2 id=&#34;maria存储引擎&#34;&gt;Maria存储引擎&lt;/h2&gt;
&lt;p&gt;Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎，开发者是MySQL 的创始人之一的Michael Widenius。因此，它可以看作是MyISAM的后续版本。其特点是：缓存数据和索引文件，行锁设计，提供MVCC功能，支持事务和非事务安全的选项 支持，以及更好的BLOB字符类型的处理性能。&lt;/p&gt;
&lt;h2 id=&#34;其他存储引擎&#34;&gt;其他存储引擎&lt;/h2&gt;
&lt;p&gt;除了上面提到的7种存储引擎外，还有很多其他的存储引擎，包括Merge、CSV、Sphinx和Infobright，它们都有各自适用的场合，这里不再一一做介绍了。了解了MySQL拥有这么多存储引擎后，现在我可以回答1.2节中提到的问题了。&lt;/p&gt;
&lt;p&gt;为什么MySQL不支持全文索引？不！MySQL支持，MyISAM、Sphinx存储引擎支持全文索引。&lt;br&gt;
MySQL快是因为不支持事务吗？错！MySQL MyISAM存储引擎不支持事务，但是InnoDB支持。快是相对于不同应用来说的，对于ETL这种操作，MyISAM当然有其优势。&lt;br&gt;
当表的数据量大于1000W时，MySQL的性能会急剧下降吗？不！MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，如果 你选择了正确的存储引擎以及正确的配置，再大的数据量MySQL也是能承受的。如官方手册上提及的，Mytrix和Inc.在InnoDB上存储了超过 1TB的数据，还有一些其他网站使用InnoDB存储引擎处理平均每秒800次插入/更新的操作。&lt;/p&gt;
&lt;h2 id=&#34;myisam和innodb差别&#34;&gt;MyISAM和InnoDB差别&lt;/h2&gt;
&lt;h3 id=&#34;构成差别&#34;&gt;构成差别&lt;/h3&gt;
&lt;p&gt;每个MyISAM在磁盘上存储成三个文件，文件的名字以表的名字开始，.frm文件存储表定义，.MYI(MYIndex)为索引文件，.MYD(MYData)为数据文件。&lt;/p&gt;
&lt;p&gt;基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。&lt;/p&gt;
&lt;h3 id=&#34;事务处理差别&#34;&gt;事务处理差别&lt;/h3&gt;
&lt;p&gt;MyISAM类型的表强调性能，执行速度比InnoDB快，但是不支持事务处理等高级功能。&lt;/p&gt;
&lt;p&gt;InnoDB提供事务支持、外部键等高级数据库功能。&lt;/p&gt;
&lt;h3 id=&#34;crud操作&#34;&gt;CRUD操作&lt;/h3&gt;
&lt;p&gt;如果执行大量SELECT查询操作，MyISAM是最好的选择。&lt;/p&gt;
&lt;p&gt;如果执行大量的UPDATE或者INSERT操作，出于性能方面考虑，应该使用InnoDB。&lt;code&gt;DELETE from table&lt;/code&gt;时，InnoDB不会重新建立表，而是一行一行的删除。&lt;br&gt;
&lt;code&gt;LOAD TABLE FROM MASTER&lt;/code&gt;操作对InnoDB不起作用，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。&lt;/p&gt;
&lt;h3 id=&#34;auto_increment操作&#34;&gt;AUTO_INCREMENT操作&lt;/h3&gt;
&lt;p&gt;MyISAM为INSERT和UPDATE操作自动更新这一列，这使得AUTO_INCREMENT列更快（10%+），在序列项的值删除后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。&lt;br&gt;
AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置。&lt;/p&gt;
&lt;p&gt;对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但 是在MyISAM表中，可以和其他字段一起建立联合索引。&lt;br&gt;
如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。InnoDB自动增长计数器仅被存储在主内存中，而不是存在磁盘上。&lt;/p&gt;
&lt;h3 id=&#34;表的具体行数&#34;&gt;表的具体行数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;select count(*) from table&lt;/code&gt;，MyISAM只要简单的读出保存好的行数。注意的是，当count(*)语句包含 where 条件时，两种类型表的操作是一样的。&lt;/p&gt;
&lt;p&gt;InnoDB 中不保存表的具体行数。也就是说，执行&lt;code&gt;select count(*) from table&lt;/code&gt;时，InnoDB要扫描一遍整个表来计算有多少行。&lt;/p&gt;
&lt;h3 id=&#34;锁&#34;&gt;锁&lt;/h3&gt;
&lt;p&gt;MyISAM的锁是在表级别。其并发写的性能一直是一个让人比较头疼的问题。&lt;/p&gt;
&lt;p&gt;InnoDB提供了行级别的锁(locking on row level)，提供与 Oracle类型一致的不加锁读取(non-locking read in SELECTs)。另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如&lt;code&gt;update table set num=1 where name like &#39;%aaa%&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;索引&#34;&gt;索引&lt;/h3&gt;
&lt;p&gt;MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引。&lt;/p&gt;
&lt;p&gt;Innodb是索引和数据是存放在相同的文件，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。Innodb 的数据存放格式也比较独特,每个Innodb表 都会将主键以聚簇索引的形式创建。所有的数据都是以主键来作为升序排列在物理磁盘上面,所以主键 查询并且以主键排序的查询效率也会非常高。&lt;/p&gt;
&lt;h2 id=&#34;如何选择合适的引擎&#34;&gt;如何选择合适的引擎&lt;/h2&gt;
&lt;h3 id=&#34;采用myisam引擎&#34;&gt;采用MyISAM引擎&lt;/h3&gt;
&lt;p&gt;R/W &amp;gt; 100 ，并且Update较少 (R/W:读写比)&lt;br&gt;
并发不高，不需要支持事务&lt;br&gt;
表数据量小&lt;br&gt;
需要进行全文搜索&lt;/p&gt;
&lt;h3 id=&#34;采用innodb引擎&#34;&gt;采用InnoDB引擎&lt;/h3&gt;
&lt;p&gt;R/W比较小，频繁更新大字段&lt;br&gt;
表数据量超过千万，高并发&lt;br&gt;
安全性和可用性要求高&lt;/p&gt;
&lt;h3 id=&#34;采用memory引擎&#34;&gt;采用Memory引擎&lt;/h3&gt;
&lt;p&gt;有足够的内存&lt;br&gt;
对数据一致性要求不高，如session/在线人数等&lt;br&gt;
需要定期归档的数据&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ha97.com/4197.html&#34;&gt;MySQL存储引擎MyISAM与InnoDB的主要区别对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://imysql.com/2015/07/23/something-important-about-mysql-design-reference.shtml&#34;&gt;老叶观点：MySQL开发规范之我见&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://simpleframework.net/news/view?newsId=63cd772590e8495bbff4d713e092f772&#34;&gt;《MySQL技术内幕:InnoDB存储引擎》-- 第1章 MySQL体系结构和存储引擎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">MySQL不同的存储引擎</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/array-and-linkedlist/"" data-c="
          &lt;p&gt;在计算机程序里，数据存储的方式无外乎两种：顺序存储和链式存储。顺序存储的结构可以称为顺序表，也可以用数组描述，链式存储的结构可以称为链表。&lt;br&gt;
我们每一个学过数据结构的都知道，它们两者各自有一些鲜明的特性，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以通过数组下标去访问数组里的元素，查询、更新的效率高，时间复杂度是O(1)，但是在中间某个位置插入或删除一个元素就要挪动后面所有的元素，时间复杂度是O(n)。&lt;/li&gt;
&lt;li&gt;链表里元素之间存在指针指向关联的另一个元素，我们只能通过指针挨个去遍历访问链表里的元素，查询、更新的效率低，时间复杂度是O(n)，在中间某个位置插入或删除一个元素比较方便，只需要修改相邻指针的引用就可以了，时间复杂度是O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;数组的好处显而易见，它的存储结构比较紧凑，相对节省空间。每个元素都有唯一的索引，支持随机访问。但是数组所需要的空间需要一次分配够，当数组容量满时，新加入元素就要对数组进行扩容。扩容时，往往不能在原地直接扩，因为后面的内存可能已经分配给其他数据结构了，所以要重新申请一块新的更大的内存空间，将原有的数组里的元素全部复制到新的数组里，再释放原有数组的空间，这个过程时间复杂度是O(n)，可以参考Java的&lt;code&gt;ArrayList&lt;/code&gt;。如果不加以合理的维护，内存中将产生大量碎片。&lt;/p&gt;
&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;
&lt;p&gt;链表有效地解决里数组需要扩容的问题，因为链表里的每个元素节点都不需要连续，链表的节点通过指针进行索引，每个节点只能找到它指针指向的下一个节点。正常的单向链表是从头节点开始，每个节点依次有一个指针指向它后面的节点，尾部节点指向NULL。有时候为了方便拿到前驱节点，我们会采用双向链表，也就是每个节点既包含一个指针指向后面的，也包含一个指针指向前面的。还有一种链表是循环链表，也就是说尾节点指向了头节点。&lt;/p&gt;
&lt;h3 id=&#34;dummy-node&#34;&gt;Dummy Node&lt;/h3&gt;
&lt;p&gt;翻译为哑节点或者假人头节点。&lt;/p&gt;
&lt;p&gt;Dummy node 是一个虚拟节点，也可以认为是标杆节点。Dummy node 就是在链表表头 head 前加一个节点指向 head，即dummy -&amp;gt; head。Dummy node 的使用多针对单链表没有前向指针的问题，保证链表的 head 不会在删除操作中丢失。还有一种用法比较少见，就是使用 dummy node 来进行head的删除操作。所以，当链表的 head 有可能变化（被修改或者被删除）时，使用 dummy node 可以很好的简化代码，最终返回&lt;code&gt;dummy.next&lt;/code&gt;即新的链表。&lt;/p&gt;
&lt;h3 id=&#34;快慢指针&#34;&gt;快慢指针&lt;/h3&gt;
&lt;p&gt;快慢指针指的是2个指针沿着链表向前移动的步数不一样，比如一个每次移2步，另一个每次移1步。可以通过它找到链表中间的节点以及判断链表是否循环。&lt;/p&gt;
">【数据结构】数组和链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/linux-redirect-dev-null/"" data-c="
          &lt;p&gt;本文亦发布于&lt;a href=&#34;https://thinkbucket.cn/blog/2020/05/21/linux-redirect-dev-null&#34;&gt;ThinkBucket&lt;/a&gt;。&lt;br&gt;
在 Linux 的 shell 命令或者脚本中，我们经常看到这样的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是何意？&lt;/p&gt;
 &lt;!-- more --&gt; 
&lt;h2 id=&#34;linux-进程&#34;&gt;Linux 进程&lt;/h2&gt;
&lt;p&gt;以 bash 为例，shell 中执行一个命令时，其实是由 bash shell fork 出一个子进程，然后在这个子进程中运行相应的命令，直至退出。Linux 里的进程的数据结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;struct task_struct {
	// 进程状态
	long state;
	// 虚拟内存结构体
	struct mm_struct *mm;
	// 进程号
	pid_t pid;
	// 指向父进程的指针
	struct task_struct __rcu *parent;
	// 子进程列表
	struct list_head children;
	// 存放文件系统信息的指针
	struct fs_struct *fs;
	// 一个数组，包含该进程打开的文件指针
	struct files_struct *files;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt; 就是 Linux 对于一个进程的描述，也可以称之为进程描述符。其中的 &lt;code&gt;files&lt;/code&gt; 指针指向一个数组，表示当前进程打开的所有文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个进程被创建时，&lt;code&gt;files&lt;/code&gt; 指向的数组前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 中的所有设备都是抽象成文件的，设备可以当作文件一样读和写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述所说的文件描述符如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;文件描述符&lt;/th&gt;
&lt;th&gt;默认情况&lt;/th&gt;
&lt;th&gt;对应文件句柄位置&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标准输入（standard input）&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;从键盘获得输入&lt;/td&gt;
&lt;td&gt;/proc/slef/fd/0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标准输出（standard output）&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;输出到屏幕（即控制台）&lt;/td&gt;
&lt;td&gt;/proc/slef/fd/1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;错误输出（error output）&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;输出到屏幕（即控制台）&lt;/td&gt;
&lt;td&gt;/proc/slef/fd/2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;重定向&#34;&gt;重定向&lt;/h2&gt;
&lt;p&gt;Linux shell 里通过 &lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;进行输出、输入的重定向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;：将 shell 命令的输出指向某个地方，可以是文件，也可以是内存里的某个变量。比如 &lt;code&gt;ls -l &amp;gt; file.txt&lt;/code&gt; 就是把当前路径下的文件信息保存到 file.txt 文本中，如果没有这个重定向，它会将结果输出到显示器屏幕上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;：从某个地方读取内容作为 shell 命令的输入，可以是文件，也可以是内存里的某个变量。比如 &lt;code&gt;{command} &amp;lt; file.txt&lt;/code&gt;，如果没有这个重定向，它会从键盘读取输入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用&lt;code&gt;&amp;gt;&lt;/code&gt;进行输出重定向时，默认是把某个命令的标准输出进行重定向。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 把标准输出重定向到新文件中
command &amp;gt;filename

# 把标准输出重定向到新文件中
command 1&amp;gt;filename

# 把标准错误重定向到新文件中
command 2&amp;gt;filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当使用&lt;code&gt;&amp;lt;&lt;/code&gt;进行输入重定向时，默认时把它右边的内容作为标准输入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 以filename文件作为标准输入
command &amp;lt;filename

# 以filename文件作为标准输入
command 0&amp;lt;filename

# 从标准输入中读入，直到遇到delimiter分隔符
command &amp;lt;&amp;lt;delimiter
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;管道&#34;&gt;管道&lt;/h3&gt;
&lt;p&gt;shell 还可以通过 &lt;code&gt;|&lt;/code&gt; 这样的管道将前一个命令的输出作为下一个命令的输入，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在命令历史中找到包含 ssh 字符串的命令
history | grep ssh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-devnull&#34;&gt;2&amp;gt; /dev/null&lt;/h2&gt;
&lt;p&gt;通过上面的章节可以知道，&lt;code&gt;2&lt;/code&gt; 表示标准错误，&lt;code&gt;&amp;gt;&lt;/code&gt; 表示将标准错误重定向到某个地方。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/dev/null&lt;/code&gt; 是一个特殊文件，在Unix系统中称为 null 设备。 通俗地说，它也称为比特桶（bit bucket，也译作比特垃圾桶）或黑洞（blackhole），因为它会立即丢弃写入其中的任何内容，并且在读取时仅返回文件结束EOF。&lt;/p&gt;
&lt;p&gt;所以这个命令合起来就是将忽略执行命令产生的错误。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 删除当前路径下的folder目录，如果不存在则忽略错误
rm -r folder 2&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;之间不能有空格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;更多用法&#34;&gt;更多用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;：将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。这种写法的好处是可以避免同样的输出文件的描述符不用打开两次，标准输出和错误输出也不会抢占性往文件输出内容。&lt;br&gt;
&lt;code&gt;&amp;gt; /dev/null&lt;/code&gt;：将标准输出1重定向到&lt;code&gt;/dev/null&lt;/code&gt;中。&lt;br&gt;
&lt;code&gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;：就是让标准输出和错误输出重定向到&lt;code&gt;/dev/null&lt;/code&gt;中（就是所有输出都丢弃了）。错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了&lt;code&gt;/dev/null&lt;/code&gt;中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。&lt;br&gt;
&lt;code&gt;2&amp;gt;&amp;amp;1 &amp;gt;/dev/null&lt;/code&gt;：标准输出丢弃，错误输出显示在屏幕上。&lt;/p&gt;
&lt;p&gt;我们会用&lt;code&gt;nohup&lt;/code&gt;命令在后台启动Java程序，为了不让一些执行信息输出到控制台，会用如下命令丢弃输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nohup java -jar xxxx.jar &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bash.cyberciti.biz/guide/What_is_a_Process%3F&#34;&gt;What is a Process?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md&#34;&gt;Linux的进程、线程、文件描述符是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki//dev/null&#34;&gt;维基百科：/dev/null&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Linux 中的 2> /dev/null</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/oop-and-pure-function/"" data-c="
          &lt;p&gt;在面向对象编程里面，我们常常对现实世界建模抽象成一个个类，然后创建它们的对象，通过对象的方法行为去描述逻辑。&lt;/p&gt;
&lt;p&gt;纯函数是一种特殊的函数，给它相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;占位符，待更。&lt;/p&gt;
&lt;p&gt;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1&lt;br&gt;
https://www.jiqizhixin.com/articles/2018-10-22-15&lt;/p&gt;
">面向对象编程与纯函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/manage-multiple-java-versions/"" data-c="
          &lt;p&gt;自从Oracle宣布Java开始收费之后，越来越多的人会考虑从[Open JDK][1]下载安装Java环境。可能自己机器上也会同时并存好几个Java版本，本文以macOS为例介绍一下如何从Open JDK安装并进行管理多版本。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;下载安装&#34;&gt;下载安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -O https://download.java.net/java/GA/jdk12/33/GPL/openjdk-12_osx-x64_bin.tar.gz 
tar xvf openjdk-12_osx-x64_bin.tar.gz

# 解压后文件夹比如名为jdk-12.jdk，移动到macOS管理的JVM目录中去
sudo mv jdk-12.jdk /Library/Java/JavaVirtualMachines
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，可以输入如下命令查看本机上有几种Java版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/usr/libexec/java_home -V
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如生成如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Matching Java Virtual Machines (2):
    12, x86_64:	&amp;quot;OpenJDK 12&amp;quot;	/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home
    1.7.0_76, x86_64:	&amp;quot;Java SE 7&amp;quot;	/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以输入小写v参数查看具体的版本信息，比如查刚刚下载的Java 12：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/usr/libexec/java_home -v 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会显示&lt;code&gt;/Library/Java/JavaVirtualMachines/jdk-12.jdk/Contents/Home&lt;/code&gt;，这个就是它的Java Home。那么就能通过export设置当前的JAVA_HOME环境变量了。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=`/usr/libexec/java_home -v 12`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;便捷管理多版本&#34;&gt;便捷管理多版本&lt;/h2&gt;
&lt;p&gt;Linux或者macOS都有bash或者其他shell，以bash为例，bash在每个用户目录下都有&lt;code&gt;.bashrc&lt;/code&gt;文件用于配置用户相关的环境变量（如果没有可以自己创建），可以在该文件下面写如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# type &#39;java7&#39; at command prompt to switch to java 7
function java7() {
    export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
    echo &amp;quot;JAVA_HOME is $JAVA_HOME&amp;quot;
    java -version
}

# type &#39;java12&#39; at command prompt to switch to java 12
function java12() {
    export JAVA_HOME=`/usr/libexec/java_home -v 12`
    echo &amp;quot;JAVA_HOME is $JAVA_HOME&amp;quot;
    java -version
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存之后，输入命令&lt;code&gt;source .bashrc&lt;/code&gt;，然后可以通过命令&lt;code&gt;java12&lt;/code&gt;或者&lt;code&gt;java7&lt;/code&gt;来便捷切换所使用的Java版本。&lt;/p&gt;
&lt;p&gt;[1]:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;https://openjdk.java.net/install/&lt;/p&gt;
">在Shell里管理多个Java版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/Try with closable resources/"" data-c="
          &lt;p&gt;以前，拿到一个closable资源后，如果对它操作，都要先用try包起来，最后一定要在finally里面关掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Closable resource = xxx; //此处为得到这个resource的逻辑
try {
	// 处理逻辑
} finally {
	if (resource != null) {
		try {
			resource.close();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自从Java 7之后，根据官方文档&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html&#34;&gt;tryResouceClose&lt;/a&gt;，任何实现了&lt;code&gt;java.lang.AutoClosable&lt;/code&gt;，以及&lt;code&gt;java.io.Closable&lt;/code&gt;接口的对象都可以在这段代码结束之后被关掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try (Closable resource = xxx) {
	// 处理逻辑
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.NET里面也有个类似的用法，C#里面一般实现了IDisposable接口的对象在使用时最好结束后调用它的dispose方法，也可以使用using的方式来帮助回收：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using (IDisposable resource = xxx) {
	// 处理逻辑
}
&lt;/code&gt;&lt;/pre&gt;
">Try with closable resources</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/wring-code-from-unit-test-side/"" data-c="
          &lt;p&gt;单元测试，也就是对代码较细粒度单元的测试，一般就是测某个方法或函数。说到单元测试，基本上每个开发者都不陌生，时不时会听到“测试覆盖率太低了！”，然后“We need to increase our code coverage!”。经常出bug？好好准备测试吧。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-为什么要提高覆盖率&#34;&gt;1. 为什么要提高覆盖率？&lt;/h2&gt;
&lt;p&gt;覆盖率为什么这么重要？我们每次修改代码之后都不希望把原有可用的功能搞出问题，如果没有足够的测试覆盖，开发者就没有足够的信心去交付新代码。测试覆盖率高的话，就可以用机器自动去跑高效率地去验证，在覆盖不到的地方需要人工去验证。所以当覆盖率很低的时候，人工需要一遍又一遍的去验证已有的功能，还要去验证新加的功能是否符合预期，这个真的会崩溃。开发者自己去做的话，八成会偷懒抑或是觉得自己改的范围影响不到那么多测得乐观。如果让测试工程师去做，那么需要领导们考虑开发跟测试的比例了。&lt;/p&gt;
&lt;p&gt;测试覆盖率不完全是看单元测试，还包括更高层次的集成测试、系统测试。当然了，如果单元测试没写多少，指望粒度更粗层次更高的其他测试，你会非常痛苦的。单元测试的2个优势：跑得快、容易定位问题。&lt;/p&gt;
&lt;p&gt;上面说了这么多，就是在强调单元测试覆盖率一定要尽可能高，每个单元测试职责一定要尽可能单一简单。单元测试覆盖无非就是代码行覆盖、分支覆盖，单元测试职责单一简单是说单元测试不要试图测某个方法的所有可能性，多写几个，这样出了问题能根据测试名字迅速找到为什么什么用例失败了以及被测方法的哪行可能有问题。&lt;/p&gt;
&lt;h2 id=&#34;2-单元测试为何难写&#34;&gt;2. 单元测试为何难写？&lt;/h2&gt;
&lt;p&gt;你可能听说过“测试驱动开发”，就是先写测试、后写代码，这个要求在写代码之前先好好分析需求、细化用例，把各个用例的测试写出来，每次改动代码都要求让尽可能多的测试结果为绿（成功），直到最后所有测试都绿了，那么代码的功能上也基本没问题了。这个可以了解下，有兴趣多看看这方面拓展一下。&lt;br&gt;
&lt;img src=&#34;http://goroyal.github.io/post-images/1560780095750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;为什么单元测试覆盖率往往上不去？因为有时候真的不好写。什么样的代码不好写单元测试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;被测方法传入了比较复杂的类的对象参数（不是依赖接口），当我要测这个方法，我就要去new依赖的那个对象，但是那个对象又依赖其他的，我又要接着new……，可能这个方法还没开始测，光创建它依赖的东西就写了一大堆测试代码。&lt;/li&gt;
&lt;li&gt;被测方法传入了某个对象作为参数，调用的复杂方法（不是依赖接口），这个方法有多复杂？可能它也跟上面一样也要new很多个对象才能跑起来，或者它调用了外部服务（网络、数据库等等）。简直没法测。&lt;/li&gt;
&lt;li&gt;被测方法自己内部创建了一些复杂对象、或者这个方法所属对象的实例创建了一些复杂对象，往往可能是外部有依赖的，比如对文件系统、数据库、网络等有调用。&lt;/li&gt;
&lt;li&gt;被测方法自己内部引用了static变量。&lt;/li&gt;
&lt;li&gt;被测方法自己内部引用了单例对象。&lt;/li&gt;
&lt;li&gt;被测方法调用了复杂的static方法，无法mock、无法用桩。&lt;/li&gt;
&lt;li&gt;被测方法是一个static方法，它可能依赖一个或多个static变量，这个变量还会被其他static方法修改，很难保证当前测试的独立性，包括它本身作为生产代码都是有坑的。&lt;/li&gt;
&lt;li&gt;被测方法传入了对象参数，考虑用桩了，但是发现那个类或者方法是final的，无法继承重写（如果是C#语言，sealed类无法被继承，无override关键字的方法不能被重写）。&lt;/li&gt;
&lt;li&gt;被测方法本身太长了，很难面面俱到，或者是单元测试出了错之后不好定位是哪行代码引起的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-如何写好单元测试&#34;&gt;3. 如何写好单元测试&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单元测试应该聚焦于被测方法本身的行为&lt;/strong&gt;，而不是被测方法所依赖的其他对象的行为。外部环境有依赖的代码应该尽可能少，并且尽量去调用接口，而不是具体的类。我们经常会听到“面向接口编程”，这个用了之后，写单元测试真的是非常爽。单元测试里面会用mock库或者自己去创建简单的类去模拟某个方法的行为，接口约定根据输入会产生什么样的输出，对于调用接口的方法而言不必去关心具体的实现是什么。Java里有著名的Mockito，C#里有Moq，用起来如行云流水一般。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法或者类构造器里面自己创建的对象不能太复杂&lt;/strong&gt;，复杂了你就没法测了。可以考虑调用该对象的接口，将它作为输入参数，那么就可以用上面说的方式去测了。&lt;/p&gt;
&lt;p&gt;个人理解，&lt;strong&gt;static方法要尽可能做到纯函数化&lt;/strong&gt;，也就是说一样的输入参数，随便什么情况下调用都应该给一样的输出。这其实就要求static这样的静态方法不要依赖不可控的static变量。如果做不到，尽量缩小它的使用范围吧……普通的实例方法调用static方法尽可能只调用简单的，没事别调用public的static变量，调用不受控制的static变量简直是给自己找麻烦，不可测是一方面，运行时被别的代码改掉的话就是灾难了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当被测方法太长的时候，实际上就意味着方法要拆了&lt;/strong&gt;，便于理解和维护。可以正常的拆，比如新建方法、新建类，也可以花哨地拆。有些人写了一堆if、else语句，如果是创建对象相关的，是否可以考虑工厂模式了？如果if、else里面是比较长的逻辑，可以考虑用策略模式。而如果是普通的前后累积的代码很长，要不试试责任链模式？当拆完之后，原本的非常长的不好测的方法变成若干个易测的小方法。覆盖率自然就上去了。&lt;/p&gt;
&lt;h2 id=&#34;4-结语&#34;&gt;4. 结语&lt;/h2&gt;
&lt;p&gt;当每层代码都经过单元测试确保自己这层没问题之后，整个逻辑的链条其实问题不大了。覆盖率不是简简单单为了覆盖而覆盖，单元测试都要有断言，就是如果跟测试目的产生不一致的结果这个测试必须显示失败，否则光数据好看是没用的。&lt;strong&gt;单元测试也不可能做到100%覆盖，但是可以尽可能做得高&lt;/strong&gt;，覆盖不到的地方再通过集成测试或者系统层面的测试去做。至于做不到100%覆盖的原因，比如代码里有对外部依赖的地方，再怎么抽离，总有地方需要去初始化。那么对于这个情况，尽可能把这个对外依赖范围缩小，其他地方用的时候传递接口。&lt;/p&gt;
&lt;p&gt;关于面向接口编程和减少耦合，还可以了解下依赖注入，能帮助解耦调用模块和具体实现类模块。&lt;/p&gt;
&lt;p&gt;为了代码可扩展性高、良好设计、易测试，可能会出现一个复杂业务逻辑的代码一层套一层的情况，一个逻辑看完可能经历了若干个类，这也是人们常常吐槽的Java这种语言的一个“啰嗦”之处。这个我也没有什么更好的想法，如果你有，可以分享一下。&lt;/p&gt;
">以单元测试的角度聊聊写代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/http-response-code/"" data-c="
          &lt;p&gt;目前HTTP在Web开发中被广泛使用，REST (Representational State Transfer) 很多人应该或多或少都知道些。当然了，比较熟悉的可能主要是GET、POST方法。这篇文章不是介绍REST的定义和如何创建符合REST风格的API，而是讲讲在Web开发中通用的不同HTTP响应状态码的含义。在普通网站开发、分布式集群开发、团队协作方面，如果采用了HTTP作为组件之间交互的协议，遵守通用的响应状态码是很有必要的（一是有充分的信息量、二是避免歧义）。&lt;/p&gt;
&lt;p&gt;HTTP响应状态共有5大类，分别是数字1、2、3、4、5开头。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1xx&#34;&gt;1XX&lt;/h2&gt;
&lt;p&gt;信息性状态码，表示接收的请求正在处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;100：说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应&lt;/li&gt;
&lt;li&gt;101：说明服务器正在根据客户端的指定，将协议切换成Update 首部所列的协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2xx&#34;&gt;2XX&lt;/h2&gt;
&lt;p&gt;成功状态码，表示请求正常处理完毕&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200：OK，实体的主体部分包含了所请求的资源。（正常请求很多是这种状态）&lt;/li&gt;
&lt;li&gt;201： Created，表示创建资源成功，响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location 首部包含的则是最具体的引用。（REST里面，POST或者PUT常常返回这样的状态）&lt;/li&gt;
&lt;li&gt;202， Accepted， 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。&lt;/li&gt;
&lt;li&gt;204：No Content，响应不包含实体的主体部分，通常在更新服务器上资源的时候成功的情况下不要求返回实体内容就会产生这个状态码。&lt;/li&gt;
&lt;li&gt;206：Partial Content，成功执行了一个部分或Range（范围）请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3xx&#34;&gt;3XX&lt;/h2&gt;
&lt;p&gt;重定向状态码，表示需要进行附加操作以完成请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;301：Moved Permanently，永久性重定向，表示请求的资源被分配了新的URI，以后应使用资源现在所指的URI。&lt;/li&gt;
&lt;li&gt;302：Found，临时性重定向，表示请求的资源被分配了新的URI，希望用户本次使用新的URI访问。&lt;/li&gt;
&lt;li&gt;303：See Other，表示请求对应的资源存在这另一个URI，应使用GET方法定向获取请求的资源。&lt;/li&gt;
&lt;li&gt;304：Not Modified，表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件。304状态码返回时不包含响应的主体部分（附带条件指：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）。304表明了客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题。另一种情况是,如果服务器认为客户端缓存的资源已经过期了，那么服务器就会返回HTTP/200 OK响应，响应体就是该资源当前最新的内容。客户端收到200响应后，就会用新的响应体覆盖掉旧的缓存资源。&lt;/li&gt;
&lt;li&gt;305：Use Proxy， 用来说明必须通过一个代理来访问资源；代理的位置由Location首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞。&lt;/li&gt;
&lt;li&gt;307：Temporary Redirect，临时重定向，与302有相同的含义。尽管302标准禁止POST变幻成GET，实际大家并未遵守。307会遵照浏览器标准，不会从POST变为GET，但是对于处理响应时的行为每种浏览器可能出现不同的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4xx&#34;&gt;4XX&lt;/h2&gt;
&lt;p&gt;客户端错误状态码，表示服务器无法处理请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;400：Bad Request， 用于告知客户端它发送了一个错误的请求，比方说请求体不符合预先定义的规则&lt;/li&gt;
&lt;li&gt;401：Unauthorized，表示发送的请求需要有通过HTTP认证的认证信息，若之前已进行过请求，则表示认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate手部质询用户信息。&lt;/li&gt;
&lt;li&gt;403：Forbidden，表明请求资源的访问被服务器拒绝了。&lt;/li&gt;
&lt;li&gt;404：Not Found，用于说明服务器无法找到请求的URL所对应的资源。&lt;/li&gt;
&lt;li&gt;405：Method Not Allowed，发起的请求中带有所请求的URL 不支持的方法时，使用此状态码。应该在响应中包含Allow 首部，以告知客户端对所请求的资源可以使用哪些方法。&lt;/li&gt;
&lt;li&gt;406：Not Acceptable，客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的URL 相匹配的资源时，使用此代码。&lt;/li&gt;
&lt;li&gt;413： Request Entity Too Large， 客户端发送的实体主体部分比服务器能够或者希望处理的要大时，返回此状态码。&lt;/li&gt;
&lt;li&gt;429：Too Many Requests，表示客户端在给定时间范围内发送了太多请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5xx&#34;&gt;5XX&lt;/h2&gt;
&lt;p&gt;服务器错误状态码，表示服务器处理请求出错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;500：Intenernal Server Error，服务器在执行请求时发生了错误&lt;/li&gt;
&lt;li&gt;501：Not Implemented，客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）&lt;/li&gt;
&lt;li&gt;502：Bad Gateway， 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）。&lt;/li&gt;
&lt;li&gt;503：Service Unavailable 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况所需时间，最好写入Retry-After首部字段返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 权威指南&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/yuyii/archive/2008/10/16/1312238.html&#34;&gt;HTTP头的Expires与Cache-control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">HTTP 响应状态码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/java-annotation/"" data-c="
          &lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;注解，也就是Annotation，是Java 5 开始引入的特征，它提供了一种安全的类似注释的机制，用来将任何的信息或元数据与程序元素（类、方法、属性等）进行关联。&lt;br&gt;
Annotation通过Java反射机制来访问注解信息，相关类根据这些信息决定对这些程序元素采用什么行为。Java语言解释器在工作时会忽略这些注解，因此注解在JVM中是“不起作用”的，只能通过配套工具对这些注解类型的信息进行访问和处理。&lt;br&gt;
在软件框架或者工具中常常用到注解，比如Struts，JUnit，TestNG，Spring等。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;定义注解&#34;&gt;定义注解&lt;/h2&gt;
&lt;p&gt;注解使用关键字&lt;code&gt;@interface&lt;/code&gt;定义，而不是&lt;code&gt;interface&lt;/code&gt;。所有注解都是继承的&lt;code&gt;java.lang.annotation.Annotation&lt;/code&gt;接口，但是如果直接创建一个interface继承&lt;code&gt;java.lang.annotation.Annotation&lt;/code&gt;接口并不是定义一个注解类型。&lt;br&gt;
创建的注解类型中可以定义常量、静态成员，也可以定义方法。但是这些方法的声明里必须是无参数、无抛出异常的。方法的返回值必须为primitive类型（包括&lt;code&gt;String&lt;/code&gt;类型）、&lt;code&gt;Class&lt;/code&gt;类型、枚举类型、注解类型中的一个或者以上之一组成的一维数组。方法的后面可以用default和一个值来表示这个方法的默认返回值，注意，默认值不能设为null。只有返回值是&lt;code&gt;Class&lt;/code&gt;的方法可以在注解类型中使用泛型，因为该方法能够将各种类型通过类转换变成&lt;code&gt;Class&lt;/code&gt;。&lt;br&gt;
举一个定义注解的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Property{
    boolean nullable default false;
    String value default &amp;quot;&amp;quot;;
}

public class User{
    @Property(value = &amp;quot;林雷&amp;quot;)
    private String userName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如以上先定义了一个注解类型&lt;code&gt;@Property&lt;/code&gt;，然后定义一个Bean，也就是User类，其中有个userName的属性，对其用&lt;code&gt;@Property&lt;/code&gt;注解进行了标记，那么也就是说userName被标记为值为“林雷”，而且它是不可空的，&lt;code&gt;@Property&lt;/code&gt;后面括号里用等号连接的是个赋值操作，等号左边的内容实际上就是注解中定义的方法，等号右边的内容就是让注解中对应的方法返回一个什么样的值，如果不定义的话就采用注解里设的默认值。可以定义多个，以逗号隔开。&lt;/p&gt;
&lt;h2 id=&#34;三种标准注解&#34;&gt;三种标准注解&lt;/h2&gt;
&lt;p&gt;从Java 5开始就已经自带了三种标准注解，如下：&lt;/p&gt;
&lt;h3 id=&#34;override&#34;&gt;@Override&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Override&lt;/code&gt;是一种标记型注解。表示当前的方法定义覆盖了父类中的方法，起到断言作用，方法签名必须相同（即方法名、参数类型、参数顺序、参数个数都一样），否则无法通过编译。这个注解常用作试图覆盖父类方法而又写错了方法名时的一个保障性校验。&lt;/p&gt;
&lt;h3 id=&#34;deprecated&#34;&gt;@Deprecated&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Deprecated&lt;/code&gt;是一种标记型注解。对不应该再使用的程序元素添加该注解，当调用被注解的方法时，在编译器会显示提示信息不鼓励使用被这个注解了的程序元素。&lt;br&gt;
注意，该注解与JavaDoc注释中的&lt;code&gt;@deprecated&lt;/code&gt;标记是有区别的：前者是用于Java编译器识别的，而后者是在生成文档时被JavaDoc识别。&lt;/p&gt;
&lt;h3 id=&#34;suppresswarnings&#34;&gt;@SuppressWarnings&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此注解能告诉Java编译器关闭对类、方法及成员变量的警告。有时编译时会提出一些警告，对于这些警告有的隐藏着Bug，有的是无法避免的，对于某些不想看到的警告信息，可以通过这个注解来屏蔽。&lt;code&gt;@SuppressWarning&lt;/code&gt;不是一个marker annotation。它有一个类型为&lt;code&gt;String[]&lt;/code&gt;的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对&lt;code&gt;@SuppressWarings&lt;/code&gt;有效，同时编译器忽略掉无法识别的警告名。&lt;/p&gt;
&lt;h2 id=&#34;四种元注解&#34;&gt;四种元注解&lt;/h2&gt;
&lt;h3 id=&#34;target&#34;&gt;@Target&lt;/h3&gt;
&lt;p&gt;表示注解可以用在什么地方，它的值是ElementType枚举中的枚举类型：&lt;br&gt;
CONSTRUCTOR 构造器声明；&lt;br&gt;
FIELD 域声明；&lt;br&gt;
METHOD 方法声明；&lt;br&gt;
TYPE 类、接口或enum声明；&lt;br&gt;
PARAMETER 参数声明；&lt;br&gt;
LOCAL_VARIABLE 局部变量声明；&lt;br&gt;
ANNOTATION_TYPE 注释类型声明&lt;br&gt;
PACKAGE 包声明&lt;/p&gt;
&lt;h3 id=&#34;retention&#34;&gt;@Retention&lt;/h3&gt;
&lt;p&gt;表示需要在什么级别保存该注解信息。设值时需要提供java.lang.annotation.RetentionPolicy中的枚举类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum RetentionPolicy{
    SOURCE, //编译程序处理完Annotation信息后就完成任务
    CLASS, //编译程序将Annotation储存于class中，但会被虚拟机丢弃，@Retention默认是Class级别
    RUNTIME //编译程序将Annotation储存于class中，虚拟机在运行期也保留注解，可以通过反射机制读取注解信息
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;documented&#34;&gt;@Documented&lt;/h3&gt;
&lt;p&gt;将此注解包含到Javadoc中。&lt;/p&gt;
&lt;h3 id=&#34;inherited&#34;&gt;@Inherited&lt;/h3&gt;
&lt;p&gt;允许子类继承父类的注解。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在自定义注解的时候可以综合使用这四个元注解定义自己定义的注解的作用范围等信息。&lt;/p&gt;
&lt;h2 id=&#34;通过反射加载注解&#34;&gt;通过反射加载注解&lt;/h2&gt;
&lt;p&gt;还用之前举的例子，下面简单写个通过反射获得注解信息的例子。&lt;br&gt;
先定义注解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface Property {
    boolean nullable() default false;

    String value() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义POJO Bean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {

    @Property(value = &amp;quot;李雷&amp;quot;)
    private String username;

    @Property(nullable = true, value = &amp;quot;test@a.com&amp;quot;)
    private String email;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来就是获取这个注解了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.Field;

public class AnnotationTest {
    public static void main(String[] args){
        //获取User类的Class实例
        Class&amp;lt;?&amp;gt; clazz = User.class;
        //获取这个类的所有属性
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields){
            //判断这个属性中是否有Property注解
            if (field.isAnnotationPresent(Property.class)){
                Property property = field.getAnnotation(Property.class);
                System.out.println(field.getName()+&amp;quot;: &amp;quot;+property.nullable()+&amp;quot; &amp;quot;+property.value());
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行之后结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;username: false 李雷
email: true test@a.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的结果也可以看到，即使类中的属性定义为private类型，也可以通过注解对其进行标记赋值，这个方法在Spring等框架中常常使用。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://computerdragon.blog.51cto.com/6235984/1210969&#34;&gt;Java注解annotation用法和自定义注解处理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/mandroid/archive/2011/07/18/2109829.html&#34;&gt;Java基础之理解Annotation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itzhai.com/java-based-notebook-annotation-annotation-introduction-and-use-custom-annotations.html&#34;&gt;Java基础笔记 - Annotation注解的介绍和使用 自定义注解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Java中的注解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/exit-command-in-linux/"" data-c="
          &lt;p&gt;本文亦发布于&lt;a href=&#34;https://thinkbucket.cn/blog/2020/02/11/linux-exit/&#34;&gt;ThinkBucket&lt;/a&gt;。&lt;br&gt;
我们在 Linux 的命令行里面会用到&lt;code&gt;exit&lt;/code&gt;，比方说退出某个 shell。在 shell 脚本中这个命令可以终止脚本的执行。&lt;code&gt;exit&lt;/code&gt;后面是可以接一个数字表示退出时候的状态。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;code&gt;exit(0)&lt;/code&gt;一般表示成功结束，其他的是不成功的，如&lt;code&gt;exit(1)&lt;/code&gt;。对于一些系统程序而言，这些错误编号是有含义的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;exit 错误编号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;一般性未知错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;不适合的 shell 命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;126&lt;/td&gt;
&lt;td&gt;命令不可执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;没找到命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;无效的退出参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128 + x&lt;/td&gt;
&lt;td&gt;与 Linux 信号&lt;code&gt;x&lt;/code&gt;相关的严重错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;130&lt;/td&gt;
&lt;td&gt;通过&lt;code&gt;Ctrl + C&lt;/code&gt;终止的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;正常范围之外的退出状态码&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不带数字直接&lt;code&gt;exit&lt;/code&gt;，脚本的退出状态码就由脚本里面最后执行的命令来决定（即&lt;code&gt;exit&lt;/code&gt;之前的命令）。&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;exit $?&lt;/code&gt;，它和&lt;code&gt;exit&lt;/code&gt;是一样的作用。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://man.linuxde.net/exit&#34;&gt;Linux 命令大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ixdba.net/docs/shell/exit-status.html&#34;&gt;退出和退出状态码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Linux 中的 exit 命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/install-oracle-db-in-suse/"" data-c="
          &lt;p&gt;从官网下载64位rpm安装包，解压，打开terminal进入rpm安装包所在目录，输入&lt;code&gt;rpm -i install oralce-xe-xxx.rpm&lt;/code&gt;&lt;br&gt;
然后会提示输入&lt;code&gt;/etc/init.d/oracle-xe configure&lt;/code&gt;，按照步骤照做。&lt;br&gt;
在设置http端口的时候，默认为8080，可能会影响jboss、tomcat，可以改成8088。&lt;/p&gt;
&lt;p&gt;配置ORACLE_HOME和path:&lt;br&gt;
打开&lt;code&gt;/etc/bash.bashrc.local&lt;/code&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export ORACLE_HOME=/u01/app/oracle/product/11.2.0/xe
export PATH=$PATH:$ORACLE_HOME/bin:
export ORACLE_SID=XE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置结束后，在尝试sqlplus连接数据库的时候会出现密码不正确或者权限不够等问题，因为oracle express在安装的时候讲ORACLE用户作为这个软件的owner，而这个owner没有加到dba组里。&lt;br&gt;
可以输入命令&lt;code&gt;/etc/group&lt;/code&gt;查看当前系统中的用户组，&lt;code&gt;/etc/passwd&lt;/code&gt;查看系统中的用户。遇到一个问题就是实际上并不存在ORACLE这个用户，然后采取了一个方法，就是&lt;code&gt;vi /etc/group&lt;/code&gt;强制在dba这个组加上ORACLE这个用户。&lt;br&gt;
打开新的终端，&lt;code&gt;su - oracle&lt;/code&gt;从而切换到ORACLE用户，然后输入&lt;code&gt;groups&lt;/code&gt;，可以查看它属于dba组。（其实挺奇怪，&lt;code&gt;su - oracle&lt;/code&gt;可以切换到oracle用户，但是之前在其他地方找不到这个用户）&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;/etc/init.d/oracle-xe start&lt;/code&gt;(或&lt;code&gt;lsnrctl start&lt;/code&gt;)启动oracle。&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;sqlplus system/密码&lt;/code&gt;，进行连接，如果说用户名或密码错误的话，可以输入&lt;code&gt;sqlplus / as sysdba&lt;/code&gt;(注意，需要在ORACLE用户下)，然后建立连接后，输入&lt;code&gt;alter user system identified by 密码&lt;/code&gt;;&lt;br&gt;
quit后在以&lt;code&gt;sqlplus system/密码&lt;/code&gt;就能连上了。&lt;/p&gt;
&lt;p&gt;密码不正确或者权限不够等问题，应该也可以通过更改oracle安装后的目录及文件的owner来实现，这里就暂不讨论。&lt;/p&gt;
&lt;p&gt;还有可能和&lt;code&gt;$ORACLE_HOME/network/admin&lt;/code&gt;下面的几个ora文件有关。附件里列出了它们。&lt;/p&gt;
&lt;p&gt;如果安装的时候忘了改http端口，可以输入如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sqlplus /nolog
connect
(input username and password)
exec dbms_xdb.sethttpport(8088)
&lt;/code&gt;&lt;/pre&gt;
">SUSE Linux中安装Oracle数据库</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/references-in-java/"" data-c="
          &lt;p&gt;Java中的引用主要有以下几种类型：&lt;br&gt;
• 强引用（StrongReference）：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。&lt;/p&gt;
&lt;p&gt;• 软引用（SoftReference）：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;• 弱引用（WeakReference）：弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;• 虚引用（PhantomReference）：“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面主要来谈谈软引用。&lt;br&gt;
对于软引用对象本身，至少有两个强引用指向它：由应用创建的原始的强引用，还有就是JVM创建的在所引对象队列上的一个新的强引用。软引用本质上是一个比较大的、最近最久未用的对象池。获得较好性能的关键是确保它们会被及时清理。&lt;/p&gt;
&lt;p&gt;不要使用太多软引用，它们很容易填满整个堆。&lt;/p&gt;
&lt;p&gt;当问题中的所引对象会同时被几个线程使用时，应该考虑弱引用。否则，弱引用很可能会被垃圾收集器回收：只有弱引用的对象在每个GC周期都可以回收。当强引用被移除时，弱引用会立即释放。&lt;/p&gt;
&lt;p&gt;软：只要有足够内存，而且看上去有人会偶尔访问它，就留着它。&lt;br&gt;
弱：只要有其他人对这个对象感兴趣就让我知道它在哪，但是如果他们不再需要它了，就丢了，我自己会重新创建。&lt;/p&gt;
&lt;p&gt;软引用的对象通常可以存活几分钟甚至几小时，但是只要所引读写仍然存在，弱引用对象就会一直存活（下一个GC周期会清理）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Java中，集合类经常是内存泄露的根源。比如某个应用将对象放入一个HashMap对象中，但从不移除。随着时间推移，这个HashMap对象会越来越大，而且消耗堆。&lt;/strong&gt;&lt;/p&gt;
">Java中的几种引用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/abstract-class-and-interface/"" data-c="
          &lt;p&gt;本文亦发布于&lt;a href=&#34;https://thinkbucket.cn/docs/java/object-oriented-programming/abstract-class-interface&#34;&gt;ThinkBucket&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;抽象类和接口是 Java 面向对象编程中非常重要的元素，在面向接口的编程中两者更是经常用到。类是对象的模版，抽象类和接口可以看作是具体的类的模版。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;抽象类&#34;&gt;抽象类&lt;/h2&gt;
&lt;p&gt;如果一个 &lt;code&gt;class&lt;/code&gt; 用 &lt;code&gt;abstract&lt;/code&gt;修饰，它就是抽象类。除了正常的方法定义外，抽象类里的方法可以是空的，直接以分号结尾，没有具体执行代码，这个方法就是抽象方法，它必须用 &lt;code&gt;abstract&lt;/code&gt; 修饰。&lt;/p&gt;
&lt;p&gt;我们无法实例化一个抽象类，抽象类必须通过一个具体的子类实例化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Person p = new Person(); // 编译错误
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Demo {
  public static void main(String[] args) {
    Teacher t = new Teacher();
    t.setName(&amp;quot;王明&amp;quot;);
    t.work();
    Driver d = new Driver();
    d.setName(&amp;quot;小陈&amp;quot;);
    d.work();
  }
}
// 定义一个抽象类
abstract class People {
  private String name; // 实例变量
  // 共有的 setter 和 getter 方法
  public void setName(String name){
    this.name = name;
  }
  public String getName(){
    return this.name;
  }
  // 抽象方法
  public abstract void work();
}

class Teacher extends People {
  // 必须实现该方法
  public void work() {
    System.out.println(&amp;quot;我的名字叫&amp;quot; + this.getName() + &amp;quot;，我正在讲课，请大家不要东张西望…&amp;quot;);
  }
}

class Driver extends People {
  // 必须实现该方法
  public void work() {
    System.out.println(&amp;quot;我的名字叫&amp;quot; + this.getName() + &amp;quot;，我正在开车，不能接听电话…&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了可以拥有抽象方法和不能实例化的特性外，抽象类拥有普通类的所有特点，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以继承父类（但抽象类的父类必须是抽象类）&lt;/li&gt;
&lt;li&gt;可以实现接口&lt;/li&gt;
&lt;li&gt;可以写 &lt;code&gt;private&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt;、 &lt;code&gt;public&lt;/code&gt; 的成员变量和方法&lt;/li&gt;
&lt;li&gt;可以写 &lt;code&gt;static final&lt;/code&gt; 的常量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口&#34;&gt;接口&lt;/h2&gt;
&lt;p&gt;接口一般是描述一些行为，是对接口使用者的一个承诺。在面向接口的编程中，接口的使用者只需要调用接口的某个方法达到其目的，而无需关心是哪个类实现的。接口的一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Person {
  void run();
  String getName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口的一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有方法都是 &lt;code&gt;public abstract&lt;/code&gt; 的，必须被接口的实现类实现（Java 8之前）&lt;/li&gt;
&lt;li&gt;所有的变量都是 &lt;code&gt;public static final&lt;/code&gt; 的，其实就是常量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;strong&gt;tip&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为接口定义的所有方法默认都是 &lt;code&gt;public abstract&lt;/code&gt; 的，所以这两个修饰符不需要写出来（写不写效果都一样）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个具体的 &lt;code&gt;class&lt;/code&gt; 去实现一个 &lt;code&gt;interface&lt;/code&gt; 时，需要使用 &lt;code&gt;implements&lt;/code&gt; 关键字。举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Student implements Person {
  private String name;

  public Student(String name) {
    this.name = name;
  }

  @Override
  public void run() {
    System.out.println(this.name + &amp;quot; run&amp;quot;);
  }

  @Override
  public String getName() {
    return this.name;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;空接口&#34;&gt;空接口&lt;/h3&gt;
&lt;p&gt;我们常常看到 Java 程序里有定义的一些空接口，那么空接口是什么作用呢？&lt;/p&gt;
&lt;p&gt;空接口的主要是用来做判断的，也就是作为一个标记。为了判断某一个类是否满足其筛选条件时可以做一个空接口，然后利用 &lt;code&gt;instanceof&lt;/code&gt; 方法来判断某一类是否使用了该接口，以达到你要筛选指定类型类的需求。&lt;/p&gt;
&lt;h2 id=&#34;接口和抽象类比较&#34;&gt;接口和抽象类比较&lt;/h2&gt;
&lt;h3 id=&#34;相同点&#34;&gt;相同点&lt;/h3&gt;
&lt;p&gt;从某种角度讲，接口是一种特殊的抽象类，它们有很大的相似处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，&lt;strong&gt;使方法的定义和实现分离&lt;/strong&gt;，这样做对于代码有松散耦合的好处。&lt;/li&gt;
&lt;li&gt;都不能被实例化。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;都能包含抽象方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;接口里只能有常量，而且会“污染”实现类里的作用域；抽象类可以拥有 &lt;code&gt;private&lt;/code&gt; 的变量，有一定程度的封装。&lt;/li&gt;
&lt;li&gt;接口只能继承接口；抽象类既可以继承抽象类，也可以实现接口。&lt;/li&gt;
&lt;li&gt;接口里的所有方法使用者都能直接调用；抽象类里可以封装一些 &lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt; 或者包访问级别的方法&lt;/li&gt;
&lt;li&gt;接口里的所有方法都是抽象的，没有方法体（Java 8 之前）；抽象类里的非抽象方法可以拥有方法体。&lt;/li&gt;
&lt;li&gt;一个实现类一旦继承了某个抽象类，可以实现别的接口，但是不能继承其他类了；而如果它实现了某个接口，还可以实现别的接口，也可以继承别的类。体为空），但抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现。&lt;/li&gt;
&lt;li&gt;接口是对行为的一种抽象，而抽象类是对类的抽象，包括属性、方法。继承抽象类的类往往是具有一些相似特点的类，而实现接口的类可以跨不同的域，仅仅实现了接口定义的契约。类继承抽象类像是一个 &lt;strong&gt;”is-a”&lt;/strong&gt; 特点，类实现接口像是 &lt;strong&gt;”like-a”&lt;/strong&gt; 特点。&lt;/li&gt;
&lt;li&gt;在设计时，对接口往往是自上而下的，先定义接口行为，然后再针对其做具体实现；抽象类往往是自下而上的，我们先知道子类后才对其进行抽象出父类。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Student implements Person, Hello { // 实现了两个interface
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口继承&#34;&gt;接口继承&lt;/h3&gt;
&lt;p&gt;一个 &lt;code&gt;interface&lt;/code&gt; 可以使用 &lt;code&gt;extends&lt;/code&gt; 继承自另一个 &lt;code&gt;interface&lt;/code&gt; 。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Hello {
  void hello();
}

interface Person extends Hello {
  void run();
  String getName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时， &lt;code&gt;Person&lt;/code&gt; 接口继承自 &lt;code&gt;Hello&lt;/code&gt; 接口，因此， &lt;code&gt;Person&lt;/code&gt; 接口现在实际上有 3 个抽象方法签名，其中一个来自继承的 &lt;code&gt;Hello&lt;/code&gt; 接口。&lt;/p&gt;
&lt;h3 id=&#34;类与接口的继承关系&#34;&gt;类与接口的继承关系&lt;/h3&gt;
&lt;p&gt;合理设计 interface 和 abstract class 的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在 abstract class 中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考 Java 的集合类定义的一组接口、抽象类以及具体子类的继承关系：&lt;/p&gt;
&lt;Img w=&#34;380&#34; src=&#39;https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/rt4hsL.png&#39; /&gt;
&lt;p&gt;在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List list = new ArrayList(); // 用List接口引用具体子类的实例
Collection coll = list; // 向上转型为Collection接口
Iterable it = coll; // 向上转型为Iterable接口
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;接口里的默认方法&#34;&gt;接口里的默认方法&lt;/h2&gt;
&lt;p&gt;从 Java 8 开始，Java 为接口提供了默认方法的功能，用 &lt;code&gt;default&lt;/code&gt; 关键字表示，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface InterfaceA {
  default void foo() {
    System.out.println(&amp;quot;InterfaceA foo&amp;quot;);
  }
}

class ClassA implements InterfaceA {
}

public class Test {
  public static void main(String[] args) {
    new ClassA().foo(); // Will print &amp;quot;InterfaceA foo&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ClassA&lt;/code&gt; 没有实现 &lt;code&gt;InterfaceA&lt;/code&gt; 的 &lt;code&gt;foo&lt;/code&gt; 方法，但是 &lt;code&gt;InterfaceA&lt;/code&gt; 提供了默认实现，当 &lt;code&gt;ClassA&lt;/code&gt; 的实例调用到 &lt;code&gt;foo&lt;/code&gt; 方法时，实际上是调用了接口里的默认实现。&lt;/p&gt;
&lt;h3 id=&#34;为什么引入默认方法&#34;&gt;为什么引入默认方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在 Java 8 之前&lt;/strong&gt;，接口和实现类之间高度耦合，当接口中添加一个方法时，它的所有实现类都需要修改，否则会发生编译错误。无法在不破坏现有实现的条件下向接口添加&lt;strong&gt;新&lt;/strong&gt;方法。&lt;/p&gt;
&lt;p&gt;:::&lt;strong&gt;tip&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To use default method, JDK &amp;gt;= 1.8 is a must.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Java 8 里面，引入默认方法的意图是&lt;strong&gt;允许向现有接口添加方法&lt;/strong&gt;，Java 8 里有一个重要新功能： lamda 表达式，这需要升级旧接口并保持向后兼容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] array = new String[] {
  &amp;quot;hello&amp;quot;,
  &amp;quot;, &amp;quot;,
  &amp;quot;world&amp;quot;,
};
List&amp;lt;String&amp;gt; list = Arrays.asList(array);
list.forEach(System.out::println); // additional method in JDK 1.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;forEach&lt;/code&gt; 方法是 Java 8 里为 &lt;code&gt;Iterable&lt;/code&gt; 接口添加的新默认方法，实现类不需要做任何修改就可以直接用它。下面是 &lt;code&gt;Iterable&lt;/code&gt; 接口里的 &lt;code&gt;forEach&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang;

import java.util.Objects;
import java.util.function.Consumer;

public interface Iterable&amp;lt;T&amp;gt; {
  default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
    Objects.requireNonNull(action);
    for (T t : this) {
      action.accept(t);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多细节，可以参考这篇文章：https://ebnbin.com/2015/12/20/java-8-default-methods/&lt;/p&gt;
&lt;p&gt;:::&lt;strong&gt;caution&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;向现有接口添加新方法充满了风险。在存在默认方法的情况下，接口的现有实现&lt;strong&gt;可能&lt;/strong&gt;编译没有错误或警告，但在运行时会失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;:::&lt;strong&gt;good&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除非有必要，否则应避免使用默认方法向现有接口添加新方法，在这种情况下，你应该认真考虑一下现有接口实现是否会被默认方法实现破坏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上都是需要注意的，但是默认方法对于在创建接口时提供标准方法实现非常有用，它能简化实现接口的任务。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/30412517/&#34;&gt;Effective Java, By Joshua Bloch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ebnbin.com/2015/12/20/java-8-default-methods/&#34;&gt;Java 8 Default Methods, By Ebn Zhang&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">Java 抽象类和接口</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/add-icon-to-ubuntu-dash/"" data-c="
          &lt;p&gt;我们建设以创建 Eclipse 程序图标为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进入图标存放目录|：&lt;code&gt;cd /usr/share/applications&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建文件并编辑：&lt;code&gt;sudo gedit eclipse.desktop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[Desktop Entry]
Name=eclipse
Name[zh_CN]=eclipse
Comment=eclipse Client
Exec=/usr/programa/tools/eclipse/eclipse
Icon=/usr/programa/tools/eclipse/icon.xpm
Terminal=false
Type=Application
Categories=Application;
Encoding=UTF-8
StartupNotify=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点参数说明（注意：路径使用完整路径）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Name 为你想要显示在 Launcher 中的名称&lt;/li&gt;
&lt;li&gt;Comment 为说明。&lt;/li&gt;
&lt;li&gt;Exec 为程序执行位置&lt;/li&gt;
&lt;li&gt;Icon 为图标所在路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，打开 Dash，在顶部搜索框搜索 eclipse，此时你应该能搜到它，先单击试一下看能不能打开，如果可以打开，拖到该图标启动器上，下次就可以直接从启动器打开了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://my.oschina.net/Obahua/blog/110612&#34;&gt;Ubuntu 将 Sublime Text 添加到 Launcher 和其它方式 原&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/enein/articles/2818864.html&#34;&gt;Ubuntu 12.10 程序图标放到启动器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-26404477-id-3462663.html&#34;&gt;向Ubuntu Dash中添加图标&lt;/a&gt;\&lt;/li&gt;
&lt;/ul&gt;
">Ubuntu中给Dash创建图标</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/final-finally-finalize-in-java/"" data-c="
          &lt;h2 id=&#34;final&#34;&gt;final&lt;/h2&gt;
&lt;p&gt;final是Java里面的一个关键字，可以用来修饰成员变量、局部变量、类、方法。&lt;/p&gt;
&lt;p&gt;final修饰的类不能被继承，比方说String，Integer以及其他包装类。&lt;/p&gt;
&lt;p&gt;final修饰的方法不能被重写。&lt;/p&gt;
&lt;p&gt;final修饰的基本类型变量不可以被修改，修饰的其他类型变量的引用不能被修改。也就是说如果&lt;code&gt;final int a=10&lt;/code&gt;，那么这个&lt;code&gt;a&lt;/code&gt;变量以后就不能再给它赋值成别的值了。而修饰的非基本类型变量的话，该变量的引用指向的堆里面的内容是可以修改的，比如说：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;final List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&amp;quot;item1&amp;quot;);
list.add(&amp;quot;item2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述操作是合法的。&lt;/p&gt;
&lt;p&gt;final修饰的String类型再第一次赋值之后，也不能再重新赋值了，因为不管是采用下面哪种方式创建的String对象，如果再次赋值，该对象指向的引用就会变化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;final String string1 = new String(&amp;quot;string1&amp;quot;);
final String string2 = &amp;quot;string2&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，匿名内部类如果需要用到外面的局部变量，该变量必须是final类型。&lt;/p&gt;
&lt;p&gt;final修饰局部变量时，局部变量必须在声明时就赋值。&lt;/p&gt;
&lt;p&gt;没有在声明时初始化的final成员变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。&lt;/p&gt;
&lt;p&gt;接口中的声明的变量始终都是 &lt;code&gt;publis static final&lt;/code&gt; 类型的。&lt;/p&gt;
&lt;h2 id=&#34;finally&#34;&gt;finally&lt;/h2&gt;
&lt;p&gt;finally用于在异常处理时处理一些收尾工作，比方说输入输出流、JDBC数据库连接打开后不管成功成功还是失败，都要将其关闭，释放资源。常用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;try{
  ......
}catch (Exception e){
  ......
}finally {
  ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;finalize&#34;&gt;finalize&lt;/h2&gt;
&lt;p&gt;finalize是Object类中定义的方法，用于垃圾回收。Object类中该方法的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;protected void finalize() throws Throwable { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当对某个对象垃圾收集确定没有更多引用时被垃圾收集器调用。子类重写&lt;code&gt;finalize&lt;/code&gt;方法来处理系统资源或者做其他清理工作。&lt;/p&gt;
&lt;p&gt;一般来说，finalize方法都是在Java虚拟机发现去除那些已经被执行了finalize的对象之外，没有任何活动的线程能够引用到该对象的时候调用。finalize方法可以做任何事情，包括使这个对象可以被其他进程访问；但是通常finalize的目的是在对象被真正回收之前做一些清理工作。例如，一个对象的finalize方法表示输入/输出连接可能在对象被永久回收前执行显式I/O事务来中断连接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt;类的finalize方法不执行特别的操作，它只是简单地返回。&lt;code&gt;Object&lt;/code&gt;子类可以重写这个方法。&lt;/p&gt;
&lt;p&gt;Java编程语言不保证对于任何给定的对象哪个线程将调用finalize方法，但是它保证执行finalize的线程在调用finalize方法后不会一直保持任何用户可见的同步锁。如果finalize方法中抛出一个没有catch的异常，这个异常将会被忽略并且对象的finalize将终止。&lt;/p&gt;
&lt;p&gt;在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。&lt;/p&gt;
&lt;p&gt;对于任何给定的对象，finalize最多被Java虚拟机执行一次。&lt;/p&gt;
&lt;p&gt;finalize方法抛出的任何异常将导致这个对象的终结操作停止，但也会被忽略。（抛出异常后，该对象还是不可以继续操作，不会影响其他对象，直到被虚拟机回收）&lt;/p&gt;
&lt;p&gt;建议尽量避免使用它，它不是C/C++中的析构函数，而是Java诞生时为了使c/c++程序员更容易接受它所做的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对对象的调用顺序。虽然注释中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种安慰，finalize()能做的所用工作，使用try-finally或者其他方式都可以做的更好，更及时。&lt;/p&gt;
&lt;h2 id=&#34;参考资源&#34;&gt;参考资源&lt;/h2&gt;
&lt;p&gt;JDK 1.7 源码&lt;/p&gt;
&lt;p&gt;Effective Java&lt;/p&gt;
&lt;p&gt;http://www.importnew.com/7553.html&lt;/p&gt;
&lt;p&gt;http://s1099.iteye.com/blog/1447714&lt;/p&gt;
&lt;p&gt;http://www.xuebuyuan.com/813760.html&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/cyp331203/article/details/44461021&lt;/p&gt;
&lt;p&gt;http://www.debugease.com/j2se/820363.html&lt;/p&gt;
&lt;p&gt;http://www.programgo.com/article/6855606134/&lt;/p&gt;
">Java中的final、finally和finalize</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/release-it-design-and-deploy-production-ready-software/"" data-c="
          &lt;h1 id=&#34;笔记&#34;&gt;笔记&lt;/h1&gt;
&lt;p&gt;早期决策对系统的最终形态影响最大，最初的决策最难以更改。这个时候团队对软件的最终结构最无知，但必须要做出某些不可更改的决策。&lt;/p&gt;
&lt;p&gt;敏捷强调及早发布并持续改进，意味着软件可以尽快投入使用，因为软件投入使用是唯一得知软件如何响应真实世界刺激的途径。&lt;/p&gt;
&lt;p&gt;发布1.0版是软件生命的开始，而不是项目的结束。1.0版发布后，你的生活质量取决于你在这个重要里程碑之前所做的选择。&lt;/p&gt;
&lt;p&gt;对于那些还没有被取消或废弃的系统来说，系统的运营时间要远远多于开发时间，靠承担经常性运营成本来避免一次性成本，是没有意义的。&lt;/p&gt;
&lt;p&gt;宕机后恢复服务是优先级最高的任务。重大事故之后的管理认知和管理事故本身同样重要。&lt;/p&gt;
&lt;p&gt;系统寿命受到的主要威胁是内存泄露和数据疯涨。&lt;/p&gt;
&lt;p&gt;有条墨菲定律，只要你不针对某种失效情况特别做测试，它一定会发生。&lt;/p&gt;
&lt;p&gt;最初的触发点，裂痕扩散的方式和损坏的结果，并称为故障模式。&lt;/p&gt;
&lt;p&gt;代码耦合得越紧，代码错误扩散的机会也越大。反之，代码越松散，就如同减震器一样越能消除而非扩大这种错误的影响。&lt;/p&gt;
&lt;p&gt;考虑下面各种可能存在的冲击和压力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果我不启动连接？&lt;/li&gt;
&lt;li&gt;如果连接需要10分钟？&lt;/li&gt;
&lt;li&gt;如果已经连接，那它如何断开连接？&lt;/li&gt;
&lt;li&gt;如果已经连接，而我却不能得到另一端的任何响应？&lt;/li&gt;
&lt;li&gt;如果需要2分钟来回应我的查询请求？&lt;/li&gt;
&lt;li&gt;如果同时有10000个请求？&lt;/li&gt;
&lt;li&gt;如果网络陷入蠕虫的攻击而瘫痪，而我要将关于SQLException异常发生的错误信息写入日志时，我的磁盘已满？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络永远是不可靠的，超时是让你放弃等待你认为不会到来的响应的一种简单机制。设置合理的超时可以隔离故障，在其他系统、子系统或设备中的问题不会成为你的问题。所有阻塞线程的资源池都应设置一个超时，以确保不管资源最后是否可用，线程都可以被解除阻塞。如果不这么做，就可能会永远等待了。&lt;/p&gt;
&lt;p&gt;电路中的保险丝，自己先失效，从而控制整体失效。但是有人自己使用高电流低电阻的保险丝，从而不起到保险作用。软件系统中也可以使用断路器来保护。检测过度使用，然后先失效（跳闸），可以再重新设置恢复系统使用。&lt;/p&gt;
">发布！软件的设计与部署</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/handle-password-expire-in-oracle/"" data-c="
          &lt;p&gt;Oracle的用户密码默认是有一定的有效期限，前一阵子有提示密码快过期但是没理睬，于是等过期之后就无法用那个用户名连接oracle数据库了。&lt;/p&gt;
&lt;p&gt;首先看看服务器里面的数据库连接配置使用了哪些用户名和密码，然后进入oracle用system用户连接，接下来，执行下面的SQL语句查看当前数据库中所有用户的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT USERNAME,ACCOUNT_STATUS FROM DBA_USERS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询结果类似这样：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;USERNAME&lt;/th&gt;
&lt;th&gt;ACCOUNT_STATUS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TEST1&lt;/td&gt;
&lt;td&gt;OPEN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEST2&lt;/td&gt;
&lt;td&gt;LOCKED&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEST3&lt;/td&gt;
&lt;td&gt;EXPIRED &amp;amp;LOCKED&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SYSTEM&lt;/td&gt;
&lt;td&gt;LOCKER&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果嫌密码总是会过期比较麻烦的话，可以执行下面的SQL语句，让密码生命周期不受限制：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对已经过期的用户，如TEST3，需要重置它的密码（如密码设为test3）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER USER TEST3 IDENTIFIED BY test3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后解除用户的锁定，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER USER TEST3 ACCOUNT UNLOCK;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hecpv.wordpress.com/2014/10/16/how-to-solve-ora-28001-the-password-has-expired/&#34;&gt;https://hecpv.wordpress.com/2014/10/16/how-to-solve-ora-28001-the-password-has-expired/&lt;/a&gt;&lt;/p&gt;
">Oracle用户密码过期解决</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/reetrantlock-in-java/"" data-c="
          &lt;h2 id=&#34;类说明&#34;&gt;类说明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ReetrantLock&lt;/code&gt;是一个可重入排它&lt;code&gt;Lock&lt;/code&gt;，和使用&lt;code&gt;synchronized&lt;/code&gt;方法和语句的隐式监视器锁有着相同的基本行为和语义，但是有着扩展性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;由上次成功加锁但是还没有解锁的线程所持有。在锁没有被其他线程持有时，一个线程调用&lt;code&gt;lock&lt;/code&gt;将返回成功获取锁。如果当前线程已经持有锁那么该方法将立即返回。这个可以使用方法&lt;code&gt;isHeldByCurrentThread&lt;/code&gt;和&lt;code&gt;getHoldCount&lt;/code&gt;检查。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;这个类的构造器接收一个可选的公平性参数。当设为 true 时，在争用的情况下，锁倾向于授权给等待时间最长的线程。另外，这个锁不保证任何特定访问顺序。使用被多个线程访问的公平锁的程序将呈现比使用默认设置的情况较低的总吞吐量（也就是变慢了，通常是慢很多），但是在获取锁和保证不饥饿的时间上有较小的方差。&lt;/p&gt;
&lt;p&gt;公平锁可以保证锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程饥饿，但是较少线程切换，保证了很大的吞吐量。&lt;/p&gt;
&lt;p&gt;同样需要注意的是，不计时的&lt;code&gt;tryLock()&lt;/code&gt;方法不赞成公平设置。如果锁是可用的它将成功获得锁，而不管其他线程是否正在等待。&lt;/p&gt;
&lt;p&gt;建议实践时永远在&lt;code&gt;lock&lt;/code&gt;后面立即跟上一个&lt;code&gt;try&lt;/code&gt;块，大多数典型的在构造之前/之后的情况是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class X{
	private final ReentrantLock lock = new ReentrantLock();
	//...
	public void m(){
		lock.lock(); // block until condition holds
		try{
			// ... method body
		} finally {
			lock.unlock();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了实现&lt;code&gt;Lock&lt;/code&gt;接口，这个类定义了大量 public 和 protected 方法来检查锁的状态。其中有一些方法只用于仪表和监控。&lt;/p&gt;
&lt;p&gt;这个类的序列化和内置锁的行为方式一致：反序列化的锁是处于解锁状态，在序列化的时候不管当前它的状态。&lt;/p&gt;
&lt;p&gt;这个锁支持相同线程递归锁最大2147483647次。尝试超过这个限制将导致从加锁方法抛出&lt;code&gt;Error&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;JDK 1.7&lt;/p&gt;
">Java中的可重入锁ReetrantLock</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/readwrite-lock-in-java/"" data-c="
          &lt;p&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;是&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;下面的接口，其内部方法结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public interface ReadWriteLock{
	Lock readLock();
	Lock writeLock();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;
&lt;p&gt;一个&lt;code&gt;ReadWriteLock&lt;/code&gt;维护一组关联的锁，一个用于只读的操作，另一个用来写。读锁可以被多个读线程同时持有，只要当前没有写线程。而写锁是排它的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;的所有实现必须保证&lt;code&gt;writeLock&lt;/code&gt;操作的内存同步影响（在&lt;code&gt;Lock&lt;/code&gt;接口中定义的），也保持关联的&lt;code&gt;readLock&lt;/code&gt;的影响。也就是说，一个成功获取读锁的线程将看到写锁之前版本所做的所有更新。&lt;/p&gt;
&lt;p&gt;读写锁访问共享数据比允许一个排它锁的并发性大很多。它利用一次只有一个线程可以修改共享数据，大多数情况下任意数量可以同步读取数据的现实（所以叫读线程）。理论上，允许读写锁的使用对并发性的提高将导致比使用一个排它锁带来性能提升。在实践中，这个并发改善只有在多处理器上能够完全实现，并且只有共享数据的访问模式是合适的。&lt;/p&gt;
&lt;p&gt;读写锁与排它锁是否提高性能取决于数据被读以及被修改的频率比较，读和写操作的持续时间，以及数据的争用情况——也就是说，同一时间尝试去读或尝试去写数据的线程的数量。例如，最初填充数据的集合此后很少被修改，而且频繁被搜索（比如一个目录），这就是读写锁使用的理想选择。但是，如果更新变的频繁，那么数据花费大量时间被排它锁定，那么就很少有并发上的提升。而且，如果读操作时间太短，读写锁实现的开销（读写锁所固有的比一个排它锁更复杂）可能在执行消耗中占主要部分，尤其是很多读写锁实现仍然通过一小段代码序列化所有线程。最终，只有分析和测量才能确定使用读写锁是否适合于你的应用。&lt;/p&gt;
&lt;p&gt;尽管读写锁的基本操作是很简单，实现需要做出很多政策决定，这个将影响给定应用中的读写锁的效率。这些政策包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当写线程释放写锁时，此时有读线程和写线程都在等待，确定是授权读锁还是写锁。通常倾向于给写线程，因为写操作一般比较短而且不频繁。通常不倾向于给读线程，因为如一般情况下那样如果读线程频繁写存活时间长读操作可能导致写的时间延迟。公平的讲，或者“按照顺序”的实现也是可以的。&lt;/li&gt;
&lt;li&gt;当一个读线程活跃且一个写线程等待时，确定是否有读线程请求读锁，然后授权读锁。倾向于给读线程可能使得写线程无限期延迟，而倾向于写线程可能减少并发的潜力。&lt;/li&gt;
&lt;li&gt;确定锁是否是可重入的：一个带写锁的线程能否重复获取写锁？当持有写锁的时候能否获取读锁？读锁本身是否可重入？&lt;/li&gt;
&lt;li&gt;写锁能否在不允许干预写线程的情况下降级到读锁？读锁能否升级到写锁，优先于其他等待的读线程和写线程？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你应该在评估你应用的给定实现时考虑以上全部4点。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;JDK 1.7&lt;/p&gt;
">Java中的ReadWriteLock</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://goroyal.github.io/post/about/"" data-c="
          &lt;ul&gt;
&lt;li&gt;后端工程师&lt;/li&gt;
&lt;li&gt;最近对分布式有点兴趣&lt;/li&gt;
&lt;li&gt;以前在上海和苏州，现在在上海和苏州之间&lt;/li&gt;
&lt;/ul&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>



</html>